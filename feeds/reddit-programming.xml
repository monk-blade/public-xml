<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="http://192.168.1.132/?platform=reddit&amp;subreddit=programming&amp;averagePostsPerDay=5&amp;content&amp;view=rss" rel="self" type="application/rss+xml"/><title>/r/programming</title><description>Hot posts in /r/programming (roughly 5 posts per day)</description><link>https://www.reddit.com/r/programming/</link><language>en-us</language><lastBuildDate>Sun, 07 Sep 2025 03:51:57 +0000</lastBuildDate><generator>Upvote RSS</generator><image><url>https://styles.redditmedia.com/t5_2fwo/styles/communityIcon_1bqa1ibfp8q11.png</url><title>/r/programming</title><link>https://www.reddit.com/r/programming/</link></image><item><link>https://www.pcworld.com/article/2898698/microsofts-first-ever-programming-language-was-just-open-sourced.html</link><title>Microsoft’s first-ever programming language was just open-sourced (pcworld.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/</guid><comments>https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 3 min | <a href='https://www.reddit.com/r/programming/comments/1na1zyo/microsofts_firstever_programming_language_was/'>Post permalink</a></p></section><section class='preview-image'><img src='https://www.pcworld.com/wp-content/uploads/2025/09/Commodore-64.jpg?quality=50&strip=all&w=1024' /></section><section class='parsed-content'><div><article><div><div><div><body><p>Did you know that, between 1976 and 1978, Microsoft developed its own version of the BASIC programming language? It was initially called Altair BASIC before becoming Microsoft BASIC, and it was designed for the 6502 (a microprocessor used in the Apple II, Atari 2600, VIC-20, Commodore 64, and Nintendo Entertainment System).</p><p>As of yesterday, Microsoft has released the version 1.1 source code of &ldquo;Microsoft BASIC for 6502 Microprocessor&rdquo; on <a href="https://go.skimresources.com?id=111346X1569483&amp;xs=1&amp;url=https://github.com/microsoft/BASIC-M6502&amp;xcust=2-1-2898698-1-0-0-0-0&amp;sref=https://www.pcworld.com/article/2898698/microsofts-first-ever-programming-language-was-just-open-sourced.html">GitHub</a>, which means you can freely view the assembly code and even download it if you want to.</p><p>Why did Microsoft publish this code? Because it has historical significance and was one of the pillars of modern software:</p><blockquote><p>This source code represents the foundation upon which the modern software industry was built. The techniques, patterns, and business models pioneered in this BASIC interpreter directly influenced:</p><ul> <li>The development of MS-DOS and subsequent Microsoft operating systems</li> <li>The standardization of programming language implementations</li> <li>The establishment of software licensing as a business model</li> <li>The democratization of computer programming</li> </ul> </blockquote><p>Microsoft&rsquo;s version of BASIC was one of the first programming languages that the general public came into contact with, making it an important milestone in computer history. While Microsoft BASIC is no longer used in earnest, its spirit lives on with Visual Basic .NET.</p></body></div><p>This article originally appeared on our sister publication <a href="https://www.pcforalla.se">PC f&ouml;r Alla</a> and was translated and localized from Swedish.</p><div><h3> <a href="https://www.pcworld.com/author/mikael_markander"> Author: Mikael Markander</a>, Contributor, PCWorld </h3><div><p>Mikael writes news across all our consumer tech categories. He has previously worked with Macworld, but today mainly writes for our sister sites PC f&ouml;r Alla and M3. Mikael has a firm grasp on which gadgets are released, and what is happening with the streaming services and the latest AI tools.</p></div></div></div></div></article> </div><div class="gallery"><p><img src="https://www.pcworld.com/wp-content/uploads/2025/09/1380047922-4.jpg?quality=50&amp;strip=all&amp;w=150&amp;h=150&amp;crop=1"></p></div></section>]]></description><pubDate>Sat, 06 Sep 2025 20:41:56 +0530</pubDate></item><item><link>https://codesmash.dev/why-i-ditched-docker-for-podman-and-you-should-too</link><title>I Ditched Docker for Podman (codesmash.dev)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n97mbo/i_ditched_docker_for_podman/</guid><comments>https://www.reddit.com/r/programming/comments/1n97mbo/i_ditched_docker_for_podman/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 13 min | <a href='https://www.reddit.com/r/programming/comments/1n97mbo/i_ditched_docker_for_podman/'>Post permalink</a></p></section><section class='preview-image'><img src='https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fstock%2Funsplash%2FqMVR2YhOVQI%2Fupload%2Fff5f28b79266f1737ba9b66092c75cde.jpeg%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng' /></section><section class='parsed-content'><div><h2>Beginnings</h2><p>I'm old enough to remember when Vagrant looked like a promised land where every development environment would look the same. Differences between language versions, as well as some unusual OS version differences, resulted in a few days of unproductive debugging of your development environment. I've had similar excitement when I started my first Docker Swarm (who uses that these days?!) - it felt revolutionary. Docker wasn't just a tool - it fundamentally changed how we thought about application development and deployment. Having a repeatable, separated environment from your local system was refreshing and looked like a superpower. It has become a must-have tool for every engineer. "<em>Just Dockerize it</em>" became my go-to solution for pretty much everything. Sure, architecture or defining a new Docker image could be a bit finicky at times, but hey, that's just how things worked. Is the persistent dockerd daemon eating upresources in the background with root privileges, just the price of doing business? I thought so.</p><p>If you are in this industry long enough, there is one pattern that emerges every day. Everybody begins questioning the "that's just how it's done" mentality. Along the way, the quiet Docker daemon running in the background felt less like a comfortable constant and more like a ticking bomb. More and more ways to explore this vulnerability emerged:</p><p><strong>2019-02-11 - CVE-2019-5736 (runC container escape):</strong> lets a process in a container overwrite the host&rsquo;s runc binary &rarr; full host compromise if exploited.</p><p><strong>2022-03-07 - CVE-2022-0847 &ldquo;Dirty Pipe&rdquo; (Linux kernel):</strong> read-only file overwrite in kernel; practical container-to-host abuse scenarios documented by Docker/Sysdig. </p><p><strong>2022-03-07 - CVE-2022-0492 (cgroups v1 release_agent):</strong> privilege escalation / container escape via cgroups v1; mitigations via seccomp/AppArmor/SELinux. </p><p><strong>2024-01-31 - CVE-2024-21626 (runC &ldquo;Leaky Vessels&rdquo;):</strong> fd leak + process.cwd issues enabling host FS access and potential escape; fixed in runC <strong>1.1.12</strong> (Docker Engine &ge; <strong>25.0.2</strong>). </p><p><strong>2024-02-01 - CVE-2024-23651/23652/23653 (BuildKit, &ldquo;Leaky Vessels&rdquo;):</strong> build-time issues that can affect host files; fixed in BuildKit <strong>0.12.5</strong>. </p><p><strong>2024-09-23 - In-the-wild cryptojacking campaign:</strong> attackers targeted exposed Docker APIs and microservices. </p><p><strong>2024-10-01 - Docker API swarm botnet campaign:</strong> cryptojacking via exposed Docker Engine API (<a href="https://securitylabs.datadoghq.com/articles/threat-actors-leveraging-docker-swarm-kubernetes-mine-cryptocurrency/">details</a>).</p><p>I had been seeking an alternative (I assumed that someone had already questioned the status quo), and that's how I stumbled into Podman territory. It began as casual curiosity - "<em>Hey, let me check out this thing</em>" - turned into a complete overhaul of my container workflows and pulled me into using Fedora in my home lab. And honestly? I wish I'd made the switch sooner.</p><h2>Daemonless</h2><p>Here's the fundamental issue that kept me awake: Docker's entire architecture is built around a persistent background service - the dockerd daemon. Whenever you run a docker command, you're actually talking to this daemon, which then does the heavy lifting. Sounds about right?</p><p>Yes?!</p><p>Or rather NO, because this daemon runs with root privileges. Always. And if something goes south with a daemon - innocent bug, a crash, or worst case scenario, a security exploit - your entire container ecosystem is potentially compromised. Not just the containers, daemon, or resource that you assigned to it, but the whole host system. It was a huge relief that Podman threw this model out the window. No daemon, no processes running in the background. When you run <code>podman run my-app</code>, the container becomes a direct child of your command. And it is running under your user privileges. Simple architecture change with huge implications:</p><h3>Security that actually makes sense:</h3><p>Remember those late-night security advisories about Docker daemon vulnerabilities (ex., when dockerd was misconfigured to listen on TCP:2375 without TLS, attackers could spin up privileged containers remotely)? With Podman, even if someone somehow escalates privileges inside a container to root level, they're still just an unprivileged user on the actual host. It significantly reduces the surface of an attack.</p><h3>No more single points of failure:</h3><p>Usually Docker daemon runs just fine. But when hiccups kick in - oh boy, hold your hats, as it will take down multiple containers at once. With Podman when one container crashed, the other kept running like nothing happened. It makes so much sense, and it's built in the spirit of hermetization.</p><h3>Lighter resource footprint:</h3><p>I had been surprised when my MacBook M2 Pro started to get warmer when left unattended. After a brief investigation (with Activity Monitor), it was obvious - Docker never knows when to stop. No constantly running daemon means less memory usage. Unfortunately, running a container using Podman can be a different story (ekhm: <a href="https://blog.podman.io/2025/06/podman-and-apple-rosetta/">blog.podman.io/2025/06/podman-and-apple-ros..</a>) - yet the thing is getting better: <a href="https://blog.podman.io/2025/08/podman-5-6-released-rosetta-status-update/">blog.podman.io/2025/08/podman-5-6-released-..</a>.</p><h2>Where Podman Really Shines</h2><p>Beyond the obvious daemon advantages, Podman brings some genuinely clever features that make day-to-day container work more pleasant:</p><p><strong>Systemd integration that doesn't suck:</strong> This one's huge if you're working on Linux servers (most of us are). Podman justgenerates proper systemd unit files. Boom, your container is a first-class citizen in the Linux service ecosystem. Boot dependencies, automatic restarts, resource limits - it all just works. I can run <code>podman generate systemd --name my-app</code> and get a clean service file. Afterwards, I can enable, start, stop, and monitor with standard systemctl commands. Say bye-bye to third-party process managers.</p><p><strong>Kubernetes alignment that's not just marketing:</strong> Since Red Hat (the folks behind Podman) is also a major Kubernetes contributor, the tool feels like it was designed with K8s in mind from day one. The native pod support isn't just a bolt-on feature - it's central to how Podman works. I do not need to run k3s or any local substitute for Kubernetes. Now, I can prototype multi-container applications as Podman pods locally. Then I just generate Kubernetes YAML directly from those pods with podman generate kube. My local development environment actually looks like what I'm going to deploy. This was revolutionary when I had to take over the responsibility of managing and developing a quite complex cluster.</p><p><strong>The Unix philosophy done right:</strong> Instead of trying to be everything to everyone, Podman focuses on running containers well and delegates specialized tasks to purpose - built tools. Need to build images with fine - grained control? That's Buildah. Want to inspect or copy images between registries? Skopeo's your friend. I can use the best tool for each job. I'm no longer stuck with whatever image-building quirks Docker decides to implement.</p><h2>The Migration That Wasn't Really a Migration</h2><p>Here's the part that surprised me most: switching from Docker to Podman was almost seamless. The Podman folks clearly understood that creating the next standard would not let them win the market, and they just adhered to the known CLI tool. I literally just aliased <code>docker=podman</code> in my shell and carried on with life. <code>podman run, podman build, podman ps</code> - they all behave exactly like their Docker counterparts. My existing Dockerfiles worked without modification. My muscle memory didn't need retraining.</p><p>Though there were a few places where I did hit differences that were actually improvements in disguise:</p><ul> <li><p>Privileged ports in rootless mode not working? Good! That's security working as intended. A reverse proxy setup is a better architecture anyway.</p></li> <li><p>Some volume permission quirks? Yes - but it's a small price, and again - if you do it right, you are limiting the scope of possible attack.</p></li> <li><p>A few legacy tools that expected the Docker socket? If there is no support by now, just remember that Podman can expose a Docker-compatible API if needed.</p></li> <li><p>If your Docker Compose workflow is overly complex, just convert it to Kubernetes YAML. We all use Kubernetes these days, so why even bother about this? Having the same layout for development and production is a huge bonus of doing so.</p></li> </ul> <h2>The Real-World Difference</h2><p>After six months of running Podman in production, here's what I've noticed:</p><p>I'm sleeping much better. Because I'm personally responsible for security, I do not have to check if every container is running in rootless mode. Something that I did not think I would benefit from is that my monitoring dashboards show cleaner resource usage patterns. Don't get me wrong - Docker isn't going anywhere. It has massive momentum, a mature ecosystem, and plenty of organizational inertia keeping it in place. But for new projects, or if you are able to make technical decisions based on merit rather than legacy, Podman represents a clear evolution in container technology. More secure by design, more aligned with Linux system management practices, and more thoughtfully architected for the way we actually deploy containers in 2025. The best way forward is to question the assumptions you didn't even realize you were making.</p><h2>FastAPI Migration Guide: From Docker to Podman</h2><p>Just to prove how easy transition can be, here's a practical walkthrough of migrating a FastAPI application from Docker to Podman. </p><h3>What You'll Need</h3><p>Your existing FastAPI project with its Dockerfile and requirements.txt</p><p>Podman is installed on your system:</p><ul> <li><p>Ubuntu/Debian: sudo apt update &amp;&amp; sudo apt install podman</p></li> <li><p>Fedora/RHEL: sudo dnf install podman</p></li> <li><p>macOS: Grab Podman Desktop for a GUI experience</p></li> <li><p>Windows: If you are not a C# developer - stop doing this to yourself and just use Linux: <a href="https://www.youtube.com/watch?v=S_RqZG6YR5M">youtube.com/watch?v=S_RqZG6YR5M</a></p></li> </ul> <h3>Step 1: Your Dockerfile Probably Just Works</h3><p>This is the beautiful part&mdash;Podman uses the same OCI container format as Docker. Your existing Dockerfile should work without any changes. Here's a typical FastAPI setup:</p><pre><code>FROM python:3.10-slim-buster WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir --upgrade -r requirements.txt COPY . . EXPOSE 8000 CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"] </code></pre> <h3>Step 2: Build Your Image</h3><p>Instead of docker build, just run:</p><pre><code>podman build -t my-fastapi-app:latest . </code></pre><p>That's it. Same flags, same behavior, same output. If you want to ease the transition, create an alias:</p><pre><code><span>alias</span> docker=podman </code></pre><p>Now you can use your existing docker build commands without thinking about it.</p><h3>Step 3: Run Your Container</h3><p>For development and testing:</p><pre><code>podman run --rm -p 8000:8000 --name my-fastapi-container my-fastapi-app:latest </code></pre><p>For background services:</p><pre><code>podman run -d -p 8000:8000 --name my-fastapi-container my-fastapi-app:latest </code></pre><p>Your app should be accessible at <a href="http://localhost:8000">localhost:8000</a> just like before.</p><p><strong>Important note:</strong> <em>By default, Podman runs in rootless mode. This is a security win, but it means you can't bind directly to privileged ports (below 1024). For production, you'll want a reverse proxy anyway, so this pushes you toward better architecture.</em></p><h3>Step 4: Production Deployment with Systemd</h3><p>This is where Podman really shines. Instead of wrestling with custom service management, generate a proper systemd unit file:</p><pre><code><span># First, make sure your container is running</span> podman run -d -p 8000:8000 --name my-fastapi-container my-fastapi-app:latest <span># Generate the systemd service file</span> mkdir -p ~/.config/systemd/user/ podman generate systemd --name my-fastapi-container &gt; ~/.config/systemd/user/my-fastapi-container.service <span># Enable and start the service</span> systemctl --user daemon-reload systemctl --user <span>enable</span> my-fastapi-container.service systemctl --user start my-fastapi-container.service </code></pre><p>Now your FastAPI app is managed like any other system service. It'll start on boot, restart on failure, and integrate with standard Linux logging and monitoring tools.</p><p>For server deployments where you want the service to persist even when you're not logged in:</p><p>loginctl enable-linger $(whoami)</p><h3>Step 5: Multi-Service Applications with Pods</h3><p>If your FastAPI app needs a database or other services, Podman's pod concept is cleaner than Docker Compose for simple setups:</p><pre><code><span># Create a pod that shares networking</span> podman pod create --name my-fastapi-pod -p 8000:8000 -p 5432:5432 <span># Run your FastAPI app in the pod</span> podman run -d --pod my-fastapi-pod --name fastapi-app my-fastapi-app:latest <span># Run PostgreSQL in the same pod</span> podman run -d --pod my-fastapi-pod --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword postgres:13 </code></pre><p>Now your FastAPI app can reach PostgreSQL at localhost:5432 because they share the same network namespace.</p><h3>Step 6: Docker Compose Compatibility</h3><p>For existing Docker Compose setups, you have options:</p><p><strong>Option 1:</strong> Use podman-compose as a drop-in replacement:</p><pre><code>pip install podman-compose podman-compose up -d </code></pre><p><strong>Option 2:</strong> Convert to Kubernetes YAML for a more cloud-native approach:</p><pre><code><span># Install kompose first</span> kompose convert -f docker-compose.yml -o k8s-manifest.yaml podman play kube k8s-manifest.yaml </code></pre><p>This second option is particularly nice if you're planning to deploy to Kubernetes eventually.</p><p><strong>Common Gotchas and Solutions</strong></p><p><strong>Volume permissions:</strong> If you hit permission issues with mounted volumes, remember that rootless containers run as your user. Make sure your user owns the directories you're mounting:</p><pre><code>chown -R $(id -un):$(id -gn) /path/to/your/data </code></pre><p><strong>Legacy tooling:</strong> Some tools expect the Docker socket at /var/run/docker.sock. Podman can provide a compatible API:</p><pre><code>systemctl --user <span>enable</span> podman.socket systemctl --user start podman.socket <span>export</span> DOCKER_HOST=unix://<span>$XDG_RUNTIME_DIR</span>/podman/podman.sock </code></pre><p><strong>Performance tuning:</strong> For production workloads, you might want to tune the rootless networking stack or consider running specific containers in rootful mode for maximum performance.</p><p>The migration process is usually much smoother than people expect. Start with a development environment, get comfortable with the workflow differences, then gradually move production workloads. The security and operational benefits make it worth the effort.</p></div></section>]]></description><pubDate>Fri, 05 Sep 2025 20:30:48 +0530</pubDate></item><item><link>https://www.youtube.com/watch?v=uBhe1Rvp4PI</link><title>Made a tutorial Python in 10 minutes for beginners (with homework) (youtube.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n92nbh/made_a_tutorial_python_in_10_minutes_for/</guid><comments>https://www.reddit.com/r/programming/comments/1n92nbh/made_a_tutorial_python_in_10_minutes_for/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 1 min | <a href='https://www.reddit.com/r/programming/comments/1n92nbh/made_a_tutorial_python_in_10_minutes_for/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>I just uploaded a short and beginner-friendly <strong>Python tutorial</strong> on YouTube where I explain the core concepts in only 10 minutes.<br/>Perfect if you&#39;re just starting out or need a quick refresher.<br/>Would love your feedback on whether you&#39;d like to see more quick lessons like this.</p><p>Thanks!</p></div><!-- SC_ON --></section><section class='embedded-media'><iframe width="356" height="200" src="https://www.youtube.com/embed/uBhe1Rvp4PI?feature=oembed&enablejsapi=1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen title="Learn Python in 10 minutes for Beginners! (with homework)"></iframe></section>]]></description><pubDate>Fri, 05 Sep 2025 16:56:39 +0530</pubDate></item><item><link>https://shiftmag.dev/saying-no-is-not-a-free-action-in-the-world-of-software-engineering-5339/</link><title>The hidden costs of saying “no” in software engineering (shiftmag.dev)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n8gpkk/the_hidden_costs_of_saying_no_in_software/</guid><comments>https://www.reddit.com/r/programming/comments/1n8gpkk/the_hidden_costs_of_saying_no_in_software/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 8 min | <a href='https://www.reddit.com/r/programming/comments/1n8gpkk/the_hidden_costs_of_saying_no_in_software/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><p>At ShiftMag we recently explored an angle of software engineering that doesn’t get much attention: the cost of saying “no”.</p><p>We often hear that being able to refuse is a vital soft skill – but refusing also carries a psychological and professional price. Declining can create stress, trigger anxiety, and even feel like a career risk, especially in environments where overcommitment is the norm. </p><p>Meanwhile, saying “yes” is usually rewarded in the short term, even if it leads to burnout later.This raises some questions for us as a profession:</p><p>How do you personally navigate the emotional toll of refusing requests at work?Have you seen “just say no” advice backfire in your teams?</p><p>What practices have you found effective for making refusal safer and healthier in professional environments?</p><p>We’d love to hear how others in the community experience and handle this dynamic.</p></div><!-- SC_ON --></section><section class='separator separator-after-selftext'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><div><p>'Who could refuse that?' Turns out, almost no one - especially when faced with puppy eyes, heartfelt asks, or a desperate Pikachu. Refusing is hard, and it costs more than we admit. </p></div><div><figure><img width="1200" height="630" src="https://shiftmag.dev/wp-content/uploads/2025/06/saying-no.png?x73249" alt srcset="https://shiftmag.dev/wp-content/uploads/2025/06/saying-no.png 1200w, https://shiftmag.dev/wp-content/uploads/2025/06/saying-no-300x158.png 300w, https://shiftmag.dev/wp-content/uploads/2025/06/saying-no-1024x538.png 1024w, https://shiftmag.dev/wp-content/uploads/2025/06/saying-no-768x403.png 768w"></figure><p>We all agree: <strong>saying <em>no</em> is important</strong> &ndash; it can be liberating, support work-life balance, and is a crucial life skill.</p><p>What&rsquo;s discussed far less is the cost of refusing, especially the <strong>psychological cost</strong>. That&rsquo;s what I&rsquo;d like to explore: the emotional toll of refusing &ndash; on ourselves and on those we ask for something, even when we reassure them, &ldquo;It&rsquo;s totally fine if you can&rsquo;t.&rdquo;</p><h2>It&rsquo;s hard to refuse &ndash; and all too easy to agree</h2><p>Overall, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2443710/">saying <em>no</em> often carries negative connotations</a>, which is why we tend to avoid it. We dislike being in situations where <strong>our words or actions might be perceived as negative</strong>. It becomes even more difficult to decline in person &ndash; especially when we know the person well or feel emotionally connected to them or the topic.</p><blockquote><p>People are generally more dismissive online or in anonymous settings, where <strong>the perceived consequences are minimal</strong>. It&rsquo;s much easier to ignore or mock a request to &ldquo;like&rdquo; a post on social media than to say <em>no</em> to your mum when she asks for help picking apples.</p></blockquote><p>In a professional setting, declining becomes even more complicated.</p><p>We&rsquo;ve created a work culture where <strong>declining requests too often can feel like a career risk</strong>, especially for <a href="https://shiftmag.dev/the-journey-of-a-lone-female-software-developer-2876/">women</a> and members of <a href="https://www.harpersbazaar.com/culture/features/a36687625/naomi-osaka-and-the-cost-of-saying-no/">minority groups</a>. Declining isn&rsquo;t only disappointing for the person who asked; it might also mean missing out on a promotion or an exciting opportunity. <a href="https://en.wikipedia.org/wiki/Carp">Holy carp</a>!</p><p>Conversely, <strong>accepting is effortless</strong>. </p><p>It feels nice and positive. You&rsquo;re pleasing the other person, maybe even securing a future reward for yourself. What could be better? Since <a href="https://en.wikipedia.org/wiki/Hyperbolic_discounting">humans are wired to chase immediate rewards</a> and often <a href="http://spia.uga.edu/faculty_pages/tyler.scott/teaching/PADP6950_Spring2017/Readings/Odonoghue.Rabin.2000.pdf">overlook future pain</a>, we tend to say <em>yes</em> just to see that happy twinkle in someone&rsquo;s eye &ndash; consequences be damned!</p><p>If you Google <a href="https://www.google.com/search?q=how+to+say+no">&ldquo;how to say no&rdquo;</a>, you&rsquo;ll get a lot of results, mostly focused on the actual skill of rejecting something. If you Google <a href="https://www.google.com/search?q=how+to+say+yes">&ldquo;how to say yes&rdquo;</a>, you mostly get results about how to say words and phrases in different languages. <strong>Declining is a tricky soft skill</strong>; accepting is often just about language.</p><h2><span>Turning something down is&hellip; stressful.</span></h2><p>So, where are we with <em>no</em>?</p><ul> <li>We&rsquo;re not that great at saying it.</li> <li>It&rsquo;s not a pleasant thing to do.</li> <li>It can have negative consequences.</li> </ul><p>As a result,<strong> it&rsquo;s often stressful to refuse a request</strong>. </p><p>We tend to worry about it before, during, and after the fact. This stress can be even worse if we&rsquo;re already dealing with things like <strong>burnout, impostor syndrome, or anxiety</strong>. Saying <em>no</em> in those situations can feel like adding fuel to the fire. If I already don&rsquo;t believe I&rsquo;m doing a stellar job, turning something down might only reinforce the fear that others see me as a failure.</p><blockquote><p>Our tendency toward <a href="https://en.wikipedia.org/wiki/Herd_mentality">herd mentality</a> doesn&rsquo;t help either. When most of the team says <em>yes</em> and we&rsquo;re the only ones who want to say <em>no</em>, <strong>we often end up going along with the group</strong>, even if we feel conflicted inside.</p></blockquote><p>Many of us have experienced this in sprint planning and sprint reviews &ndash; the team takes on more work than necessary during planning to avoid refusing requests, and then feels deflated and disappointed when they can&rsquo;t deliver everything by the end. Over time, this can <strong>hurt team morale and spirit</strong>, lower motivation, and even create a toxic dynamic between teams and their stakeholders.</p><p>All of this leads to a simple point: <strong>refusing comes with its own burden</strong>. Telling someone to &ldquo;just say <em>no</em>&rdquo; can be disingenuous &ndash; placing the emotional and social cost of rejection on them, while pretending it&rsquo;s easy.</p><h2><span>Expecting a simple refusal hurts the ones who care most</span></h2><p>The people who are most invested in a project, those who care deeply about the quality of their work and their team&rsquo;s delivery, often your &ldquo;best performers&rdquo;, are <strong>usually the ones who find it hardest to say <em>no</em></strong>. As a result, they often take the initiative to pick up tasks that others might reject.</p><p>If you keep asking, they may continue to agree, depending on their situation, until they eventually hit a wall and burn out.</p><h2><span>Be kind. Don&rsquo;t act like <em>no</em> is just a simple word</span></h2><p>We should be<strong> mindful of our colleagues&rsquo; workloads</strong> and, whenever possible, avoid asking them for additional tasks if we know they might already have a full plate. </p><blockquote><p>It&rsquo;s important to recognize that they may feel unable or reluctant to refuse, even when they want to. And even when they do refuse, it can still come at a cost to their emotional well-being or personal life.</p></blockquote><p>We should also recognize that <strong>refusal comes in many forms</strong>. It can mean:</p><ul> <li>Literally saying <em>no</em>.</li> <li>Taking only 5 tasks out of 10 that were offered.</li> <li>Choosing not to volunteer when most others do.</li> <li>Not attending a meeting or participating in a Slack discussion.</li> </ul><p>All of the above can be difficult to do and <strong>may lead to negative consequences down the road</strong>, for both the individual and the team.</p><h2><span>What&rsquo;s the solution?</span></h2> <ul> <li><strong>Talk openly with your colleagues.</strong> Be aware of the challenges they face and the workloads they carry. Don&rsquo;t expect them to simply reject additional work &ndash; understand their situation through honest conversations.</li> <li><strong>Keep expectations realistic.</strong> Avoid presenting people or teams with overwhelming wish lists they can&rsquo;t reasonably deliver. Don&rsquo;t assume others will just say <em>no</em> to unreasonable demands.</li> <li><strong>Diversify your requests for help.</strong> Instead of always turning to the same people who tend to say <em>yes</em>, reach out to others and distribute the load more evenly.</li> <li><strong>Avoid herd mentality pressure.</strong> Give individuals space and time to make decisions independently, and encourage sharing outcomes in a safe environment. This is why practices like writing retrospective points individually or revealing estimations simultaneously in planning poker are important.</li> <li><strong>Lead by example.</strong> Show that saying <em>no</em> when it&rsquo;s appropriate is acceptable. Recognize that you might also struggle with this and discuss it openly with your team.</li> <li><strong>Establish fair systems and processes.</strong> Ensure workloads are distributed transparently and fairly, rather than relying on informal methods that often favor those who find it easier to say <em>no</em> &ndash; which can unfairly burden those who care most about the project&rsquo;s success.</li> <li><strong>Don&rsquo;t reward or idolize overwork.</strong> Encourage a culture that values balance and sustainable effort over relentless hustle.</li> </ul> </div></section>]]></description><pubDate>Thu, 04 Sep 2025 23:05:17 +0530</pubDate></item><item><link>https://open.substack.com/pub/softwarearthopod/p/vibe-coding-our-way-to-disaster?r=ww6gs&amp;&amp;&amp;showWelcomeOnShare=true</link><title>Are We Vibecoding Our Way to Disaster? (open.substack.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n8fqry/are_we_vibecoding_our_way_to_disaster/</guid><comments>https://www.reddit.com/r/programming/comments/1n8fqry/are_we_vibecoding_our_way_to_disaster/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 18 min | <a href='https://www.reddit.com/r/programming/comments/1n8fqry/are_we_vibecoding_our_way_to_disaster/'>Post permalink</a></p></section><section class='preview-image'><img src='https://substackcdn.com/image/fetch/$s_!Dwjn!,w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4defe298-7b3d-4fc0-8624-ff6bc2348103_2688x1792.png' /></section><section class='parsed-content'><div><article><div><p><span>In 2010 and 2011, </span><a href="https://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a><span>, the creator of Clojure, gave two talks that shaped how many developers think about software design. His talks have only become more relevant since then, as we are now being inundated with AI-written code.</span></p><p><a href="https://www.youtube.com/watch?v=SxdOUGdseq4">Simple Made Easy</a><span> distinguishes between simplicity (things that aren't intertwined with other things) and ease (things that are familiar or quick to use). The distinction matters because we often choose easy solutions that create complex, tangled systems.</span></p><p><a href="https://www.youtube.com/watch?v=f84n5oFoZBc">Hammock-Driven Development</a><span> advocates deep, unhurried thinking about problems before writing code. Hickey argues that most critical bugs actually result from misunderstanding the problem rather than implementation errors.</span></p><p>As I've worked with coding agents over the past year, I keep returning to these principles. They provide a framework for understanding why some AI-assisted development results in high-quality software, while others create a complex mess. The key insight: AI tools amplify whatever approach you bring to them. If you rush to code without understanding the problem, AI helps you build the wrong solution. If you think deeply first, AI becomes a powerful tool for implementing well-considered solutions.</p><p>Hickey makes a distinction between simple and easy that at first sounds pedantic. Simple meaning: a single braid, one responsibility, or one concept that doesn't touch anything else. Easy, meaning the thing you reach for automatically. The familiar choice. The solution you can implement without a design doc. The easy approach seduces you because it asks nothing of you in return for using it. The definition of simple really has no overlap with easy, but it is a common idea that simple things are easy, which is not always the case.</p><p>This distinction becomes clearer today when using AI coding agents. The easy approach is to open a chat and start vibe coding your app, iterating through conversation after conversation. It feels natural and productive. The AI responds quickly, code appears, and you can see immediate progress.</p><p>But this easy path comes at the cost of a special kind of complexity: context complexity. As conversations grow longer, the AI's context window fills with corrections, clarifications, searches, tool invocations, and evolving requirements. You are stacking complexity without realizing it. Earlier thoughtful design decisions get buried under the frustration of revisions. The AI starts making connections between these unrelated parts of the conversation, and your focused task dissolves into partial solutions and conflicting approaches, each one 'fixing' the problems created by the last.</p><p>Vibe coding is explicitly choosing ease over simplicity, just as Hickey warned. The comfortable, conversational interface of AI assistants makes it tempting to skip the hard work of clearly defining what we're building. We let the software evolve organically, which feels productive but inevitably creates exactly what Hickey calls "complected" (unnecessarily intertwined) systems. Our context complexity becomes code complexity, and every clarification and correction in the chat history gets woven into the implementation.</p><p>'Hammock-Driven Development' presents an idea that has influenced the way I work, even before working with AI tools. Rich Hickey argues that the most critical software bugs arise from misunderstanding the problem itself, not from implementation errors.</p><p>He demonstrates how our best solutions emerge from harnessing our brain's natural creative process. The analytical mind specializes in gathering information and critiquing ideas, but it gets trapped in familiar patterns of problems it has previously solved. The background mind synthesizes and connects ideas in new ways, but only when we give it space to work. You can't force it to work.</p><p>Hickey's approach maps directly onto the four stages of creative thought, a framework from Graham Wallas's work in the 1920s:</p><ol><li><p><strong>Preparation</strong><span>: Loading up your analytical mind with information. In software, this means understanding the problem domain, exploring existing solutions, and identifying constraints. Hickey emphasizes that we often rush this stage, but it's the foundation for everything else. You need to gather the raw material before your brain can do anything useful with it.</span></p></li><li><p><strong>Incubation</strong><span>: Stepping away from the keyboard. Your background mind processes the information you've gathered, making connections your conscious mind wouldn't make. This is why solutions often come during walks, showers, or lying in a hammock. The key is to actually step away after thorough preparation. (This can also show up as having nightmares about JavaScript)</span></p></li><li><p><strong>Illumination</strong><span>: The eureka moments when connections suddenly become clear. These insights feel like they come from nowhere, but they're actually the result of your background mind's processing during incubation. Hickey notes these moments often reveal simpler solutions than what your analytical mind was initially pursuing.</span></p></li><li><p><strong>Verification</strong><span>: Testing whether the insight actually works. This brings the analytical mind back into play, but now it's working with a fundamentally different approach born from synthesis rather than incremental analysis. Not every insight survives verification, but the ones that do often solve the real problem.</span></p></li></ol><p><span>This focus on disciplined thinking led me to a revelation about AI tools. As I've worked with coding agents over the last few months, I noticed that the most successful agent runs were not from writing the best prompts, but from applying Hickey's preparation phase upfront. This realization led me to develop what I at the time called</span><a href="https://x.com/nayshins/status/1925710279217754123">The Context Compression Funnel</a><span> - later coined by others as </span><a href="https://www.youtube.com/watch?v=8kMaTybvDUw">Context Engineering</a><span> (a much more marketable term, let's be honest). Context engineering is the discipline of designing what an AI sees before it responds - not just the prompt, but all the supporting information, tools, and structure needed to get reliable results.</span></p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!Zov0!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5a4d3fb9-67eb-46dc-a2e9-26cb54884cba_589x652.png"></a></figure></div><p>The core insight is that we should treat AI agents not as conversational partners but as powerful tools whose context must be carefully managed. Just as Hickey advocates for choosing simple constructs over complex ones, we need to opt for simple interaction patterns that provide context upfront over the ease of conversational threads.</p><p>So how do we apply Hickey's principles to AI development? I've found success with three distinct phases that force us to think before we code. This approach directly applies Hickey's principles to prevent the complexity that naturally emerges from unstructured AI interactions.</p><p>The first phase treats the AI as a research assistant focused solely on understanding the problem space. Given a high-level goal, the AI explores the codebase to identify all relevant components. The output is a research document that maps the terrain we'll be working in.</p><p>This phase embodies Hickey's emphasis on thoroughly understanding the problem before attempting solutions. The AI can quickly traverse large codebases, identifying dependencies and relationships that provide crucial context. For instance, discovering that what seemed like a simple UI change actually touches three different API endpoints and a shared state manager. But the key to thinking deeply is that we stop here and review this research before proceeding.</p><p>The human review at this checkpoint represents the highest-leverage intervention in the entire process. By validating the AI's understanding of the problem space early on, we prevent cascading errors that would be far more costly to fix later. This is our "waking mind" actively framing the problem correctly.</p><p>With the validated research in hand, the second phase asks the AI to create a detailed implementation plan. This plan should be so explicit that any developer could follow it - specifying which files to modify, what functions to create, and how components will interact.</p><p>This phase directly implements the principle of separating concerns. By distinguishing the "what" (the plan) from the "how" (the implementation), we create a simple, reviewable specification. The plan itself becomes a design artifact that embodies our thinking about the solution.</p><p>The human review step is the opportunity for you to do a design review. We're not looking at code yet; we're just evaluating the approach. Does this plan maintain proper separation of concerns? Are we tangling together things that should remain separate? This is where we apply what Hickey calls our "entanglement radar" - spotting when things are getting unnecessarily intertwined.</p><p>Only after validating both our understanding and our plan do we move to implementation. This is where all of the upfront work pays off: the AI now has a clear specification to follow, dramatically reducing the chance of drift or confusion.</p><p>This final phase becomes pleasingly straightforward. Because we've already done the hard work of thinking and planning ahead of time, the AI can focus on translating the plan into code. The context remains clean and focused, preventing the accumulation of complexity that inevitably strangles long conversational sessions.</p><div><figure><a href="https://substackcdn.com/image/fetch/$s_!UC4a!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc7aa3030-eec5-4b65-830f-c3f128ac5a2c_704x658.png"></a></figure></div><p>Hickey's emphasis on simplicity becomes even more valuable when working with AI agents. Their power and ease of use make it easy to create new applications faster than ever, but these vibe-coded applications are a mess of complexity (and hilarious security issues). By structuring our interactions to maintain simplicity, we harness AI's capabilities while avoiding its pitfalls.</p><p>The discipline of "hammock time" thinking is translated into our phased approach. We're building in moments of reflection and review, ensuring that human judgment guides the process. The AI amplifies our capabilities, but the crucial thinking work remains fundamentally human.</p><p>More importantly, we're maintaining focus on solving problems rather than just producing code. Hickey argued that we should think more about the problem space than the solution space. Our methodology ensures that two-thirds of the process (research and planning) is dedicated to understanding and designing before any implementation begins.</p><p>As AI coding assistants become more powerful and prevalent, the temptation to use them in "easy" ways will only grow stronger. We'll see tools that promise even more magical transformations from description to implementation. But Hickey's warnings about choosing ease over simplicity will remain relevant.</p><p>The methodology I've outlined goes beyond productivity with AI tools. At its core, it maintains the discipline and thoughtfulness that creates maintainable, understandable systems. It recognizes that the hard work of thinking can't be outsourced to AI, only amplified by it.</p><p>I encourage you to experiment with this approach in your own AI-assisted development. Start by being deliberate about the phases of Research, Planning, and Implementation. Resist the temptation to jump straight into code generation. Permit yourself to spend time thinking. You might find, as I have, that slowing down at key moments actually speeds up the overall process while producing dramatically simpler results.</p><p>AI assistants are here to stay in software development. We must choose to do the work to build elegantly simple systems rather than succumb to the ease of vibe-coded complexity. Hickey gave us the principles. Now we need the discipline to apply them before we are buried in slop.</p></div></article></div><div><h4>Discussion about this post</h4></div><div class="gallery"><p><img src="https://substackcdn.com/image/fetch/$s_!t5z0!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5da078b8-d849-44ca-9330-17ea619df199_667x406.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!Zov0!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5a4d3fb9-67eb-46dc-a2e9-26cb54884cba_589x652.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!UC4a!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc7aa3030-eec5-4b65-830f-c3f128ac5a2c_704x658.png"></p></div></section>]]></description><pubDate>Thu, 04 Sep 2025 22:28:58 +0530</pubDate></item><item><link>https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding</link><title>Where's the Shovelware? Why AI Coding Claims Don't Add Up (mikelovesrobots.substack.com)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n7vpvi/wheres_the_shovelware_why_ai_coding_claims_dont/</guid><comments>https://www.reddit.com/r/programming/comments/1n7vpvi/wheres_the_shovelware_why_ai_coding_claims_dont/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 16 min | <a href='https://www.reddit.com/r/programming/comments/1n7vpvi/wheres_the_shovelware_why_ai_coding_claims_dont/'>Post permalink</a></p></section><section class='preview-image'><img src='https://substackcdn.com/image/fetch/$s_!wZwr!,w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc4476935-b0de-4a02-91a8-8d0cd92f4b54_664x415.png' /></section><section class='parsed-content'><div><article><div><p>I&rsquo;m furious. I&rsquo;m really angry. I&rsquo;m angry in a knocking down sandcastles and punching Daniel LaRusso in the face and talking smack about him to his girl kind of way.</p><p>I&rsquo;m not an angry person generally, but I can&rsquo;t stand what&rsquo;s happening to my industry. </p><p><span>I know software development. I&rsquo;ve been doing it for 25 years, maybe even 28 years</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-1-172538377">1</a></span><span> if you count market research tabulation on amber monochrome screens. Yes, I&rsquo;m old. I&rsquo;m a middle-aged programming nerd. My entire life and personal identity are wrapped up in this programming thing for better or worse. I thrive off the dopamine hits from shipping cool things.</span></p><p><span>I was an early adopter of AI coding and a fan until maybe two months ago, when I read the </span><a href="https://metr.org/blog/2025-07-10-early-2025-ai-experienced-os-dev-study/">METR study</a><span> and suddenly got serious doubts. In that study, the authors discovered that developers were unreliable narrators of their own productivity. They thought AI was making them 20% faster, but it was actually making them 19% slower. This shocked me because I had just told someone the week before that I thought AI was only making me about 25% faster, and I was bummed it wasn&rsquo;t a higher number. I was only off by 5% from the developer&rsquo;s own incorrect estimates.</span></p><p>This was unsettling. It was impossible not to question if I too were an unreliable narrator of my own experience. Was I hoodwinked by the screens of code flying by and had no way of quantifying whether all that reading and reviewing of code actually took more time in the first place than just doing the thing myself?</p><p>So, I started testing my own productivity using a modified methodology from that study. I&rsquo;d take a task and I&rsquo;d estimate how long it would take to code if I were doing it by hand, and then I&rsquo;d flip a coin, heads I&rsquo;d use AI, and tails I&rsquo;d just do it myself. Then I&rsquo;d record when I started and when I ended. That would give me the delta, and I could use the delta to build AI vs no AI charts, and I&rsquo;d see some trends. I ran that for six weeks, recording all that data, and do you know what I discovered?</p><p>I discovered that the data isn&rsquo;t statistically significant at any meaningful level. That I would need to record new datapoints for another four months just to prove if AI was speeding me up or slowing me down at all. It&rsquo;s too neck-in-neck.</p><p>That lack of differentiation between the groups is really interesting though. Yes, it&rsquo;s a limited sample and could be chance, but also so far AI appears to slow me down by a median of 21%, exactly in line with the METR study. I can say definitively that I&rsquo;m not seeing any massive increase in speed (i.e., 2x) using AI coding tools. If I were, the results would be statistically significant and the study would be over.</p><p>That&rsquo;s really disappointing.</p><p>I wish the AI coding dream were true. I wish I could make every dumb coding idea I ever had a reality. I wish I could make a fretboard learning app on Monday, a Korean trainer on Wednesday, and a video game on Saturday. I&rsquo;d release them all. I&rsquo;d drown the world in a flood of shovelware like the world had never seen. Well, I would &mdash; if it worked.</p><p><span>It turns out, though, and I&rsquo;ve collected a lot of data on this, it doesn&rsquo;t just not work for me, </span><strong>it doesn&rsquo;t work for anyone</strong><span>, and I&rsquo;m going to prove that.</span></p><p><span>But first, let&rsquo;s examine how extreme and widespread these productivity claims are. Cursor&rsquo;s tagline is &ldquo;Built to make you extraordinarily productive.&rdquo; Claude Code&rsquo;s is &ldquo;Build Better Software Faster.&rdquo; GitHub Copilot&rsquo;s is &ldquo;Delegate like a boss.&rdquo; Google says their LLMs make their developers 25% faster. OpenAI makes their own bombastic claims about their coding efficiencies and studies</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-2-172538377">2</a></span><span>. And my fellow developers themselves are no better, with 14% claiming they&rsquo;re seeing a 10x increase in output due to AI.</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-3-172538377">3</a></span></p><p><em>&ldquo;Delegate like a boss&rdquo; &ndash; Github Copilot</em></p><div><p><span>These claims wouldn't matter if the topic weren't so deadly serious. Tech leaders everywhere are buying into the FOMO, convinced their competitors are getting massive gains they're missing out on. This drives them to rebrand as AI-First companies</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-4-172538377">4</a></span><span>, justify layoffs with newfound productivity narratives, and lowball developer salaries under the assumption that AI has fundamentally changed the value equation.</span></p><p><span>And yet, despite the most widespread adoption one could imagine</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-5-172538377">5</a></span><span>, </span><strong>these tools don&rsquo;t work</strong><span>.</span></p></div><p><strong>My argument: If so many developers are so extraordinarily productive using these tools, where is the flood of shovelware?</strong><span> We should be seeing apps of all shapes and sizes, video games, new websites, mobile apps, software-as-a-service apps &mdash; we should be drowning in choice. We should be in the middle of an indie software revolution. We should be seeing 10,000 Tetris clones on Steam.</span></p><div><p><strong>Consider this: </strong><span>with all you know about AI-assisted coding and its wide adoption, if I showed you charts and graphs of new software releases across the world, what shape of that graph would you expect? Surely you&rsquo;d be seeing an exponential growth up-and-to-the-right as adoption took hold and people started producing more?</span></p><p><span>Now, I&rsquo;ve spent a lot of money and weeks putting the data for this article together, processing tens of terabytes of data in some cases. So I hope you appreciate how utterly uninspiring and flat these charts are across every major sector of software development. </span></p></div><div><figure><a href="https://substackcdn.com/image/fetch/$s_!eBmO!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4e23e3e0-d046-4b58-ab6d-bb8e78d38493_664x415.png"></a><figcaption><span>I spent $70 on BigQuery processing to make this chart. Via </span><a href="https://www.gharchive.org/">GH Archive</a></figcaption></figure></div><p>The most interesting thing about these charts is what they&rsquo;re not showing. They&rsquo;re not showing a sudden spike or hockey-stick line of growth. They&rsquo;re flat at best. There&rsquo;s no shovelware surge. There&rsquo;s no sudden indie boom occurring post-2022/2023. You could not tell looking at these charts when AI-assisted coding became widely adopted. The core premise is flawed. Nobody is shipping more than before.</p><p><span>The impact on human lives is incredible. People are being fired because they&rsquo;re not adopting these tools fast enough</span><span><a href="https://mikelovesrobots.substack.com/p/wheres-the-shovelware-why-ai-coding#footnote-6-172538377">6</a></span><span>. People are sitting in jobs they don&rsquo;t like because they&rsquo;re afraid if they go somewhere else it&rsquo;ll be worse. People are spending all this time trying to get good at prompting and feeling bad because they&rsquo;re failing.</span></p><p>This whole thing is bullshit.</p><p>So if you're a developer feeling pressured to adopt these tools &mdash; by your manager, your peers, or the general industry hysteria &mdash; trust your gut. If these tools feel clunky, if they're slowing you down, if you're confused how other people can be so productive, you're not broken. The data backs up what you're experiencing. You're not falling behind by sticking with what you know works. If you&rsquo;re feeling brave, show your manager these charts and ask them what they think about it.</p><p>If you take away anything from this it should be that (A) developers aren't shipping anything more than they were before (that&rsquo;s the only metric that matters), and (B) if someone &mdash; whether it's your CEO, your tech lead, or some Reddit dork &mdash; claims they're now a 10xer because of AI, that&rsquo;s almost assuredly untrue, demand they show receipts or shut the fuck up.</p><p>Now, I know the internet. I know what many of you chumps are going to say before you even say it, so let&rsquo;s just get into it:</p><ol><li><p><em>&ldquo;Well, if you just learned how to prompt properly, then you would be a 10x engineer like me.&rdquo;</em><br><span>Look at the data. There are no new 10xers. If there were &mdash; if the 14% of self-proclaimed AI 10xers were actually 10xers &mdash; that would more than double the worldwide output of new software. That didn&rsquo;t happen. And as for you, personally, show me the 30 apps you created this year. I&rsquo;m not entertaining this without receipts.</span></p></li><li><p><em><span>&ldquo;Well, it&rsquo;s a new technology and so much is invested, and it takes time&hellip;&rdquo;</span><br></em><span>Yes, billions of dollars have been invested in these tools. Billions of dollars will continue to be invested in these tools. The problem is that they&rsquo;re being sold and decisions are being made about them &mdash; which affect real people&rsquo;s lives &mdash; as if they work today. Don&rsquo;t parrot that nonsense to me that it&rsquo;s a work in progress. It&rsquo;s September 2025, and we&rsquo;ve had these tools for years now, and they still suck. Someday, maybe they won&rsquo;t suck, but we'd better see objective proof of them having an impact on actually shipping things on the large.</span></p></li><li><p><em><span>&ldquo;Well, maybe it kind of sucks now, but if you don&rsquo;t adopt it early, you&rsquo;ll be left behind.&rdquo;</span><br></em><span>There are no indicators that prompting is hard to learn. Github Copilot themselves say that </span><a href="https://github.blog/news-insights/research/the-economic-impact-of-the-ai-powered-developer-lifecycle-and-lessons-from-github-copilot/">initially, users only accept 29% of prompted coding suggestions</a><span> (which itself is a wild claim to inefficiency, why would you publicize that?), but with six months of experience, users naturally get better at prompting and that grows to a whopping 34% acceptance rate. Apparently, 6 months of experience only makes you 5% better at prompting.</span></p></li><li><p><em>&ldquo;Well, maybe quality is going up and things aren&rsquo;t necessarily shipping faster&hellip;&rdquo;</em><br><span>That doesn&rsquo;t make any sense. We all know that the industry has taken a step back in terms of code quality by at least a decade. Hardly anyone tests anymore. The last time I heard the phrase &ldquo;continuous improvement&rdquo; or &ldquo;test-driven development&rdquo; was before COVID. You know as well as I do that if there&rsquo;s a tool that can make people 10x coders, we&rsquo;d be drowning in shovelware.</span></p></li><li><p><em>&ldquo;Well, it&rsquo;s all website-driven, and people don&rsquo;t really care about domain names these days; it&rsquo;s all subdomains on sites like Vercel.&rdquo;</em><br><span>Shut up. People love their ego domains.</span></p></li><li><p><em>&ldquo;Well, .ai domain names are up 47% this year&hellip;&rdquo;</em><br><span>Yeah, that&rsquo;s cause all the startups pivoted to AI. It&rsquo;s the only way to get money out of investor FOMO. Has the overall amount of domain names gone up at an unprecedented rate, though? No, it hasn&rsquo;t. Look at the new domains chart.</span></p></li><li><p><em>&ldquo;Well, if you were a real engineer, you&rsquo;d know that most of software development is not writing code.&rdquo;</em><br><span>That&rsquo;s only true when you&rsquo;re in a large corporation. When you&rsquo;re by yourself, when you&rsquo;re the stakeholder as well as the developer, you&rsquo;re not in meetings. You're telling me that people aren&rsquo;t shipping anything solo anymore? That people aren&rsquo;t shipping new GitHub projects that scratch a personal itch? How does software creation not involve code?</span></p></li></ol></div></article></div><div><h4>Discussion about this post</h4></div><div class="gallery"><p><img src="https://substackcdn.com/image/fetch/$s_!DPg1!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F53c83842-05e1-4ca1-9021-c292e8f3a502_600x371.png"></p><p><img src="https://substackcdn.com/image/fetch/$s_!eBmO!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4e23e3e0-d046-4b58-ab6d-bb8e78d38493_664x415.png"></p></div></section>]]></description><pubDate>Thu, 04 Sep 2025 05:55:29 +0530</pubDate></item><item><link>https://kyo.iroiro.party/en/posts/why-rewriting-emacs-is-hard/</link><title>Why Rewriting Emacs Is Hard (kyo.iroiro.party)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n7j5wr/why_rewriting_emacs_is_hard/</guid><comments>https://www.reddit.com/r/programming/comments/1n7j5wr/why_rewriting_emacs_is_hard/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 25 min | <a href='https://www.reddit.com/r/programming/comments/1n7j5wr/why_rewriting_emacs_is_hard/'>Post permalink</a></p></section><section class='separator separator-before-parsed-content'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><div><nav><h2>Table of Contents<a href="https://kyo.iroiro.party#table-of-contents" title="Permalink to this heading">&para;</a></h2><div><ul> <li> <a href="https://kyo.iroiro.party#rolling-your-own-string-types">1. Rolling your own string types</a> <ul> <li><a href="https://kyo.iroiro.party#lossless-file-editing">1.1. Lossless file editing</a></li> <li><a href="https://kyo.iroiro.party#more-universal-than-unicode">1.2. More universal than Unicode</a></li> </ul> </li> <li> <a href="https://kyo.iroiro.party#bringing-your-own-string-libraries">2. Bringing your own string libraries</a> <ul> <li><a href="https://kyo.iroiro.party#case-tables">2.1. Case tables</a></li> <li><a href="https://kyo.iroiro.party#regexp">2.2. Regexp</a></li> <li><a href="https://kyo.iroiro.party#any-encoding-you-want">2.3. Any encoding you want</a></li> </ul> </li> <li> <a href="https://kyo.iroiro.party#buffers-are-more-than-buffers">3. Buffers are more than buffers</a> <ul> <li><a href="https://kyo.iroiro.party#trees-are-everywhere">3.1. Trees are everywhere</a></li> <li><a href="https://kyo.iroiro.party#strings-into-buffers-into-strings">3.2. Strings into buffers into strings</a></li> <li><a href="https://kyo.iroiro.party#more-on-gap-buffers">3.3. More on gap buffers</a></li> </ul> </li> <li><a href="https://kyo.iroiro.party#summarizing">4. Summarizing</a></li> </ul> </div></nav><p>There have been quite a few attempts to re-implement (part of) Emacs&rsquo; functionalities in languages other than C, like <a href="https://jemacs.sourceforge.net/">JEmacs</a>, <a href="https://github.com/remacs/remacs">remacs</a>, and <a href="https://github.com/lem-project/lem/">lem</a>. And we are seeing new efforts in EmacsConf 2024: <a href="https://github.com/CeleritasCelery/rune">rune</a> <sup><a href="https://kyo.iroiro.party#fn.rune">1</a></sup>, <a href="https://codeberg.org/ramin_hal9001/schemacs">schemacs</a> <sup><a href="https://kyo.iroiro.party#fn.gypsum">2</a></sup>, and the revived <a href="https://codeberg.org/lyrra/guilemacs">Guilemacs</a> <sup><a href="https://kyo.iroiro.party#fn.guilemacs">3</a></sup>. (Strictly speaking, Guilemacs is more a fork than a total rewrite, but anyway.) </p><p>However, a complete rewrite of (<span>GNU</span>) Emacs <sup><a href="https://kyo.iroiro.party#fn.gnu-emacs">4</a></sup>has always seemed like an insurmountable task, not just because writing editors <i>is</i> hard. This article aims to look into some of these difficulties and the Emacs designs (that of course have been exposed in some Emacs Lisp <span>API</span>) that lead to them. </p><blockquote><p>The rationale for this piece is that I too have been pipe-dreaming about yet another rewrite. :-/ </p></blockquote><div><h2> <span>1.</span> Rolling your own string types<a href="https://kyo.iroiro.party#rolling-your-own-string-types" title="Permalink to this heading">&para;</a></h2><div><p>What is the highest <a href="https://en.wikipedia.org/wiki/Code_point">code point</a> supported in your favorite programming language? If it&rsquo;s <code>#x10FFFF</code>, as per the current Unicode standard, then good luck rolling your own string implementation to stay compatible with Emacs, in that it supports characters up to <code>#x3FFFFF</code>. </p><p>This design decision has <a href="https://lists.gnu.org/archive/html/emacs-devel/2020-12/msg00892.html">a bit of history behind it</a>, which led us to the following two nice features of <span>GNU</span> Emacs. </p></div><div><h3> <span>1.1.</span> Lossless file editing<a href="https://kyo.iroiro.party#lossless-file-editing" title="Permalink to this heading">&para;</a></h3><div><p>In an era dominated by Unicode, it is becoming rarer to have to work with multiple character sets. But if you do (or did) need to deal with some other encodings, you might have the experience of opening a file and the editor getting the encoding wrong. Now, for some editors, if you accidentally save the wrongly-decoded file back, poof, your file is doomed. </p><p>The main reason for such disasters lies in how string types handle invalid byte sequences. For instance, in Java, when decoding bytes into a <code>String</code> with built-in libraries, you can ask the decoder to either: </p><ol> <li>Replace invalid bytes with replacement characters <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)">like <code>#xFFFD</code></a>,</li> <li>Or just throw an error.</li> </ol><p>That is to say, you either give up decoding, or lossily convert them to Unicode. The same applies to most other languages/libraries whose string types are aware of Unicode: the string type has no place for invalid Unicode characters, rightfully so, because it was designed (or re-designed) with only Unicode in mind. </p><p>However, Emacs Lisp, as a language dedicated to a text editor, decides to reserve space for even invalid bytes. Trying to construct a string containing a single <code>#x3FFFFF</code> code point in Emacs, and you will see that it is treated as a single raw byte <code>\377</code> (or <code>#xFF</code>) - the code point range <code>#x3FFF80 - #x3FFFFF</code> is for representing raw bytes: </p><div><pre><code><span>(</span><span>string</span><span>#x3FFF80</span><span>#x3FFFFF</span><span>)</span> </code></pre></div><pre>"\200\377" </pre><p>This is how Emacs ensures lossless file editing. Regardless of the encoding, it transforms invalid bytes into &ldquo;raw bytes&rdquo; that both the ELisp runtime and encoders recognize. When saving, these raw bytes are preserved exactly as they were. </p><blockquote><p>Actually many C-based editors may have similar properties: unedited bytes are preserved as is because a string is just a sequence of bytes. But I am afraid their scripting language, if any, may not be prepared for this. </p></blockquote> </div></div><div><h3> <span>1.2.</span> More universal than Unicode<a href="https://kyo.iroiro.party#more-universal-than-unicode" title="Permalink to this heading">&para;</a></h3><div><p>Another reason for the <code>0 - #x3FFFFF</code> character range is that Emacs was born before Unicode, and, quite luckily, has been one of the few apps that <i>do not</i> just wrongly assume that Unicode has been actually universal. </p><p>Before Unicode, there were a lot of encodings for various languages in various territories. While many of them have now been incorporated into Unicode and can map the code points back and forth, some of them are yet to be fully mapped. An example is the tibetan <span>ISO</span>-2022 encoding, and you may see for yourself at <a href="https://github.com/emacs-mirror/emacs/blob/master/lisp/language/tibetan.el"><code>tibetan.el</code></a> (where Emacs defines its lossless tibetan coding system) for how many of the characters are only representable by replacement characters. <sup><a href="https://kyo.iroiro.party#fn.tibetan">5</a></sup></p><p>The Emacs&rsquo; solution to this is similar to that of invalid bytes: Emacs reserves code point space (<code>#x110000 - #x3FFF7F</code>) for characters that are not yet unified (meaning, not yet mapped to Unicode), and any ELisp programs may simply treat them as normal characters, with all text operations still applicable. </p><blockquote><p>Personally I still wonder how these un-unified characters are to be displayed. On my Emacs setup they are just tofu blocks with hexadecimal codes on top, and I don&rsquo;t have a clue whether there are any fonts for them. It seems the look-up tables in many font formats nowadays also assume Unicode code points (or at least searching in English tells me that). So maybe one will need special font formats/terminals for that? </p></blockquote> </div></div></div><div><h2> <span>2.</span> Bringing your own string libraries<a href="https://kyo.iroiro.party#bringing-your-own-string-libraries" title="Permalink to this heading">&para;</a></h2><p>If you are to roll your own string types, then you definitely will need to re-implement all those string libraries. Even if you decide to ignore all that and just use the language&rsquo;s built-in Unicode strings for everything, you will still need to brace yourself for most of the string primitives. No, you cannot simply wrap around your favorite regexp/string libraries, and here is why. </p><div><h3> <span>2.1.</span> Case tables<a href="https://kyo.iroiro.party#case-tables" title="Permalink to this heading">&para;</a></h3><div><p>Most languages provide ways to convert a string to its uppercase/lowercase, and most of them use look-up tables under the hood because of the vast number of conversions and irregularities of Unicode case conversions. Emacs does this too, except that it fully exposes those look-up tables as mutable to ELisp code (although some of them are only accessible through <code>unicode-property-table-internal</code>). The result of this is that one can use <code>upcase/downcase</code> for arbitrary string transformations, in addition to Unicode case conversions. And of course, some ELisp code has been doing so: </p><div><pre><code><span>(</span><span>defconst</span><span>erc--casemapping-rfc1459-strict</span> <span>(</span><span>let</span><span>((</span><span>tbl</span><span>(</span><span>copy-sequence</span><span>ascii-case-table</span><span>))</span> <span>(</span><span>cup</span><span>(</span><span>copy-sequence</span><span>(</span><span>char-table-extra-slot</span><span>ascii-case-table</span><span>0</span><span>))))</span> <span>(</span><span>set-char-table-extra-slot</span><span>tbl</span><span>0</span><span>cup</span><span>)</span> <span>(</span><span>set-char-table-extra-slot</span><span>tbl</span><span>1</span><span>nil</span><span>)</span> <span>(</span><span>set-char-table-extra-slot</span><span>tbl</span><span>2</span><span>nil</span><span>)</span> <span>(</span><span>pcase-dolist</span><span>(</span><span>`</span><span>(</span><span>,</span><span>uc</span><span>.</span><span>,</span><span>lc</span><span>)</span><span>'</span><span>((</span><span>?\[</span><span>.</span><span>?\{</span><span>)</span><span>(</span><span>?\]</span><span>.</span><span>?\}</span><span>)</span><span>(</span><span>?\\</span><span>.</span><span>?\|</span><span>)))</span> <span>(</span><span>aset</span><span>tbl</span><span>uc</span><span>lc</span><span>)</span> <span>(</span><span>aset</span><span>tbl</span><span>lc</span><span>lc</span><span>)</span> <span>(</span><span>aset</span><span>cup</span><span>uc</span><span>uc</span><span>))</span> <span>tbl</span><span>))</span> </code></pre></div><p>The code snippet is from <a href="https://github.com/emacs-mirror/emacs/blob/master/lisp/erc/erc.el"><code>erc.el</code></a>, one of the built-in <span>IRC</span> clients in Emacs. What it is doing here is creating case tables for <a href="https://en.wikipedia.org/wiki/Scandinavian_languages">scandanavian</a> case conversions between <code>[]\</code> and <code>{}|</code>, as is specified in <span>RFC</span> 1459: </p><blockquote><p>Because of <span>IRC</span>&rsquo;s scandanavian origin, the characters {}| are considered to be the lower case equivalents of the characters []\, respectively. This is a critical issue when determining the equivalence of two nicknames. </p></blockquote><p>Emacs also provides a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Case-Tables.html"><code>with-case-table</code></a> macro for this, mostly used with <code>ascii-case-table</code> to prevent locale-aware case conversions from messing with some <span>ASCII</span> protocols. </p></div></div><div><h3> <span>2.2.</span> Regexp<a href="https://kyo.iroiro.party#regexp" title="Permalink to this heading">&para;</a></h3><div><p>How can an editor do without regular expressions? Unfortunately, the regexp in Emacs is too specialized to be compatible with any other regexp implementations, <a href="https://swtch.com/~rsc/regexp/regexp1.html">backtracking or not</a>. The following is a regexp example I took from <code>cc-fonts.el</code> (font lock support for <span>CC</span> Mode (a mode for C/C++)): </p><div><pre><code><span>"\\(\\=\\|\\(\\=\\|[^\\]\\)[\n\r]\\)"</span><span>; noncontinued-line-end</span> </code></pre></div><p>No, it is not the extraneous backslashes that makes it incompatible. For people that prefer &ldquo;normal&rdquo; regexp syntax, here it is: <code>(\=|(\=|[^\\])[\n\r])</code>, with <code>\=</code> basically meaning &ldquo;where the user cursor is&rdquo;, and the regexp just means &ldquo;let&rsquo;s treat <code><backslash> and then <end_of_line></end_of_line></backslash></code> or <code><user_cursor> and then <end_of_line></end_of_line></user_cursor></code> as a non-continued line end. Simple, right? Only if the common regexp libraries support asserting <code><user_cursor></user_cursor></code>. </p><p>And it&rsquo;s more than that. Of course Emacs regexps will use case tables for <code>[:lower:]</code>, <code>[:upper:]</code> or case-insensitive matching via <code>case-fold-search</code>. And unsurprisingly, the same applies to the word assertion <code>\w</code>, word boundary assertion <code>\b</code> and more, which involve syntax tables and maybe char category tables. All these also make a slowish backtracking regexp engine mandatory (although one may offload simple regexps to a non-backtracking one). </p><blockquote><p>Emacs allows ELisp to attach <code>syntax-table</code> properties to specific texts in buffers or strings, thus overriding &ldquo;what the syntax table says about this particular character&rdquo;. It seems mainly used with subroutines for parsing, like <code>parse-partial-sexp</code>, but thank goodness it does not affect regexp matching. (<a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/lisp/progmodes/js.el#L2194-L2196">It</a> <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/lisp/progmodes/sh-script.el#L935-L937">is</a> <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/lisp/minibuffer.el#L5205-L5211">not</a> <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/lisp/progmodes/ruby-ts-mode.el#L1091-L1124">that</a> <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/lisp/progmodes/typescript-ts-mode.el#L682-L695">uncommon</a> by the way.) </p></blockquote> </div></div><div><h3> <span>2.3.</span> Any encoding you want<a href="https://kyo.iroiro.party#any-encoding-you-want" title="Permalink to this heading">&para;</a></h3><div><p>Did I forget to mention that Emacs employs another language (<span>CCL</span>, the Code Conversion Language) for <a href="https://emacsninja.com/posts/code-conversion-language.html">encoding conversion</a> and you can implement literally any encoding converters from ELisp with <span>CCL</span>? It&rsquo;s not that hard. All you need to do is to include yet another bytecode interpreter in your implementation. </p><blockquote><p>An alternative is to pretend that everything is Unicode. </p></blockquote> </div></div></div><div><h2> <span>3.</span> Buffers are more than buffers<a href="https://kyo.iroiro.party#buffers-are-more-than-buffers" title="Permalink to this heading">&para;</a></h2><div><p>Every editor must have something to represent editable texts, whether it is <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Gap.html#index-buffer-gap">gap buffers</a>, or <a href="https://xi-editor.io/docs/rope_science_00.html">ropes</a>, or <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">piece tables/trees</a> or plain strings. However, Emacs buffers are much more than texts and multiple concepts couple tightly to buffers: </p><ul> <li>Text properties: Attach fonts, colors or any objects to specific texts. One may also use it to highlight texts or hide texts.</li> <li>Overlays: Similar to text properties, but instead of replacing existing properties, it &ldquo;overlays&rdquo; them with newer ones so that one doesn&rsquo;t need to worry about having to restore them later.</li> <li><p>Markers: Want to go back to your previous cursor position? <code>C-u C-SPC</code> will pop and take you to the last marker, which likely <i>marks</i> where you were in the buffer. </p></li> <li><p>Indirect buffers: Indirect buffers share their texts and text properties with base buffers, but not markers, overlays, nor narrowing (i.e., a range specified to make the buffer operate on only a sub-string of its text). </p></li> </ul><p>All of these stay in sync with the text, however or wherever you insert or delete texts. And they need to be considered when you design buffers for your Emacs, especially if you are hoping for concurrent redisplay in the first place. </p><blockquote><p>Also, at least in Emacs, users index strings and buffers mostly by code points. So if you are storing strings as some <span>UTF</span>-8-like bytes, you will need to come up with a way to map between byte offsets and char offsets. Or, if you are using some <a href="https://www.graalvm.org/truffle/javadoc/com/oracle/truffle/api/strings/TruffleString.Encoding.html">auto-compacting <span>UTF</span>-32 encoding</a>, you will need to map char offsets back to byte offsets, as is required by the Emacs <code>position-bytes/string-bytes</code> subroutine. </p></blockquote> </div><div><h3> <span>3.1.</span> Trees are everywhere<a href="https://kyo.iroiro.party#trees-are-everywhere" title="Permalink to this heading">&para;</a></h3><div><p>For an editor, it is critical to offer decent text editing performance. Let&rsquo;s first take a look at the buffer implementations in some editors here: </p><ul> <li><span>GNU</span> Emacs: <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/src/buffer.h#L228-L238">Gap buffers</a>, with <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/src/intervals.h#L29-L66">intervals stored in a tree</a>, with a <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/src/region-cache.c">line-number cache</a>, with markers that are just integer wrappers that need constant adjustment. <ul> <li><span>GNU</span> Emacs uses a list of markers that track both char offsets and byte offsets to convert between the two systems of offsets, which it admits to be <a href="https://github.com/emacs-mirror/emacs/blob/ac52993b996927031a6913927e1028de47be4312/src/marker.c#L142-L160">slow sometimes</a>.</li> <li> <a href="https://github.com/CeleritasCelery/rune">Rune</a> (&ldquo;experimental Emacs core written in Rust&rdquo;): Also gap buffers, except that it stores char offsets in a tree.</li> </ul> </li> <li><span>VS</span> Code: <a href="https://github.com/microsoft/vscode/blob/a2b1f14d1cc3dfcaa35dc1595c927b77d68cdbe3/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts#L269">&ldquo;Piece trees&rdquo;</a>, or, what-actually-look-like-ropes. It seems they are just ropes with the string fragments turned into sub-string references to a huge append-only string buffer.</li> <li><p>Neovim: <a href="https://github.com/neovim/neovim/blob/17b46d01e29443452ae8b607017f8f5c585d3f0a/src/nvim/memline.c#L5-L35">Line-based ropes</a>, with <a href="https://github.com/neovim/neovim/blob/17b46d01e29443452ae8b607017f8f5c585d3f0a/src/nvim/marktree.c#L1-L5">marks stored in a separate tree</a>. </p><blockquote><p><span>&ldquo;</span>Mom, can we get ropes?&rdquo; &ldquo;We have ropes at home.&rdquo; </p></blockquote> </li> <li>IntelliJ: <a href="https://github.com/JetBrains/intellij-community/blob/e16def25ec80aa742470b604827c21bb1f15679c/platform/util/base/src/com/intellij/util/text/ImmutableText.java">Rope-like strings</a>, with <a href="https://github.com/JetBrains/intellij-community/blob/e16def25ec80aa742470b604827c21bb1f15679c/platform/core-impl/src/com/intellij/openapi/editor/impl/RangeMarkerTree.java">range markers stored in <code>RangeMarkerTree</code></a> and <a href="https://github.com/JetBrains/intellij-community/blob/e16def25ec80aa742470b604827c21bb1f15679c/platform/core-impl/src/com/intellij/openapi/editor/impl/LineSet.java">line-number mappings stored in <code>LineSet</code></a>. <ul> <li>Fleet: <a href="https://blog.jetbrains.com/fleet/2022/02/fleet-below-deck-part-ii-breaking-down-the-editor/">Ropes</a>, with &ldquo;updatable interval trees&rdquo; for widgets, highlighting and more. (As it is not (yet) open source, I cannot look into what they mean by &ldquo;updatable interval trees&rdquo;, but it sounds really like Emacs text properties.)</li> </ul> </li> <li>Zed: <a href="https://zed.dev/blog/zed-decoded-rope-sumtree">Ropes, implemented as a <code>SumTree</code></a>.</li> </ul><p>I won&rsquo;t go into what all these implementations are about since there have been quite some articles about them already (e.g., <a href="https://en.wikipedia.org/wiki/Gap_buffer">gap buffers</a>, <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">piece tree</a>, and <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">ropes</a>). Different as they might sound, when you think of ropes as strings with attached statistics, the distinction actually turns vague (under a single-threaded context): </p><table> <colgroup><col> <col> <col> <col> </colgroup><thead><tr> <th>&nbsp;</th> <th>Ropes</th> <th>Gap Buffers + Tree</th> <th>Piece Tree</th> </tr></thead> <tr> <td>Metadata Keeping</td> <td>In-tree</td> <td>In-tree</td> <td>In-tree</td> </tr><tbody> <tr> <td>New Strings</td> <td>Allocated</td> <td>In gaps</td> <td>In string buffer</td> </tr> <tr> <td>String Deletion</td> <td>De-allocation</td> <td>Gap update</td> <td>No-op</td> </tr> </tbody> </table><p>Notice the &ldquo;in-tree metadata keeping&rdquo; part? Buffers are not just the texts: they are texts with all the attached metadata, be it text properties or code point offsets or line numbers. And trees are usually the way to go if you want these to be in sync with the text. (And I really like how <a href="https://zed.dev/blog/zed-decoded-rope-sumtree#everythings-a-sumtree">Zed treats all these as <code>SumTree</code> with Rust&rsquo;s generics and traits</a>.) </p></div></div><div><h3> <span>3.2.</span> Strings into buffers into strings<a href="https://kyo.iroiro.party#strings-into-buffers-into-strings" title="Permalink to this heading">&para;</a></h3><div><p>Text properties are not unique to Emacs buffers, and you probably have guessed it: ELisp strings also carry properties, and it is only natural that one can pass them between strings and buffers: </p><div><pre><code><span>(</span><span>with-temp-buffer</span> <span>;; `insert' also inserts string properties into buffers.</span> <span>(</span><span>insert</span><span>#(</span><span>"hello world"</span><span>0</span><span>11</span><span>(</span><span>str-prop</span><span>1</span><span>)))</span> <span>(</span><span>put-text-property</span><span>(</span><span>point-min</span><span>)</span><span>(</span><span>point</span><span>)</span><span>'buf-prop</span><span>2</span><span>)</span> <span>;; Buffer text properties are extracted into substrings.</span> <span>(</span><span>buffer-substring</span><span>1</span><span>6</span><span>))</span> </code></pre></div><pre>#("hello" 0 5 (buf-prop 2 str-prop 1)) </pre> <blockquote><p>The weird <span><code><span>#(</span><span>"hello world"</span><span>0</span><span>11</span><span>(</span><span>str-prop</span><span>1</span><span>))</span> </code> thing is the read syntax for strings with text properties. </span></p></blockquote><p>Inserting strings into buffers have some corner cases, like conversion between 0/1-base offsets, <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Not-Intervals.html">interval coalescing</a> and <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Sticky-Properties.html">stickiness</a>. But since these cases are quite straightforward, let&rsquo;s look at some more interesting cases: </p><div><pre><code><span>(</span><span>with-temp-buffer</span> <span>(</span><span>insert</span><span>#(</span><span>"&#129303;"</span><span>0</span><span>1</span><span>(</span><span>a</span><span>1</span><span>)))</span> <span>(</span><span>set-buffer-multibyte</span><span>nil</span><span>)</span> <span>(</span><span>buffer-string</span><span>))</span> </code></pre></div><pre>#("\360\237\244\227" 0 4 (a 1)) </pre><p>Basically, a property spanning <code>1 - 2</code> is automatically expanded to <code>1 - 5</code> when converting a multi-byte buffer into a single byte buffer (probably because intervals track byte positions under the hood): </p><div><pre><code>1 2 (chars) |----&gt; Property: (a 1) &lt;----| +------+------+------+------+ | &#129303; (four bytes in UTF-8) | +------+------+------+------+ | (set-buffer-multibyte nil) \|/ +------+------+------+------+ | \360 | \237 | \244 | \227 | +------+------+------+------+ |----&gt; Property: (a 1) &lt;----| 1 2 3 4 5 (chars) </code></pre></div><p>This also makes one wonder: what happens if we convert a multi-byte string info a single-byte string? Well, normally you won&rsquo;t be able to do that while preserving string properties, but we can work around that with <code>clear-string</code> since <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Modifying-Strings.html">Emacs strings are mutable</a>: </p><div><pre><span></span><code><span>(</span><span>let</span><span>((</span><span>s</span><span>#(</span><span>"&#129303;"</span><span>0</span><span>1</span><span>(</span><span>a</span><span>1</span><span>))))</span> <span>(</span><span>clear-string</span><span>s</span><span>)</span> <span>(</span><span>prin1</span><span>s</span><span>))</span> </code></pre></div><pre>Fatal error 11: Segmentation fault Backtrace: emacs(emacs_backtrace+0x51) [0x57ed0155c5d1] emacs(terminate_due_to_signal+0xa1) [0x57ed014408f4] emacs(+0x80260) [0x57ed01441260] emacs(+0x80267) [0x57ed01441267] emacs(+0x19969e) [0x57ed0155a69e] /usr/lib/libc.so.6(+0x3d1d0) [0x755cd06dc1d0] emacs(copy_intervals+0x188) [0x57ed0164fa58] emacs(Fcopy_sequence+0x84) [0x57ed015dafc4] emacs(+0x23a86d) [0x57ed015fb86d] emacs(Fprin1+0x6b) [0x57ed015fcfdb] emacs(eval_sub+0x933) [0x57ed015d2c43] emacs(Flet+0x250) [0x57ed015d6080] emacs(eval_sub+0x7fa) [0x57ed015d2b0a] ... (as of Emacs 30.0.93) </pre><p>That&rsquo;s &hellip; unexpected. Ahem, and the moral is that you definitely need to be careful working with corner cases, especially when Emacs texts (both buffers and strings) are separated into single-byte (raw-byte) variants and multi-byte ones. &#129303; </p><blockquote><p>This has been <a href="https://lists.gnu.org/archive/html/bug-gnu-emacs/2025-01/msg01131.html">fixed</a> by the way: <code>clear-string</code> should now also clear any string properties. </p></blockquote> </div></div><div><h3> <span>3.3.</span> More on gap buffers<a href="https://kyo.iroiro.party#more-on-gap-buffers" title="Permalink to this heading">&para;</a></h3><div><p>I sometimes see an article (by Troy Hinckley, the creator of <a href="https://github.com/CeleritasCelery/rune">Rune</a>) quoted in discussions on gap buffers and ropes: <a href="https://coredumped.dev/2023/08/09/text-showdown-gap-buffers-vs-ropes/">Text showdown: Gap Buffers vs Ropes</a>. But I don&rsquo;t think some of its benchmarks are actually fair: <a href="https://docs.rs/ropey/latest/ropey/">ropey</a> and <a href="https://docs.rs/crop/latest/crop/">crop</a> track line numbers, while the gap buffer implementation does not. (Or maybe I am missing something here: although the post says it has &ldquo;metrics include things like char and line position&rdquo;, but actually <a href="https://github.com/CeleritasCelery/rune/blob/58575bf028264d4c512826b0bbbc3e747a300659/crates/text-buffer/src/metric.rs#L1009-L1012">it does not (yet)</a>.) And scanning for new lines as well as special-casing for <span>CRLF</span> (e.g., what about inserting <code>CR</code> and only afterwards <code>LF</code>?) certainly takes time&hellip; or maybe not. <sup><a href="https://kyo.iroiro.party#fn.perf">6</a></sup>But anyway, to quote from one of my favorite benchmarking libraries (<a href="https://github.com/openjdk/jmh/"><span>JMH</span></a>): </p><blockquote><p><span>REMEMBER</span>: The numbers below are just data. To gain reusable insights, you need to follow up on why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial experiments, perform baseline and negative tests that provide experimental control, make sure the benchmarking environment is safe on <span>JVM</span>/<span>OS</span>/<span>HW</span> level, ask for reviews from the domain experts. Do not assume the numbers tell you what you want them to tell. </p></blockquote> </div></div></div><div><h2> <span>4.</span> Summarizing<a href="https://kyo.iroiro.party#summarizing" title="Permalink to this heading">&para;</a></h2><div><p>In this post we mostly covered some of the text processing features of Emacs and what challenges they pose on implementations. Personally, I am yet to see another language design that puts embedded raw bytes into the built-in string, and it is indeed a good-to-have feature for me. So kudos again to Emacs maintainers and contributors! In a future post or two (that I hope I can eventually finish), we will be discussing redisplay in Emacs and look into why Emacs can be hard to parallelize. </p><hr> <blockquote><p>Thanks for reading! There are some discussions about this post on <a href="https://lobste.rs/s/jeg5l9/why_rewriting_emacs_is_hard">Lobsters</a>, <a href="https://www.reddit.com/r/emacs/comments/1n7i586/why_rewriting_emacs_is_hard_from_gudzpoz/">Reddit</a> and <a href="https://news.ycombinator.com/item?id=45122442"><span>HN</span></a>, and there are some insightful comments there that you might want to check out! </p><p>Notably, Troy Hinckley, the author of Rune and the &ldquo;Text showdown: Gap Buffers vs Ropes&rdquo; blog post <a href="https://www.reddit.com/r/emacs/comments/1n7i586/comment/ncbcwnh/">pointed out several issues</a> in this post and talked about his vision of ways to handle the problems presented here. (The rune repo is at <a href="https://github.com/CeleritasCelery/rune">https://github.com/CeleritasCelery/rune</a> by the way.) </p><p>Also, Ramin Honary, who&rsquo;s behind Schemacs (originally named Gypsum), <a href="https://fe.disroot.org/@ramin_hal9001/posts/AxprmwhQXPVuQqGE3E">shared his view about these challenges on Fedi</a>. (The Schemacs repo is at <a href="https://codeberg.org/ramin_hal9001/schemacs">https://codeberg.org/ramin_hal9001/schemacs</a>.) </p></blockquote> </div></div></div></section>]]></description><pubDate>Wed, 03 Sep 2025 21:44:47 +0530</pubDate></item><item><link>https://ordep.dev/posts/writing-code-was-never-the-bottleneck</link><title>Writing Code Was Never The Bottleneck (ordep.dev)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n7ggac/writing_code_was_never_the_bottleneck/</guid><comments>https://www.reddit.com/r/programming/comments/1n7ggac/writing_code_was_never_the_bottleneck/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 3 min | <a href='https://www.reddit.com/r/programming/comments/1n7ggac/writing_code_was_never_the_bottleneck/'>Post permalink</a></p></section><section class='separator separator-after-permalink'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='selftext'><!-- SC_OFF --><div class="md"><blockquote><p>The actual bottlenecks were, and still are, code reviews, knowledge transfer through mentoring and pairing, testing, debugging, and the human overhead of coordination and communication. All of this wrapped inside the labyrinth of tickets, planning meetings, and agile rituals.</p></blockquote></div><!-- SC_ON --></section><section class='preview-image'><p>&nbsp;</p><img src='https://ordep.dev/assets/images/social/writing-code-was-never-the-bottleneck.png' /></section><section class='parsed-content'><div><p>For years, I&rsquo;ve felt that writing lines of code <em>was never</em> the bottleneck in software engineering.</p><p>The actual bottlenecks were, and still are, <strong>code reviews</strong>, <strong>knowledge transfer</strong> through mentoring and pairing, <strong>testing</strong>, <strong>debugging</strong>, and the human overhead of <strong>coordination and communication</strong>. All of this wrapped inside the labyrinth of tickets, planning meetings, and agile rituals.</p><p>These processes, meant to drive quality, often slow us down more than the act of writing code itself because they require thought, shared understanding, and sound judgment.</p><p>Now, with LLMs making it easy to generate working code faster than ever, a new narrative has emerged: that writing code <em>was</em> the bottleneck, and we&rsquo;ve finally cracked it.</p><p>But that&rsquo;s <strong>not quite right</strong>.</p><p>The marginal cost of adding new software is approaching <strong>zero</strong>, especially with LLMs. But what is the price of <em>understanding</em>, <em>testing</em>, and <em>trusting</em> that code? <strong>Higher than ever</strong>.</p><hr> <h2>LLMs shift the workload &mdash; they don&rsquo;t remove it</h2><p>Tools like Claude can speed up initial implementation. Still, the result is often more code flowing through systems and more pressure on the people responsible for reviewing, integrating, and maintaining it.</p><p>This becomes especially clear when:</p><ul> <li>It&rsquo;s unclear whether the author fully understands what they submitted.</li> <li>The generated code introduces unfamiliar patterns or breaks established conventions.</li> <li>Edge cases and unintended side effects aren&rsquo;t obvious.</li> </ul><p>We end up in a situation where code is more straightforward to produce but more complex to verify, which doesn&rsquo;t necessarily make teams move faster overall.</p><p>It&rsquo;s not a new challenge. Developers have long joked about <strong>&ldquo;copy-paste engineering&rdquo;</strong>, but the velocity and scale that LLMs enable have <strong>amplified those copy-paste habits</strong>.</p><hr> <h2>Understanding code is still the hard part</h2> <blockquote><p><em>&ldquo;The biggest cost of code is understanding it &mdash; not writing it.&rdquo;</em></p></blockquote><p>LLMs reduce the time it takes to produce code, but they haven&rsquo;t changed the amount of effort required to reason about behavior, identify subtle bugs, or ensure long-term maintainability. That work can be even more challenging when reviewers struggle to distinguish between generated and handwritten code or understand why a particular solution was chosen.</p><hr> <h2>Teams still rely on trust and shared context</h2><p>Software engineering has always been collaborative. It depends on <strong>shared understanding</strong>, <strong>alignment</strong>, and <strong>mentoring</strong>. However, when code is generated faster than it can be discussed or reviewed, teams risk falling into a mode where <strong>quality is assumed rather than ensured</strong>. That creates stress on reviewers and mentors, potentially slowing things down in more subtle ways.</p><hr> <h2>LLMs are powerful &mdash; but they don&rsquo;t fix the fundamentals</h2><p>There&rsquo;s real value in faster prototyping, scaffolding, and automation. But LLMs don&rsquo;t remove the need for <strong>clear thinking</strong>, <strong>careful review</strong>, and <strong>thoughtful design</strong>. If anything, those become even more important as more code gets generated.</p><p>Yes, the cost of writing code has indeed dropped. But the cost of making sense of it together as a team <strong>hasn&rsquo;t</strong>.</p><p><strong>That&rsquo;s still the bottleneck. Let&rsquo;s not pretend it isn&rsquo;t.</strong></p></div></section>]]></description><pubDate>Wed, 03 Sep 2025 20:03:25 +0530</pubDate></item><item><link>https://blog.frost.kiwi/dual-kawase/</link><title>Video Game Blurs (and how the best one works) (blog.frost.kiwi)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n7c780/video_game_blurs_and_how_the_best_one_works/</guid><comments>https://www.reddit.com/r/programming/comments/1n7c780/video_game_blurs_and_how_the_best_one_works/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 347 min | <a href='https://www.reddit.com/r/programming/comments/1n7c780/video_game_blurs_and_how_the_best_one_works/'>Post permalink</a></p></section><section class='separator separator-before-parsed-content'><p>&nbsp;</p><hr><p>&nbsp;</p></section><section class='parsed-content'><div><p>Blurs are the basic building block for many <a href="https://en.wikipedia.org/wiki/Video_post-processing#Uses_in_3D_rendering">video game post-processing effects</a> and essential for sleek and modern <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUIs</a>. Video game <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/depth-of-field-in-unreal-engine">Depth of Field</a> and <a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom</a> or <a href="https://blog.frost.kiwi/GLSL-noise-and-radial-gradient/#microsoft-windows-acrylic">frosted panels</a> in modern user interfaces - used subtly or obviously - they&rsquo;re everywhere. <span>Even your browser can do it, just tap this sentence!</span></p><figure><img src="https://blog.frost.kiwiimg/intro.png" alt="Texture coordinates, also called UV Coordinates or UVs for short"><figcaption>Effect of "<a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom</a>", one of many use-cases for blur algorithms</figcaption></figure><p>Conceptually, <em>&ldquo;Make thing go blurry&rdquo;</em> is easy, boiling down to some form of <em>&ldquo;average colors in radius&rdquo;</em>. Doing so in <a href="https://en.wikipedia.org/wiki/Real-time_computing">realtime</a> however, took many a graphics programmer through decades upon decades of research and experimentation, across computer science and maths. In this article, we&rsquo;ll follow their footsteps.</p><blockquote><p>A graphics programming time travel, if you will.</p><img src="https://blog.frost.kiwi/assets/kiwis/cyber.svg"></blockquote><p>Using the <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPU</a> in the device you are reading this article on, and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> capability of your browser, we&rsquo;ll implement realtime blurring techniques and retrace the trade-offs graphics programmers had to make in order to marry two, sometimes opposing, worlds: <strong>Mathematical theory</strong> and <strong>Technological reality</strong>.</p><blockquote><div><p>This is my submission to this year's <a href="https://some.3b1b.co/">Summer of Math Exposition</a></p></div><img src="https://blog.frost.kiwiimg/SOMELogo.svg"></blockquote><p>With many interactive visualizations to guide us, we&rsquo;ll journey through a bunch of blurs, make a detour through frequency space manipulations, torture your graphics processor to measure performance, before finally arriving at an algorithm with years worth of cumulative graphics programmer sweat - The &#10024; Dual Kawase Blur &#127775;</p><h2>Setup - No blur yet <a href="https://blog.frost.kiwi#setup---no-blur-yet">#</a></h2><p>In the context of video game post-processing, a 3D scene is drawn, also called <a href="https://en.wikipedia.org/wiki/Rendering_(computer_graphics)">rendering</a>, and saved to an intermediary image - a <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">framebuffer</a>. In turn, this framebuffer is processed to achieve <a href="https://en.wikipedia.org/wiki/Video_post-processing#Uses_in_3D_rendering">various effects</a>. Since this <em>processing</em> happens <em>after</em> a 3D scene is rendered, it&rsquo;s called <em>post-processing</em>. All that, <em>many</em> times a second.</p><blockquote><div><p><strong>Depending on technique</strong>, framebuffers <a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">can hold non-image data</a> and post-processing effects like <a href="https://en.wikipedia.org/wiki/Color_correction">Color-correction</a> or <a href="https://en.wikipedia.org/wiki/Tone_mapping">Tone-mapping</a> don't even require intermediate framebuffers: There's <a href="https://takahirox.github.io/three.js/examples/webgl_tonemapping.html">more</a> than <a href="https://gdcvault.com/play/1020631/The-Revolution-in-Mobile-Game">one way (@35:20)</a></p></div><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>This is where we jump in: with a framebuffer in hand, after the 3D scene was drawn. We&rsquo;ll use a scene from a <a href="https://en.wikipedia.org/wiki/Video_game_modding">mod</a> called <a href="https://store.steampowered.com/app/244630/NEOTOKYO/">NEOTOKYO&deg;</a>. Each time we&rsquo;ll implement a blur, there will be a box, a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/canvas">canvas</a> instructed with <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL 1.0</a>, rendering at <a href="https://en.wikipedia.org/wiki/1:1_pixel_mapping"><strong>native</strong> resolution</a> of your device. Each box has controls and relevant parts of its code below.</p><blockquote><p>No coding or graphics programming knowledge required to follow along. <a href="https://github.com/FrostKiwi/treasurechest/tree/main/posts/dual-kawase">But also no curtains!</a> You can always see <a href="https://www.youtube.com/watch?v=ONH-pxBMJu4">how we talk</a> with your GPU. Terms and meanings will be explained, once it's relevant.</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"></blockquote><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p></div><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span></p></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr></table></div><blockquote><details><summary>Blur Fragment Shader <a href="https://blog.frost.kiwishader/noBlurYet.fs">noBlurYet.fs</a></summary><pre><code><span>/* This is the blur "fragment shader", a program that runs on the GPU. In *this* article, the blur fragment shader runs once per output pixel of the canvas */</span> <span>/* Required in WebGL 1 Shaders and depending on platform may have no effect. For Later: Strong blurs may have a lot of minute color contributions, so we set it "highp" here, the maximum. */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader "simpleQuad.vs". This tells our current output pixel where to read our texture from. */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>/* lightBrightness input. The reason light brightness is in the fragment shader of the blur and not a value applied in a step before our blur shader before, is due to color precision limits. */</span> <span>uniform</span> <span>float</span> lightBrightness<span>;</span> <span>/* Out texture input */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>/* The "main" function, where which is executed by our GPU */</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* gl_FragColor is the output of our shader. texture2D is the texture read, performed with the current 'uv' coordinate. Then multiplied by our lightBrightness value (a multiplier with eg. 1.0 at 100%, 0.5 at 50%) In "scene" mode, this value is locked to 1.0 so it has no effect */</span> gl_FragColor <span>=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span> <span>*</span> lightBrightness<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/simple.js">simple.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupSimple</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-Simple'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>lightBrightness</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> noBlurYetFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/noBlurYet.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Helper for recompilation */</span> <span>function</span> <span>reCompileBlurShader</span><span>(</span><span>)</span> <span>{</span> ctx<span>.</span>shd<span>.</span>blur <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> noBlurYetFrag<span>,</span> <span>[</span><span>"lightBrightness"</span><span>]</span><span>)</span><span>;</span> <span>}</span> <span>/* Blur Shader */</span> <span>reCompileBlurShader</span><span>(</span><span>)</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Box blur at native resolution */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>handle<span>)</span><span>;</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>lightBrightness<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>We don&rsquo;t have a blur implemented yet, not much happening. Above the box you have an <code>Animate</code> button, which will move the scene around to tease out problems of upcoming algorithms. Movement happens <strong>before</strong> our blur will be applied, akin to the player character moving. To see our blur in different use-cases, there are 3 modes:</p><blockquote><p>Different blur algorithms behave differently based on use-case. Some are very performance efficient, but break under movement. Some reveal their flaws with small, high contrast regions like far-away lights</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><ul><li>In <code>Scene</code> mode the blur will be applied across the whole image</li><li>In <code>Lights</code> mode we see and blur just the <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html#emission">Emission</a> parts of the scene, sometimes called &ldquo;<a href="https://developer.valvesoftware.com/wiki/Glowing_textures_(Source)#$selfillum">Self-Illumination</a>&rdquo;<ul><li>This also unlocks the <code>lightBrightness</code> slider, where you can boost the energy output of the lights</li></ul></li><li>In <code>Bloom</code> mode, we use the original scene and add the blurred lights from the previous mode on top to create a moody scene. This implements the effect of <a href="https://en.wikipedia.org/wiki/Bloom_(shader_effect)">Bloom</a>, an important use-case for blurs in real-time 3D graphics</li></ul><blockquote><p>Adding the blurred emission <a href="https://chrismillervfx.wordpress.com/2013/04/15/understanding-render-passes/">pass</a> as we do in this article, or <a href="https://en.wikipedia.org/wiki/Thresholding_(image_processing)">thresholding</a> the scene and blurring that, is <strong>not</strong> actually how modern video games do bloom. We'll get into that a bit later.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Finally, you see <a href="https://en.wikipedia.org/wiki/Image_resolution">Resolution</a> of the canvas and <a href="https://en.wikipedia.org/wiki/Frame_rate">Frames per Second / time taken per frame, aka &ldquo;frametime&rdquo;</a>. A very important piece of the puzzle is <em><strong>performance</strong></em>, which will become more and more important as the article continues and the <a href="https://en.wikipedia.org/wiki/Necessity_is_the_mother_of_invention">mother of invention</a> behind our story.</p><blockquote><p>Frame-rate will be capped at your screen's <a href="https://www.intel.com/content/www/us/en/gaming/resources/highest-refresh-rate-gaming.html">refresh rate</a>, most likely 60 fps / 16.6 ms. We'll get into proper <a href="https://en.wikipedia.org/wiki/Benchmark_(computing)">benchmarking</a> as our hero descents this article into blurry madness</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"></blockquote><h3>Technical breakdown <a href="https://blog.frost.kiwi#technical-breakdown">#</a></h3><blockquote><p>Understanding the GPU code is not necessary to follow this article, but if you do choose to <a href="https://github.com/FrostKiwi/treasurechest/tree/main/posts/dual-kawase">peek behind the curtain</a>, here is what you need to know</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><p>We&rsquo;ll implement our blurs as a <a href="https://learnopengl.com/Getting-started/Hello-Triangle">fragment shader</a> written in <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a>. In a nut-shell, a fragment shader is code that runs on the GPU for every output-pixel, in-parallel. Image inputs in shaders are called <a href="https://learnopengl.com/Getting-started/Textures">Textures</a>. These textures have coordinates, often called <a href="https://en.wikipedia.org/wiki/UV_mapping">UV coordinates</a> - <em>these</em> are the numbers we care about.</p><blockquote><p>Technically, fragment shaders run per <a href="https://www.khronos.org/opengl/wiki/Fragment">fragment</a>, which aren't necessarily pixel sized and there are <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_shader_framebuffer_fetch.txt">other ways</a> to read framebuffers, but none of that matters in the context of this article.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><figure><img src="https://blog.frost.kiwiimg/UV.svg" alt="Texture coordinates, also called UV Coordinates or UVs for short"><figcaption>Texture coordinates, also called "UV" Coordinates or "UVs" for short<br>Note the squished appearance of the image</figcaption></figure><p>UV coordinates specify the position we read in the image, with bottom left being <code>0,0</code> and the top right being <code>1,1</code>. Neither UV coordinates, nor shaders themselves have any concept of image resolution, screen resolution or aspect ratio. If we want to address individual pixels, it&rsquo;s on us to express that in terms of UV coordinates.</p><blockquote><div><p>Although <a href="https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/">there are ways to find out</a>, we don't know which order output-pixels are processed in, and although the <a href="https://docs.gl/sl4/gl_FragCoord">graphics pipeline can tell us</a>, the shader doesn't even know which output-pixel it currently processes</p></div><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"></blockquote><p>The framebuffer is passed into the fragment shader in line <code>uniform sampler2D texture</code> as a texture. Using the blur shader, we draw a &ldquo;Full Screen Quad&rdquo;, a rectangle covering the entire canvas, with matching <code>0,0</code> in the bottom-left and <code>1,1</code> in the top-right <code>varying vec2 uv</code> UV coordinates to read from the texture.</p><p>The texture&rsquo;s aspect-ratio and resolution are the same as the output canvas&rsquo;s aspect-ratio and resolution, thus there is a 1:1 pixel mapping between the texture we will process and our output canvas. The <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/dual-kawase/js/blur/simple.js">graphics pipeline steps</a> and <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/dual-kawase/shader/simpleQuad.vs">vertex shader</a> responsible for this are not important for this article.</p><p>The blur fragment shader accesses the color of the texture with <code>texture2D(texture, uv)</code>, at the matching output pixel&rsquo;s position. In following examples, we&rsquo;ll read from neighboring pixels, for which we&rsquo;ll need to calculate a UV coordinate offset, a decimal fraction corresponding to one pixel step, calculated with with <code>1 / canvasResolution</code></p><blockquote><p>One way to think of fragment shader code is "What are the instructions to construct this output pixel?"</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"></blockquote><p>Graphics programming is <a href="https://www.youtube.com/watch?v=xJQ0qXh1-m0">uniquely challenging</a> in the beginning, because of how many rules and limitations the hardware, <a href="https://en.wikipedia.org/wiki/Graphics_library">graphics APIs</a> and the <a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">rendering pipeline</a> impose. But it also unlocks incredible potential, as other limitations dissolve. Let&rsquo;s find out how graphics programmers have leveraged that potential.</p><h2>Box Blur <a href="https://blog.frost.kiwi#box-blur">#</a></h2><p>From a programmer&rsquo;s perspective, the most straight forward way is to average the neighbors of a pixel using a <a href="https://en.wikipedia.org/wiki/For_loop">for-loop</a>. What the fragment shader is expressing is: &ldquo;<em>look Y pixels up &amp; down, X pixels left &amp; right and average the colors</em>&rdquo;. The more we want to blur, the more we have to increase <code>kernelSize</code>, the bounds of our for-loop.</p><pre><code><span>/* Read from the texture y amount of pixels above and below */</span> <span>for</span> <span>(</span><span>int</span> y <span>=</span> <span>-</span>kernel_size<span>;</span> y <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>y<span>)</span> <span>{</span> <span>/* Read from the texture x amount of pixels to the left and the right */</span> <span>for</span> <span>(</span><span>int</span> x <span>=</span> <span>-</span>kernel_size<span>;</span> x <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>x<span>)</span> <span>{</span> <span>/* Offset from current pixel, indicating which pixel to read */</span> <span>vec2</span> offset <span>=</span> <span>vec2</span><span>(</span>x<span>,</span> y<span>)</span> <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Read and sum up the color contribution of that pixel */</span> sum <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> offset<span>)</span><span>;</span> <span>}</span> <span>}</span></code></pre><p>The bigger the for-loop, the more texture reads we perform, <strong>per output-pixel</strong>. Each texture read is often called a &ldquo;texture tap&rdquo; and the total amount of those &ldquo;taps&rdquo; per-frame will now also be displayed. New controls, new <code>samplePosMultiplier</code>, new terms - Play around with them, get a feel for them, with a constant eye on FPS.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p><svg><circle></circle><rect height="7" width="2"></rect><rect height="9" width="2"></rect></svg></div><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>7x7</output>&nbsp;px</td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr></table></div><blockquote><details><summary>Blur Fragment Shader <a href="https://blog.frost.kiwishader/boxBlur.fs">boxBlur.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large Kernel Sizes result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>/* Resolution Reciprocal. Getting to the next pixel requires us to calculate `UV Coordinate / frameSize`. On hardware, doing a division is slightly slower than doing a multiplication. Since the shader is run per pixel, we avoid the per-pixel division, by calculating the reciprocal 1 / frameSize and pass it into the shader. A very popular micro-optimization across graphics programming */</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>uniform</span> <span>float</span> samplePosMult<span>;</span> <span>/* Multiply to push blur strength past the kernel size */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>/* `KERNEL_SIZE` added during compilation */</span> <span>const</span> <span>int</span> kernel_size <span>=</span> KERNEL_SIZE<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Variable to hold our final color for the current pixel */</span> <span>vec4</span> sum <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> <span>/* How big one side of the sampled square is */</span> <span>const</span> <span>int</span> size <span>=</span> <span>2</span> <span>*</span> kernel_size <span>+</span> <span>1</span><span>;</span> <span>/* Total number of samples we are going to read */</span> <span>const</span> <span>float</span> totalSamples <span>=</span> <span>float</span><span>(</span>size <span>*</span> size<span>)</span><span>;</span> <span>/* Read from the texture y amount of pixels above and below */</span> <span>for</span> <span>(</span><span>int</span> y <span>=</span> <span>-</span>kernel_size<span>;</span> y <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>y<span>)</span> <span>{</span> <span>/* Read from the texture x amount of pixels to the left and the right */</span> <span>for</span> <span>(</span><span>int</span> x <span>=</span> <span>-</span>kernel_size<span>;</span> x <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>x<span>)</span> <span>{</span> <span>/* Offset from the current pixel, indicating which pixel to read */</span> <span>vec2</span> offset <span>=</span> <span>vec2</span><span>(</span>x<span>,</span> y<span>)</span> <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Read and sum up the contribution of that pixel */</span> sum <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> offset<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Return the sum, divided by the number of samples (normalization) */</span> gl_FragColor <span>=</span> <span>(</span>sum <span>/</span> totalSamples<span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/boxBlur.js">boxBlur.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupBoxBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-BoxBlur'</span><span>)</span><span>;</span> <span>const</span> WebGLBoxDetail <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-BoxBlurDetail'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>kernelSize</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sizeRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> boxBlurFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/boxBlur.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/boxBlurBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>blurShaderSrc</span><span>:</span> boxBlurFrag<span>,</span> <span>kernelSize</span><span>:</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Helper for recompilation */</span> <span>function</span> <span>reCompileBlurShader</span><span>(</span><span>blurSize</span><span>)</span> <span>{</span> ctx<span>.</span>shd<span>.</span>blur <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> boxBlurFrag<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"samplePosMult"</span><span>,</span> <span>"bloomStrength"</span><span>]</span><span>,</span> <span>"#define KERNEL_SIZE "</span> <span>+</span> blurSize <span>+</span> <span>'\n'</span><span>)</span><span>;</span> <span>}</span> <span>/* Blur Shader */</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> KernelSizeSide <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>canvas<span>.</span>width <span>*</span> canvas<span>.</span>height <span>*</span> KernelSizeSide <span>*</span> KernelSizeSide <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Box blur at native resolution */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>handle<span>)</span><span>;</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>Visually, the result doesn&rsquo;t look very pleasing. The stronger the blur, the more &ldquo;boxy&rdquo; features of the image become. This is due to us reading and averaging the texture in a square shape. Especially in bloom mode, with strong <code>lightBrightness</code> and big <code>kernelSize</code>, lights become literally squares.</p><p>Performance is also really bad. With bigger <code>kernelSizes</code>, our <code>Texture Taps</code> count skyrockets and performance drops. Mobile devices will come to a slog. Even the worlds fastest PC graphics cards will fall below screen refresh-rate by cranking <code>kernelSize</code> and zooming the article on PC, thus raising canvas resolution.</p><blockquote><p>We kinda failed on all fronts. It looks bad <strong>and</strong> runs bad.</p><img src="https://blog.frost.kiwi/assets/kiwis/facepalm.svg"></blockquote><p>Then, there&rsquo;s this <code>samplePosMultiplier</code>. It seems to <em>also</em> seemingly increase blur strength, <em>without</em> increasing textureTaps or lowering performance (or lowering performance just a little on certain devices). But if we crank <em>that</em> too much, we get artifacts in the form of repeating patterns. Let&rsquo;s play with a schematic example:</p><ul><li>The white center square represents the output pixel</li><li>Grey squares are the pixels we would read, with the current <code>kernelSize</code>, with <code>samplePosMult</code> untouched</li><li>the black dots are our <em>actual</em> texture reads <em><strong>per-output-pixel</strong></em>, our &ldquo;sample&rdquo; positions</li></ul><div><table><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>3&times;3</output></td><td></td></tr><tr><td><code>samplePosMult</code></td></tr><tr><td><code>samplePosMult</code></td><td></td><td><output>100</output>%</td><td></td></tr></table></div><p>On can say, that an image is a &ldquo;continous 2D signal&rdquo;. When we texture tap at a specific coordinate, we are <em>sampling the &ldquo;image signal&rdquo; at that coordinate</em>. As previously mentioned, we use UV coordinates and are not bound by concepts like &ldquo;pixels position&rdquo;. <em><strong>Where</strong></em> we place our samples is completely up to us.</p><p>A fundamental blur algorithm option is increasing the sample distance away from the center, thus increasing the amount of image we cover with our samples - more bang for your sample buck. This works by multiplying the offset distance. That is what <code>samplePosMult</code> does and is something you will have access to going forward.</p><p>Doing it too much, brings ugly repeating patterns. This of course leaves some fundamental questions, like where these artifacts come from and what it even means to read between two pixels. <em><strong>And</strong></em> on top of that we have to address performance and the boxyness of our blur! But first&hellip;</p><h2>What even <em>is</em> a kernel? <a href="https://blog.frost.kiwi#what-even-is-a-kernel%3F">#</a></h2><p>What we have created with our for-loop, is a <a href="https://www.youtube.com/watch?v=KuXjwB4LzSA0">convolution</a>. Very simplified, in the context of image processing, it&rsquo;s usually a square of numbers constructing an output pixel, by gathering and weighting pixels, that the square covers. The square is called a kernel and was the thing we visualized previously.</p><p>For blurs, the kernel weights must sum up to 1. If that were not the case, we would either brighten or darken the image. Ensuring that is the normalization step. In the box blur above, this happens by dividing the summed pixel color by <code>totalSamples</code>, the total amount of samples taken. A basic &ldquo;calculate the average&rdquo; expression.</p><p>The same can be expressed as weights of a kernel, a number multiplied with each sample at that position. Since the box blur weighs all sample the same regardless of position, all weights are the same. This is visualized next. The bigger the kernel size, the smaller the weights.</p><div><svg></svg><table><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>3&times;3</output></td><td></td></tr><tr><td><code>samplePosMult</code></td></tr><tr><td><code>samplePosMult</code></td><td></td><td><output>100</output>%</td><td></td></tr></table></div><p>Kernels applied at the edges of our image will read from areas &ldquo;outside&rdquo; the image, with UV coordinates smaller than <code>0,0</code> and bigger than <code>1,1</code>. Luckily, the GPU handles this for us and we are free to decide what happens to those outside samples, by setting the <a href="https://learnopengl.com/Getting-started/Textures#:~:text=Texture%20Wrapping">Texture Wrapping mode</a>.</p><figure><img src="https://blog.frost.kiwiimg/WrappingModes.png" alt="Texture Wrapping Modes and results on blurring"><figcaption>Texture Wrapping Modes and results on blurring (Note the color black bleeding-in)<br><strong>Top</strong>: Framebuffer, zoomed out. <strong>Bottom</strong>: Framebuffer normal, with strong blur applied</figcaption></figure><p>Among others, we can define a solid color to be used, or to &ldquo;clamp&rdquo; to the nearest edge&rsquo;s color. If we choose a solid color, then we will get color bleeding at the edges. Thus for almost all post-processing use-cases, edge color clamping is used, as it prevents weird things happening at the edges. <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/dual-kawase/js/utility.js#L49">This article does too</a>.</p><blockquote><p>You may have noticed a black "blob" streaking with stronger blur levels along the bottom. Specifically here, it happens because the lines between the floor tiles align with the bottom edge, extending black color to infinity</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Convolution as a mathematical concept is surprisingly deep and <a href="https://www.youtube.com/@3blue1brown">3blue1brown</a> has an excellent video on it, that even covers the image processing topic. Theoretically, we won&rsquo;t depart from convolutions. We <em><strong>can</strong></em> dissect our code and express it as weights and kernels. With the for-loop box blur, that <em><strong>was</strong></em> quite easy!</p><figure><iframe src="https://www.youtube-nocookie.com/embed/KuXjwB4LzSA" title="YouTube video player" width="100%"></iframe><figcaption>But what is a convolution?<br><a href="https://www.youtube.com/watch?v=KuXjwB4LzSA">YouTube Video</a> by <a href="https://www.youtube.com/@3blue1brown">3Blue1Brown</a></figcaption></figure><p>On a practical level though, understanding where the convolution is, how many there are and what kernels are at play will become more and more difficult, once we leave the realm of classical blurs and consider the wider implications of reading between pixel bounds. But for now, we stay with the classics:</p><h2>Gaussian Blur <a href="https://blog.frost.kiwi#gaussian-blur">#</a></h2><p>The most famous of blur algorithms is the Gaussian Blur. It uses the <a href="https://en.wikipedia.org/wiki/Normal_distribution">normal distribution</a>, also known as the <a href="https://en.wikipedia.org/wiki/Normal_distribution">bell Curve</a> to weight the samples inside the kernel, with a new variable <code>sigma &sigma;</code> to control the flatness of the curve. Other than generating the kernel weights, the algorithm is identical to the box blur algorithm.</p><figure><figcaption>Gaussian blur weights formula for point <code>(x,y)</code> <a href="https://en.wikipedia.org/wiki/Gaussian_blur#Mathematics">(Source)</a></figcaption></figure><p>To calculate the weights for point <code>(x,y)</code>, the <a href="https://en.wikipedia.org/wiki/Gaussian_blur#Mathematics">above formula is used</a>. The gaussian formula has a weighting multiplier <code>1/&radic;(2&pi;&sigma;&sup2;)</code>. In the code, there is no such thing though. The formula expresses the gaussian curve as a <em>continuous</em> function going to <em>infinity</em>. But our code and its for-loop are different - <em><strong>discrete</strong></em> and <em><strong>finite</strong></em>.</p><pre><code><span>float</span> <span>gaussianWeight</span><span>(</span><span>float</span> x<span>,</span> <span>float</span> y<span>,</span> <span>float</span> sigma<span>)</span> <span>{</span> <span>/* (x&sup2; + y&sup2;) / 2 &sigma;&sup2; */</span> <span>return</span> <span>exp</span><span>(</span><span>-</span><span>(</span>x <span>*</span> x <span>+</span> y <span>*</span> y<span>)</span> <span>/</span> <span>(</span><span>2.0</span> <span>*</span> sigma <span>*</span> sigma<span>)</span><span>)</span><span>;</span> <span>}</span></code></pre><blockquote><p>For clarity, the kernel is generated in the fragment shader. Normally, that should be avoided. Fragment shaders run per-output-pixel, but the kernel weights stay the same, making this inefficient.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><p>Just like with the box blur, weights are summed up and divided at the end, instead of the term <code>1/&radic;(2&pi;&sigma;&sup2;)</code> precalculating weights. <code>sigma</code> controls the sharpness of the curve and thus the blur strength, but wasn&rsquo;t that the job of <code>kernelSize</code>? Play around with all the values below and get a feel for how the various values behave.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p><svg><circle></circle><rect height="7" width="2"></rect><rect height="9" width="2"></rect></svg></div><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>7x7</output>&nbsp;px</td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>sigma</code></td></tr><tr><td><code>sigma</code></td><td></td><td>&plusmn;<output>2.00</output>&sigma;</td><td></td></tr></table></div><blockquote><details><summary>Blur Fragment Shader <a href="https://blog.frost.kiwishader/gaussianBlur.fs">gaussianBlur.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large Kernel Sizes result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> samplePosMult<span>;</span> <span>/* Multiply to push blur strength past the kernel size */</span> <span>uniform</span> <span>float</span> sigma<span>;</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>/* `KERNEL_SIZE` added during compilation */</span> <span>const</span> <span>int</span> kernel_size <span>=</span> KERNEL_SIZE<span>;</span> <span>float</span> <span>gaussianWeight</span><span>(</span><span>float</span> x<span>,</span> <span>float</span> y<span>,</span> <span>float</span> sigma<span>)</span> <span>{</span> <span>/* (x&sup2; + y&sup2;) / 2 &sigma;&sup2; */</span> <span>return</span> <span>exp</span><span>(</span><span>-</span><span>(</span>x <span>*</span> x <span>+</span> y <span>*</span> y<span>)</span> <span>/</span> <span>(</span><span>2.0</span> <span>*</span> sigma <span>*</span> sigma<span>)</span><span>)</span><span>;</span> <span>}</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Variable to hold our final color for the current pixel */</span> <span>vec4</span> sum <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> <span>/* Sum of all weights */</span> <span>float</span> weightSum <span>=</span> <span>0.0</span><span>;</span> <span>/* How big one side of the sampled square is */</span> <span>const</span> <span>int</span> size <span>=</span> <span>2</span> <span>*</span> kernel_size <span>+</span> <span>1</span><span>;</span> <span>/* Total number of samples we are going to read */</span> <span>const</span> <span>float</span> totalSamples <span>=</span> <span>float</span><span>(</span>size <span>*</span> size<span>)</span><span>;</span> <span>/* Read from the texture y amount of pixels above and below */</span> <span>for</span> <span>(</span><span>int</span> y <span>=</span> <span>-</span>kernel_size<span>;</span> y <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>y<span>)</span> <span>{</span> <span>/* Read from the texture x amount of pixels to the left and the right */</span> <span>for</span> <span>(</span><span>int</span> x <span>=</span> <span>-</span>kernel_size<span>;</span> x <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>x<span>)</span> <span>{</span> <span>/* Calculate the required weight */</span> <span>float</span> w <span>=</span> <span>gaussianWeight</span><span>(</span><span>float</span><span>(</span>x<span>)</span><span>,</span> <span>float</span><span>(</span>y<span>)</span><span>,</span> sigma<span>)</span><span>;</span> <span>/* Offset from the current pixel, indicating which pixel to read */</span> <span>vec2</span> offset <span>=</span> <span>vec2</span><span>(</span>x<span>,</span> y<span>)</span> <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Read and sum up the contribution of that pixel, weighted */</span> sum <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> offset<span>)</span> <span>*</span> w<span>;</span> weightSum <span>+=</span> w<span>;</span> <span>}</span> <span>}</span> <span>/* Return the sum, divided by the number of samples (normalization) */</span> gl_FragColor <span>=</span> <span>(</span>sum <span>/</span> weightSum<span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/gaussianBlur.js">gaussianBlur.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupGaussianBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianBlur'</span><span>)</span><span>;</span> <span>const</span> WebGLBoxDetail <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianBlurDetail'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>sigma</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>kernelSize</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sizeRange'</span><span>)</span><span>,</span> <span>sigma</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sigmaRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBoxDetail<span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> gaussianBlurFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/gaussianBlur.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/gaussianBlurBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>blurShaderSrc</span><span>:</span> gaussianBlurFrag<span>,</span> <span>kernelSize</span><span>:</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>,</span> <span>sigma</span><span>:</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Helper for recompilation */</span> <span>function</span> <span>reCompileBlurShader</span><span>(</span><span>blurSize</span><span>)</span> <span>{</span> ctx<span>.</span>shd<span>.</span>blur <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> gaussianBlurFrag<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"samplePosMult"</span><span>,</span> <span>"bloomStrength"</span><span>,</span> <span>"sigma"</span><span>]</span><span>,</span> <span>"#define KERNEL_SIZE "</span> <span>+</span> blurSize <span>+</span> <span>'\n'</span><span>)</span><span>;</span> <span>}</span> <span>/* Blur Shader */</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> KernelSizeSide <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>canvas<span>.</span>width <span>*</span> canvas<span>.</span>height <span>*</span> KernelSizeSide <span>*</span> KernelSizeSide <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Gaussian blur at native resolution */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>handle<span>)</span><span>;</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>The blur looks way smoother than our previous box blur, with things generally taking on a &ldquo;rounder&rdquo; appearance, due to the bell curve&rsquo;s smooth signal response. That is, unless you move the <code>sigma</code> slider down. If you move <code>sigma</code> too low, you will get our previous box blur like artifacts again.</p><p>Let&rsquo;s clear up what the values actually represent and how they interact. The following visualization shows the kernel with its weights expressed as height in an <a href="https://en.wikipedia.org/wiki/Isometric_projection"><s>Isometric</s></a> <a href="https://en.wikipedia.org/wiki/Axonometric_projection#Three_types">Dimetric</a> perspective projection. There are two different interaction modes with <code>sigma</code> when changing <code>kernelSize</code> and two ways to express <code>sigma</code>.</p><div><p><label> Absolute Sigma</label> <label> Relative Sigma</label></p><table><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>7&times;7</output></td><td></td></tr><tr><td><code>sigma</code></td></tr><tr><td><code>sigma</code></td><td> </td><td><span><span>&plusmn;<output>3.00</output>&sigma; </span><span><output>1.00</output>px</span></span></td><td></td></tr></table></div><p><code>sigma</code> describes the flatness of our mathematical curve, a curve going to infinity. But our algorithm has a limited <code>kernelSize</code>. Where the kernel stops, no more pixel contributions occur, leading to box-blur-like artifacts due to the cut-off. In the context of image processing, there are two ways to setup a gaussian blur&hellip;</p><blockquote><p>A small sigma, thus a flat bell curve, paired with a small kernel size effectively <strong>is</strong> a box blur, with the weights making the kernel box-shaped.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"></blockquote><p>&hellip; way 1: <a href="https://www.youtube.com/watch?v=ueNY30Cs8Lk">Absolute Sigma</a>. <code>sigma</code> is an absolute value in pixels independent of <code>kernelSize</code>, with <code>kernelSize</code> acting as a &ldquo;window into the curve&rdquo; or way 2: <code>sigma</code> is expressed <em><strong>relative</strong></em> to the current <code>kernelSize</code>. For practical reasons (finicky sliders) the relative to <code>kernelSize</code> mode is used everywhere.</p><p>Eitherway, the infinite gaussian curve <em><strong>will</strong></em> have a cut-off <em>somewhere</em>. <code>sigma</code> too small? - We get box blur like artifacts. <code>sigma</code> too big? - We waste blur efficiency, as the same perceived blur strength requires bigger kernels, thus bigger for-loops with lower performance. An artistic trade-off every piece of software has to make.</p><blockquote><p>An optimal kernel would be one, where the outer weights are almost zero. Thus, if we increased <code>kernelSize</code> in Absolute Sigma mode by one, it would make close to no more <strong>visual</strong> difference.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><p>There are other ways of creating blur kernels, with other properties. One way is to follow <a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal&rsquo;s triangle</a> to get a set of predefined kernel sizes and weights. These are called <a href="https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/">Binomial Filters</a> and lock us into specific &ldquo;kernel presets&rdquo;, but solve the infinity vs cut-off dilemma, by moving weights to zero within the sampling window.</p><p>Binomial Kernels are also Gaussian-like in their frequency response. We won&rsquo;t expand on these further, just know that we <em><strong>can</strong></em> choose kernels by different mathematical criteria, chasing different signal response characteristics. But speaking of which, what even <em>is</em> Gaussian Like? Why do we care?</p><h3>What is Gaussian-like? <a href="https://blog.frost.kiwi#what-is-gaussian-like%3F">#</a></h3><p>In Post-Processing Blur algorithms you generally find two categories. <a href="https://en.wikipedia.org/wiki/Bokeh">Bokeh</a> Blurs and Gaussian-Like Blurs. The gaussian is chosen for its natural appearance, its ability to smooth colors without &ldquo;standout features&rdquo;. Gaussian Blurs are generally used as an ingredient in an overarching visual effect, be it frosted glass Interfaces or Bloom.</p><figure><img src="https://blog.frost.kiwiimg/gaussianLike.png" alt="Bokeh blur, gaussian blur comparison"><figcaption>Bokeh Blur and Gaussian Blur compared.</figcaption></figure><p>In contrast to that, when emulating lenses and or creating <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/depth-of-field-in-unreal-engine">Depth of Field</a>, is &ldquo;<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/cinematic-depth-of-field-method?application_version=4.27">Bokeh Blur</a>&rdquo; - also known as &ldquo;Lens Blur&rdquo; or &ldquo;Cinematic Blur&rdquo;. This type of blur <em><strong>is</strong></em> the target visual effect. The challenges and approaches are very much related, but algorithms used differ.</p><p>Algorithms get really creative in this space, all with different trade-offs and visuals. Some sample using a <a href="https://mynameismjp.wordpress.com/2011/02/28/bokeh/">poission disk distribution</a> and some have cool out of the box thinking: Computerphile covered a comlex numbers based approach to creating Bokeh Blurs, a fascinating number theory cross-over.</p><figure><iframe src="https://www.youtube-nocookie.com/embed/vNG3ZAd8wCc" title="YouTube video player" width="100%"></iframe><figcaption>Video Game &amp; Complex Bokeh Blurs<br><a href="https://www.youtube.com/watch?v=vNG3ZAd8wCc">YouTube Video</a> by <a href="https://www.youtube.com/@Computerphile">Computerphile</a></figcaption></figure><p>This article though doesn&rsquo;t care about these stylistics approaches. We are here to chase a basic building block of graphics programming and realtime visual effects, a &ldquo;Gaussian-Like&rdquo; with good performance. Speaking of which!</p><h2>Performance <a href="https://blog.frost.kiwi#performance">#</a></h2><p>The main motivator of our journey here, is the chase of realtime performance. Everything we do must happen within few milliseconds. The expected performance of an algorithm and the practical cost once placed in the graphics pipeline, are sometimes surprisingly different numbers though. Gotta measure!</p><blockquote><p>This chapter is about a very <strong>technical</strong> motivation. If you don't care about how fast a GPU does what it does, feel free to skip this section.</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"></blockquote><p>With performance being such a driving motivator, it would be a shame if we couldn&rsquo;t measure it in this article. Each WebGL Box has a benchmark function, which blurs random noise at a fixed resolution of <code>1600x1200</code> with the respective blur settings you chose and a fixed iteration count workload, a feature hidden so far.</p><blockquote><p>Realtime graphics programming is sometimes more about measuring than programming.</p><img src="https://blog.frost.kiwi/assets/kiwis/laugh.svg"></blockquote><p>Benchmarking is best done by measuring shader execution time. This <a href="https://registry.khronos.org/webgl/extensions/EXT_disjoint_timer_query_webgl2/">can be done</a> in the browser reliably, but only on some platforms. No way exists to do so across all platforms. Luckily, there is the classic method of &ldquo;stalling the graphics pipeline&rdquo;, forcing a wait until all commands finish, a moment in time we can measure.</p><blockquote><p>Across all platforms a stall is guaranteed to occur on command <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels"><code>gl.readPixels()</code></a>. Interestingly, the standards conform command for this: <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/finish"><code>gl.finish()</code></a> is simply ignored by mobile apple devices.</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"></blockquote><p>Below is a button, that unlocks this benchmarking feature, unhiding a benchmark button and <code>Detailed Benchmark Results</code> section under each blur. This allows you to start a benchmark with a preset workload, on a separate <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Browser Worker</a>. There is only one issue: Browsers get <em><strong>very</strong></em> angry if you full-load the GPU this way.</p><p>If the graphics pipeline is doing work without reporting back (called &ldquo;yielding&rdquo;) to the browser for too long, browsers will simply kill all GPU access for the whole page, until tab reload. If we yield back, then the measured results are useless and from inside WebGL, we can&rsquo;t stop the GPU, once its commands are issued.</p><blockquote>&#9888;&#65039; Especially on mobile: <strong>please</strong> increase <code>kernelSize</code> and iterations slowly. The previous algorithms have bad <code>kernelSize</code> performance scaling on purpose, be especially careful with them.<p>Stay below <strong>2</strong> seconds of execution time, or the browser will lock GPU access for the page, disabling all blur examples, until a browser restart is performed. On iOS Safari this requires a trip to the App Switcher, a page reload won't be enough.</p></blockquote><blockquote><p>iOS and iPad OS are <strong>especially</strong> strict, will keep GPU access disabled, even on Tab Reload. You will have go to the App Switcher (Double Tap Home Button), Swipe Safari Up to close it and relaunch it from scratch.</p><img src="https://blog.frost.kiwi/assets/kiwis/miffed.svg"></blockquote><h3>What are we optimizing for? <a href="https://blog.frost.kiwi#what-are-we-optimizing-for%3F">#</a></h3><p>With the <a href="https://blog.frost.kiwi#box-blur">above Box Blur</a> and <a href="https://blog.frost.kiwi#gaussian-blur">above Gaussian Blur</a>, you will measure performance scaling very badly with <code>kernelSize</code>. Expressed in the <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a>, it has a performance scaling of <code>O(pixelCount * kernelSize&sup2;)</code>. Quadratic scaling of required texture taps in terms of <code>kernelSize</code>. We need to tackle this going forward.</p><blockquote><p>Especially dedicated Laptop GPUs are slow to get out of their lower power states. Pressing the benchmark button multiple times in a row may result in the performance numbers getting better.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Despite the gaussian blur calculating the kernel <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/dual-kawase/shader/gaussianBlur.fs#L18">completely from scratch on every single pixel in our implementation</a>, the performance of the box blur and gaussian blur are very close to each other at higher iteration counts. In fact, by precalculating the those kernels we could performance match both.</p><blockquote><p>But isn't gaussian blur a more complicated algorithm?</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"></blockquote><p>As opposed to chips from decades ago, modern graphics cards have very fast arithmetic, but comparatively slow memory access times. With workloads like these, the slowest thing becomes the memory access, in our case the texture taps. The more taps, the slower the algorithm.</p><blockquote><p>Our blurs perform a <strong>dependant texture read</strong>, a graphics programming sin. This is when texture coordinates are determined <strong>during</strong> shader execution, which opts out of a many automated shader optimizations.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><p>Especially on personal computers, you may also have noticed that increasing <code>samplePosMultiplier</code> will negatively impact performance (up to a point), even though the required texture taps stay the same.</p><p>This is due hardware texture caches accelerating texture reads which are spatially close together and not being able to do so effectively, if the texture reads are all too far apart. Platform dependant tools like <a href="https://developer.nvidia.com/blog/identifying-shader-limiters-with-the-shader-profiler-in-nvidia-nsight-graphics/">Nvidia NSight</a> can measure GPU cache utilization. The browser cannot.</p><p>These are key numbers graphics programmers chase when writing fragment shaders: <strong>Texture Taps</strong> and <strong>Cache Utilization</strong>. There is another one, we will get into in a moment. Clearly, our Blurs are <em><strong>slow</strong></em>. Time for a speed up!</p><h2>Separable Gaussian Blur <a href="https://blog.frost.kiwi#separable-gaussian-blur">#</a></h2><p>We have not yet left the <em>classics</em> of blur algorithms. One fundamental concept left on the table is &ldquo;convolution separability&rdquo;. Certain Convolutions like our <a href="https://blog.frost.kiwi#box-blur">Box Blur</a>, <a href="https://blog.frost.kiwi#gaussian-blur">our Gaussian Blur</a> and the <a href="https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/">Binominal filtering</a> mentioned in passing previously can all be performed in two separate passes, by two <em><strong>separate</strong></em> 1D Kernels.</p><figure><svg height="10rem" xmlns:xlink="http://www.w3.org/1999/xlink"></svg> <figcaption>Gaussian blur weights formula for, separated</figcaption></figure><p>Not all convolutions are separable. In the context of graphics programming: If you can express the kernel weights as a formula with axes <code>X, Y</code> and factor-out both <code>X</code> and <code>Y</code> into two separate formulas, then you have gained separability of a 2D kernel and can perform the convolution in two passes, massively saving on texture taps.</p><blockquote><p>Some big budget video games have used effects with kernels that are <strong>not</strong> separable, but did it anyway in two passes + 1D Kernel for the performance gain, with the resulting artifacts being deemed not too bad.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Computerphile covered the concept of separability in the context of 2D image processing really well, if you are interested in a more formal explanation.</p><figure><iframe src="https://www.youtube-nocookie.com/embed/SiJpkucGa1o" title="YouTube video player" width="100%"></iframe><figcaption>Separable Filters and a Bauble<br><a href="https://www.youtube.com/watch?v=SiJpkucGa1o">YouTube Video</a> by <a href="https://www.youtube.com/@Computerphile">Computerphile</a></figcaption></figure><p>Here is our Gaussian Blur, but expressed as a separable Version. You can see just Pass 1 and Pass 2 in isolation or see the final result. Same visual quality as our Gaussian Blur, same dials, but massively faster, with no more quadratic scaling of required texture taps.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p><svg><circle></circle><rect height="7" width="2"></rect><rect height="9" width="2"></rect></svg></div><p><label> Pass 1</label> <label> Pass 2</label> <label> Both</label></p><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>7x7</output>&nbsp;px</td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>sigma</code></td></tr><tr><td><code>sigma</code></td><td></td><td>&plusmn;<output>2.00</output>&sigma;</td><td></td></tr></table></div><blockquote><details><summary>Blur Fragment Shader <a href="https://blog.frost.kiwishader/gaussianBlurSeparable.fs">gaussianBlurSeparable.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large Kernel Sizes result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> samplePosMult<span>;</span> <span>/* Multiply to push blur strength past the kernel size */</span> <span>uniform</span> <span>float</span> sigma<span>;</span> <span>uniform</span> <span>vec2</span> direction<span>;</span> <span>/* Direction vector: (1,0) for horizontal, (0,1) for vertical */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>/* `KERNEL_SIZE` added during compilation */</span> <span>const</span> <span>int</span> kernel_size <span>=</span> KERNEL_SIZE<span>;</span> <span>float</span> <span>gaussianWeight</span><span>(</span><span>float</span> x<span>,</span> <span>float</span> sigma<span>)</span> <span>{</span> <span>/* x&sup2; / 2 &sigma;&sup2; */</span> <span>return</span> <span>exp</span><span>(</span><span>-</span><span>(</span>x <span>*</span> x<span>)</span> <span>/</span> <span>(</span><span>2.0</span> <span>*</span> sigma <span>*</span> sigma<span>)</span><span>)</span><span>;</span> <span>}</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Variable to hold our final color for the current pixel */</span> <span>vec4</span> sum <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> <span>/* Sum of all weights */</span> <span>float</span> weightSum <span>=</span> <span>0.0</span><span>;</span> <span>/* How big one side of the sampled line is */</span> <span>const</span> <span>int</span> size <span>=</span> <span>2</span> <span>*</span> kernel_size <span>+</span> <span>1</span><span>;</span> <span>/* Sample along the direction vector (horizontal or vertical) */</span> <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>-</span>kernel_size<span>;</span> i <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>i<span>)</span> <span>{</span> <span>/* Calculate the required weight for this 1D sample */</span> <span>float</span> w <span>=</span> <span>gaussianWeight</span><span>(</span><span>float</span><span>(</span>i<span>)</span><span>,</span> sigma<span>)</span><span>;</span> <span>/* Offset from the current pixel along the specified direction */</span> <span>vec2</span> offset <span>=</span> <span>vec2</span><span>(</span>i<span>)</span> <span>*</span> direction <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Read and sum up the contribution of that pixel, weighted */</span> sum <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> offset<span>)</span> <span>*</span> w<span>;</span> weightSum <span>+=</span> w<span>;</span> <span>}</span> <span>/* Return the sum, divided by the total weight (normalization) */</span> gl_FragColor <span>=</span> <span>(</span>sum <span>/</span> weightSum<span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/gaussianSeparableBlur.js">gaussianSeparableBlur.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupGaussianSeparableBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianSeparableBlur'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>passMode</span><span>:</span> <span>"pass1"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameIntermediate</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>intermediate</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>sigma</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span><span>,</span> <span>direction</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>kernelSize</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sizeRange'</span><span>)</span><span>,</span> <span>sigma</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sigmaRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[name="modeGaussSep"]'</span><span>)</span><span>,</span> <span>passModes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[name="passMode"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianSeparableBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>passMode</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianSeparableBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#passMode'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianSeparableBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianSeparableBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> gaussianBlurFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/gaussianBlurSeparable.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Pass Mode */</span> ui<span>.</span>rendering<span>.</span>passModes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to pass1 to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"pass1"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>passMode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/gaussianSeparableBlurBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>blurShaderSrc</span><span>:</span> gaussianBlurFrag<span>,</span> <span>kernelSize</span><span>:</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>,</span> <span>sigma</span><span>:</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>passMode</span><span>:</span> ctx<span>.</span>passMode <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> ui<span>.</span>benchmark<span>.</span>passMode<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>passMode<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Helper for recompilation */</span> <span>function</span> <span>reCompileBlurShader</span><span>(</span><span>blurSize</span><span>)</span> <span>{</span> ctx<span>.</span>shd<span>.</span>blur <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> gaussianBlurFrag<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"samplePosMult"</span><span>,</span> <span>"bloomStrength"</span><span>,</span> <span>"sigma"</span><span>,</span> <span>"direction"</span><span>]</span><span>,</span> <span>"#define KERNEL_SIZE "</span> <span>+</span> blurSize <span>+</span> <span>'\n'</span><span>)</span><span>;</span> <span>}</span> <span>/* Blur Shader */</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>intermediate<span>,</span> ctx<span>.</span>tex<span>.</span>frameIntermediate<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>// Clear intermediate texture to prevent lazy initialization warnings</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>intermediate<span>)</span><span>;</span> gl<span>.</span><span>clearColor</span><span>(</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> KernelSizeSide <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span> <span>/* Separable blur: pass1/pass2 = 1 pass, combined = 2 passes */</span> <span>const</span> samplesPerPixel <span>=</span> ctx<span>.</span>passMode <span>==</span> <span>"combined"</span> <span>?</span> KernelSizeSide <span>*</span> <span>2</span> <span>:</span> KernelSizeSide<span>;</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>canvas<span>.</span>width <span>*</span> canvas<span>.</span>height <span>*</span> samplesPerPixel <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Separable Gaussian blur implementation */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>handle<span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>passMode <span>==</span> <span>"pass1"</span><span>)</span> <span>{</span> <span>/* Pass 1 only: Horizontal blur directly to screen */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span> <span>// Horizontal direction</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>if</span> <span>(</span>ctx<span>.</span>passMode <span>==</span> <span>"pass2"</span><span>)</span> <span>{</span> <span>/* Pass 2 only: Vertical blur directly to screen */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> <span>// Vertical direction</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Combined: Two-pass separable blur */</span> <span>/* Pass 1: Horizontal blur to intermediate buffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>intermediate<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span> <span>// Horizontal direction</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Pass 2: Vertical blur to final destination */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> <span>// Vertical direction</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameIntermediate<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameIntermediate<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameIntermediate <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>If you benchmark the performance, you will see a massive performance uplift, as compared to our Gaussian Blur! But there <em>is</em> a trade-off made, that&rsquo;s not quite obvious. In order to have two passes, we are writing out a new framebuffer. Remember the &ldquo;modern chips are fast but memory access in relation is not&rdquo; thing?</p><p>With a modern High-res 4k screen video game, multi-pass anything implies writing out 8.2 Million Pixels to memory, just to read them back in. With smaller kernels on high-res displays, a separable kernel may not always be faster. But with bigger kernels, it almost always is. With a massive speed-up gained, how much faster can we go?</p><h2>The magic of frequency space <a href="https://blog.frost.kiwi#the-magic-of-frequency-space">#</a></h2><p>&hellip;how about blurs that happen so fast, that they are considered free! We are doing a bit of a detour into <em><strong>Frequency Space</strong></em> image manipulation.</p><p>Any 2D image can be converted and edited in frequency space, which unlocks a whole new sort of image manipulation. To blur an image in this paradigm, we perform an <a href="https://usage.imagemagick.org/fourier/#introduction">image Fast Fourier Transform</a>, then <a href="https://usage.imagemagick.org/fourier/#blurring">mask high frequency areas to perform the blur</a> and finally do the inverse transformation.</p><p>A Fourier Transform decomposes a signal into its underlying Sine Frequencies. The output of an <em>image Fast Fourier Transform</em> are &ldquo;Magnitude&rdquo; and &ldquo;Phase&rdquo; component images. These images can be combined back together with the inverse image FFT to produce the original image again&hellip;</p><figure><img src="https://blog.frost.kiwiimg/256ScreenOverlay.png" alt="FFT Viz Input image"><figcaption>Input image for the following interactive FFT example<br>The green stripes are not an error, they are baked into the image on purpose.</figcaption></figure><p>&hellip;but before doing so, we can manipulate the frequency representation of the image in various ways. <a href="https://www.youtube.com/watch?v=qHvdLwSZmF8">Less reading, more interaction!</a> In the following interactive visualization you have the magnitude image, brightness boosted into a human visible representation on the left and the reconstructed image on the right.</p><p>For now, play around with removing energy. You can paint on the magnitude image with your fingers or with the mouse. The output image will be reconstructed accordingly. Also, play around with the circular mask and the feathering sliders. Try to build intuition for what&rsquo;s happening.</p><div><div><p><label><p>Upload <span>Image</span></p></label></p><p><label> Remove<span>Frequency Energy</span></label> <label> Add<span>Frequency Energy</span></label></p><p><label> Reset<span>Magnitude</span></label></p></div><table><tr><td><code>frequencyCutRadius</code></td></tr><tr><td><code>frequencyCutRadius</code></td><td></td><td><output>off</output></td><td></td></tr><tr><td><code>feather</code></td></tr><tr><td><code>feather</code></td><td></td><td><output>0</output></td><td></td></tr></table></div><p>The magnitude image represents the frequency make-up of the image, with the lowest frequencies in the middle and higher at the edges. Horizontal frequencies (vertical features in the image) follow the X Axis and vertical frequencies (Horizontal features in the image) follow the Y Axis, with in-betweens being the diagonals.</p><p>Repeating patterns in the image lighten up as bright-points in the magnitude representation. Or rather, their frequencies have high energy: E.g. the green grid I added. Removing it in photoshop wouldn&rsquo;t be easy! But in frequency space it <em><strong>is</strong></em> easy! Just paint over the blueish 3 diagonal streaks.</p><blockquote><p>Removing repeating features by finger-painting black over frequencies still blows me away.</p><img src="https://blog.frost.kiwi/assets/kiwis/surprised.svg"></blockquote><p>As you may have noticed, the Magnitude representation holds mirrored information. This is due to the FFT being a complex number analysis and our image having only &ldquo;real&rdquo; component pixels, leaving redundant information. The underlying number theory was covered in great detail by 3Blue1Brown:</p><figure><iframe src="https://www.youtube-nocookie.com/embed/spUNpyF58BY" title="YouTube video player" width="100%"></iframe><figcaption>But what is the Fourier Transform? A visual introduction.<br><a href="https://www.youtube.com/watch?v=spUNpyF58BY">YouTube Video</a> by <a href="https://www.youtube.com/@3blue1brown">3Blue1Brown</a></figcaption></figure><p>The underlying code this time is not written by me, but is from <a href="https://github.com/turbomaze/">@turbomaze</a>&rsquo;s repo <a href="https://github.com/turbomaze/JS-Fourier-Image-Analysis">JS-Fourier-Image-Analysis</a>. There is no standard on how you are supposed to plot the magnitude information and how the quadrants are layed out. I changed the implementation by <a href="https://github.com/turbomaze/">@turbomaze</a> to follow the <a href="https://usage.imagemagick.org/fourier/#introduction">convention used by ImageMagick</a>.</p><p>We can blur the image by painting the frequency energy black in a radius around the center, thus eliminating higher frequencies and blurring the image. If we do so with a pixel perfect circle, then we get ringing artifacts - The <a href="https://en.wikipedia.org/wiki/Gibbs_phenomenon">Gibbs phenomenon</a>. By feathering the circle, we lessen this ringing and the blur cleans up.</p><blockquote><p>Drawing a circle like this? That's essentially free on the GPU! We get the equivalent of get super big kernels for free!</p><img src="https://blog.frost.kiwi/assets/kiwis/party.svg"></blockquote><p>But not everything is gold that glitters. First of all, performance. Yes, the &ldquo;blur&rdquo; in frequency space is essentially free, but the trip to frequency space, is everything but. The main issue comes down to <a href="https://en.wikipedia.org/wiki/Butterfly_diagram">FFT transformations</a> performing writes to exponentially many pixels per input pixel, a performance killer.</p><blockquote><p><strong>And</strong> then there's still the inverse conversion!</p><img src="https://blog.frost.kiwi/assets/kiwis/facepalm.svg"></blockquote><p>But our shaders work the other way around, expressing the &ldquo;instructions to construct an output pixel&rdquo;. There <em>are</em> <a href="https://github.com/rreusser/glsl-fft">fragment shader based GPU implementations</a>, but they rely on many passes for calculation, a lot of memory access back and forth. Furthermore, non-power of two images <a href="https://rocm.docs.amd.com/projects/rocFFT/en/latest/design/bluestein.html">require a slower algorithm</a>.</p><p>This article is in the realm of fragment shaders and the graphics pipeline a GPU is part of, but there are also <a href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">GPGPU</a> and <a href="https://github.com/bane9/OpenGLFFT">compute shader implementations</a> with no fragment shader specific limitations. Unfortunately the situation remains: Conversion of high-res images to frequency space is too costly in the context of realtime graphics.</p><blockquote><p>Deleting the frequencies of that grid is magical, but leaves artifacts. In reality it's worse, as my example is idealized. Click <strong>Upload Image</strong>, take a photo of a repeating pattern and see how cleanly you can get rid of it.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Then there are the artifacts I have glossed over. The FFT transformation considers the image as an infinite 2D signal. By blurring, we are bleeding through color from the neighbor copies. And that&rsquo;s not to mention various ringing artifacts that happen. <em><strong>None</strong></em> of this is unsolvable! But there a more underlying issue&hellip;</p><h3>What is a Low-Pass filter? <a href="https://blog.frost.kiwi#what-is-a-low-pass-filter%3F">#</a></h3><blockquote><p>It's a filter that removes high frequencies and leaves the low ones, easy!</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"></blockquote><p>Try the FFT Example again and decrease the <code>frequencyCutRadius</code> to blur. At some point the green lines disappear, right? It <em><strong>is</strong></em> a low pass filter, one where high frequencies are literally annihilated. Small bright lights in the distance? Also annihilated&hellip;</p><div><div><p><label><p>Upload <span>Image</span></p><svg><path></path></svg></label></p><p><label> Remove<span>Frequency Energy</span></label> <label> Add<span>Frequency Energy</span></label></p><p><label> Reset<span>Magnitude</span></label></p></div><table><tr><td><code>frequencyCutRadius</code></td></tr><tr><td><code>frequencyCutRadius</code></td><td></td><td><output>off</output></td><td></td></tr><tr><td><code>feather</code></td></tr><tr><td><code>feather</code></td><td></td><td><output>0</output></td><td></td></tr></table></div><p>If we were to use this to build an effect like bloom, it would remove small lights that are meant to bloom as well! Our gaussian blur on the other hand, <a href="https://en.wikipedia.org/wiki/Gaussian_blur#Low-pass_filter">also a low-pass filter</a>, samples and weights <em><strong>every</strong></em> pixel. In a way it &ldquo;<em>takes the high frequency energy and spreads it into low frequency energy</em>&rdquo;.</p><p>So Low Pass Filter &ne; Low Pass Filter, it depends on context as to what is meant by that word and the reason the article didn&rsquo;t use it until now. Frequency Space energy attenuations are simply not the correct tool for our goal of a &ldquo;basic graphics programming building block&rdquo; for visual effects.</p><blockquote><p>This is a <strong>deep misunderstanding</strong> I held for year, as in why <strong>didn't</strong> video games such a powerful tool?<output></output></p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"></blockquote><p>There are other frequency space image representations, not just FFT Magnitude + Phase. Another famous one is <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">Discrete cosine transform</a>. Again, computerphile covered it in great detail in a video. As for realtime hires images, no. DCT conversion is multiple magnitudes slower. Feel free to dive deeper into frequency space&hellip;</p><figure><iframe src="https://www.youtube-nocookie.com/embed/Q2aEzeMDHMA" title="YouTube video player" width="100%"></iframe><figcaption>JPEG DCT, Discrete Cosine Transform (JPEG Pt2)<br><a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA">YouTube Video</a> by <a href="https://www.youtube.com/@Computerphile">Computerphile</a></figcaption></figure><p>&hellip;as for this article, it&rsquo;s the end of our frequency space detour. We talked so much about what&rsquo;s slow on the GPU. Let&rsquo;s talk about something that&rsquo;s not just fast, but free:</p><h2>Bilinear Interpolation <a href="https://blog.frost.kiwi#bilinear-interpolation">#</a></h2><p>Reading from textures comes with a freebie. When reading between pixels, the closet four pixel are interpolated <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">bilinearly</a> to create the final read, unless you switch to <a href="https://learnopengl.com/Getting-started/Textures#:~:text=Texture%20Filtering">Nearest Neightbor mode</a>. Below you can drag the color sample with finger touch or the mouse. Take note of how and when the color changes in the respective modes.</p><div><div><p><label> Nearest Neighbor</label> <label> Bilinear</label></p><p><label> Animate</label></p></div></div><p>Since reading between pixels gets a linear mix of pixel neighbors, we can <a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">linearly interpolate part of our gaussian kernel</a>, sometimes called a <a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">Linear Gaussian</a>. By tweaking gaussian weights and reducing the amount of samples we could do a 7 &times; 7 gaussian kernel worth of information with only a 4 &times; 4 kernel, as shown in the <a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">linked article</a>.</p><blockquote><p>Though mathematically not the same, visually the result is very close. There are a lot of hand-crafted variations on this, different mixes of kernel sizes and interpolation amounts.</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"></blockquote><p>Bilinear interpolation allows us to resize an image by reading from it at lower resolution. In a way, it&rsquo;s a free bilinear resize built into every graphics chip, zero performance impact. But there <em>is</em> a limit - the bilinear interpolation is limited to a 2 &times; 2 sample square. Try to resize the kiwi below in different modes.</p><blockquote><p>To make this more obvious, the following canvas renders at 25% of <a href="https://en.wikipedia.org/wiki/1:1_pixel_mapping">native resolution</a>.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><div><div><p><label> Nearest Neighbor</label> <label> Bilinear</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p><svg><circle></circle><rect height="7" width="2"></rect><rect height="9" width="2"></rect></svg></div></div><blockquote><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwishader/circleAnimationSize.vs">circleAnimationSize.vs</a></summary><pre><code><span>/* Our Vertex data for the Quad */</span> <span>attribute</span> <span>vec2</span> vtx<span>;</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>/* Position offset for the animation */</span> <span>uniform</span> <span>vec2</span> offset<span>;</span> <span>uniform</span> <span>float</span> kiwiSize<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Make the texture Coordinates read in the fragment shader coordinates */</span> uv <span>=</span> vtx <span>*</span> <span>vec2</span><span>(</span><span>0.5</span><span>,</span> <span>-</span><span>0.5</span><span>)</span> <span>+</span> <span>0.5</span><span>;</span> <span>/* Animate Quad in a circle */</span> gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx <span>*</span> kiwiSize <span>+</span> offset<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwishader/simpleTexture.fs">simpleTexture.fs</a></summary><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> gl_FragColor <span>=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span><span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/bilinear.js">bilinear.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'./utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupBilinear</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-Bilinear'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Resolution divider for framebuffer rendering */</span> <span>const</span> resDiv <span>=</span> <span>4</span><span>;</span> <span>// Hardcoded quarter resolution</span> <span>let</span> renderFramebuffer<span>,</span> renderTexture<span>;</span> <span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>true</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>mode</span><span>:</span> <span>"nearest"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>kiwi</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>kiwiSize</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>blit</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>texture</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>kiwiSize</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#kiwiSize'</span><span>)</span><span>,</span> <span>}</span> <span>}</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to nearest to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"nearest"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimationSize <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimationSize.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>rendering<span>.</span>kiwiSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>kiwi <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimationSize<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"kiwiSize"</span><span>]</span><span>)</span><span>;</span> <span>/* Blit Shader for upscaling */</span> ctx<span>.</span>shd<span>.</span>blit <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"texture"</span><span>]</span><span>)</span><span>;</span> <span>/* Set initial shader state */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>kiwi<span>.</span>handle<span>)</span><span>;</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>/* THis genius workaround is based on @Kaiido's: https://stackoverflow.com/a/69385604/6240779 */</span> <span>function</span> <span>loadSVGAsImage</span><span>(</span><span>blob</span><span>)</span> <span>{</span> <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>const</span> img <span>=</span> <span>new</span> <span>Image</span><span>(</span><span>)</span><span>;</span> <span>const</span> url <span>=</span> <span>URL</span><span>.</span><span>createObjectURL</span><span>(</span>blob<span>)</span><span>;</span> img<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>URL</span><span>.</span><span>revokeObjectURL</span><span>(</span>url<span>)</span><span>;</span> <span>resolve</span><span>(</span>img<span>)</span><span>;</span> <span>}</span><span>;</span> img<span>.</span>src <span>=</span> url<span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> <span>/* Create framebuffer for quarter resolution rendering */</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>renderFramebuffer<span>)</span><span>;</span> renderFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> renderFramebuffer<span>)</span><span>;</span> <span>/* Create RGBA framebuffer texture manually to preserve alpha */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>renderTexture<span>)</span><span>;</span> renderTexture <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> renderTexture<span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span> gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>,</span> gl<span>.</span><span>RGBA</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> <span>,</span> gl<span>.</span><span>RGBA</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> renderTexture<span>,</span> <span>)</span><span>;</span> buffersInitialized <span>=</span> <span>true</span><span>;</span> <span>/* Load kiwi texture */</span> <span>let</span> base <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>"img/kiwi4by3.svg"</span><span>)</span><span>;</span> <span>let</span> baseBlob <span>=</span> <span>await</span> base<span>.</span><span>blob</span><span>(</span><span>)</span><span>;</span> <span>let</span> baseImage <span>=</span> <span>await</span> <span>loadSVGAsImage</span><span>(</span>baseBlob<span>)</span><span>;</span> <span>let</span> baseBitmap <span>=</span> <span>await</span> <span>createImageBitmap</span><span>(</span>baseImage<span>,</span> <span>{</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>NEAREST</span><span>,</span> baseBitmap<span>,</span> <span>4</span><span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* Pass 1: Render to framebuffer at reduced resolution */</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>renderFramebuffer<span>)</span> <span>return</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> renderFramebuffer<span>)</span><span>;</span> gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span> <span>/* Use kiwi shader */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>kiwi<span>.</span>handle<span>)</span><span>;</span> <span>/* Bind kiwi texture and set filtering mode */</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> ctx<span>.</span>mode <span>==</span> <span>"nearest"</span> <span>?</span> gl<span>.</span><span>NEAREST</span> <span>:</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span> gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> ctx<span>.</span>mode <span>==</span> <span>"nearest"</span> <span>?</span> gl<span>.</span><span>NEAREST</span> <span>:</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>kiwi<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kiwi<span>.</span>uniforms<span>.</span>kiwiSize<span>,</span> ui<span>.</span>rendering<span>.</span>kiwiSize<span>.</span>value<span>)</span><span>;</span> <span>/* Draw kiwi to framebuffer */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> <span>/* Use blit shader */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blit<span>.</span>handle<span>)</span><span>;</span> <span>/* Bind framebuffer texture with nearest neighbor for pixelated upscaling */</span> <span>if</span> <span>(</span><span>!</span>renderTexture<span>)</span> <span>return</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> renderTexture<span>)</span><span>;</span> <span>/* Draw full-screen quad to upscale */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>renderTexture<span>)</span><span>;</span> renderTexture <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>renderFramebuffer<span>)</span><span>;</span> renderFramebuffer <span>=</span> <span>null</span><span>;</span> buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>Nearest Neightbor looks pixelated, if the size is not at 100% size, which is equivalent to 1:1 pixel mapping. At 100% it moves &ldquo;jittery&rdquo;, as it &ldquo;snaps&rdquo; to the nearest neighbor. Bilinear keeps things smooth, but going below 50%, especially below 25%, we get exactly the same kind of aliasing, as we would get from nearest neighbor!</p><blockquote><p>You may have noticed similar aliasing when playing YouTube Videos at a very high manually selected video resolution, but in a small window. Same thing!</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>With 2 &times; 2 samples, we start skipping over color information, if the underlying pixels are smaller than half a pixel in size. Below 50% size, our bilinear interpolation starts to act like nearest neighbor interpolation. So as a result, we can shrink image in steps of 50%, without &ldquo;skipping over information&rdquo; and creating aliasing. Let&rsquo;s use that!</p><h2>Downsampling <a href="https://blog.frost.kiwi#downsampling">#</a></h2><p>One fundamental thing thing you can do in post-processing is to shrink &ldquo;downsample&rdquo; first, perform the processing at a lower resolution and upsample again. With the idea being, that you wouldn&rsquo;t notice the lowered resolution. Below is the <a href="https://blog.frost.kiwi#separable-gaussian-blur">Separable Gaussian Blur</a> again, with a variable downsample / upsample chain.</p><p>Each increase of <code>downSample</code> adds a 50% scale step. Let&rsquo;s visualize the framebuffers in play, as it gets quite complex. Here is an example of a square 1024 px&sup2; image, a <code>downSample</code> of <code>2</code> and our two pass separable Gaussian blur.</p><figure><img src="https://blog.frost.kiwiimg/framebuffer.svg" alt="Downsample and Blur Framebuffers"><figcaption>Framebuffers and their sizes, as used during the downsample + blur chain</figcaption></figure><blockquote><p>One unused optimization is that the blur can read straight from the 512 px&sup2; framebuffer and output the 256 px&sup2; directly, skipping one downsample step.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Below you have the option to skip part of the downsample or part of the upsample chain, if you have <code>downSample</code> set to higher than 1. What may not be quite obvious is why we also upsample in steps. Play around with all the dials and modes, to get a feel for what&rsquo;s happening.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>&#10060; The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p></div><p><label> Normal</label> <label> Skip Down-steps</label> <label> Skip Up-steps</label></p><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>kernelSize</code></td></tr><tr><td><code>kernelSize</code></td><td></td><td><output>7x7</output>&nbsp;px</td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>downSample</code></td></tr><tr><td><code>downSample</code></td><td></td><td><output>0</output></td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>&nbsp;%</td><td></td></tr><tr><td><code>sigma</code></td></tr><tr><td><code>sigma</code></td><td></td><td>&plusmn;<output>2.00</output>&sigma;</td><td></td></tr></table></div><blockquote><details><summary>Blur Fragment Shader <a href="https://blog.frost.kiwishader/gaussianSeparableBlur.fs">gaussianSeparableBlur.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large Kernel Sizes result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> samplePosMult<span>;</span> <span>/* Multiply to push blur strength past the kernel size */</span> <span>uniform</span> <span>float</span> sigma<span>;</span> <span>uniform</span> <span>vec2</span> direction<span>;</span> <span>/* Direction vector: (1,0) for horizontal, (0,1) for vertical */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>/* `KERNEL_SIZE` added during compilation */</span> <span>const</span> <span>int</span> kernel_size <span>=</span> KERNEL_SIZE<span>;</span> <span>float</span> <span>gaussianWeight</span><span>(</span><span>float</span> x<span>,</span> <span>float</span> sigma<span>)</span> <span>{</span> <span>/* x&sup2; / 2 &sigma;&sup2; */</span> <span>return</span> <span>exp</span><span>(</span><span>-</span><span>(</span>x <span>*</span> x<span>)</span> <span>/</span> <span>(</span><span>2.0</span> <span>*</span> sigma <span>*</span> sigma<span>)</span><span>)</span><span>;</span> <span>}</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Variable to hold our final color for the current pixel */</span> <span>vec4</span> sum <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> <span>/* Sum of all weights */</span> <span>float</span> weightSum <span>=</span> <span>0.0</span><span>;</span> <span>/* How big one side of the sampled line is */</span> <span>const</span> <span>int</span> size <span>=</span> <span>2</span> <span>*</span> kernel_size <span>+</span> <span>1</span><span>;</span> <span>/* Sample along the direction vector (horizontal or vertical) */</span> <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>-</span>kernel_size<span>;</span> i <span>&lt;=</span> kernel_size<span>;</span> <span>++</span>i<span>)</span> <span>{</span> <span>/* Calculate the required weight for this 1D sample */</span> <span>float</span> w <span>=</span> <span>gaussianWeight</span><span>(</span><span>float</span><span>(</span>i<span>)</span><span>,</span> sigma<span>)</span><span>;</span> <span>/* Offset from the current pixel along the specified direction */</span> <span>vec2</span> offset <span>=</span> <span>vec2</span><span>(</span>i<span>)</span> <span>*</span> direction <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Read and sum up the contribution of that pixel, weighted */</span> sum <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> offset<span>)</span> <span>*</span> w<span>;</span> weightSum <span>+=</span> w<span>;</span> <span>}</span> <span>/* Return the sum, divided by the total weight (normalization) */</span> gl_FragColor <span>=</span> <span>(</span>sum <span>/</span> weightSum<span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/downsample.js">downsample.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>/* Quick note about the implementation. In here I use one framebuffer for each size step. In actually, this is *not* how it should be done. Graphics pipelines have "Mip Maps" for textures and we actually can use one texture and render each downsample step into each mip-map size. Then we also get a nice blending slider between the size provided by the hardware as well! That is unfortunately not possible in WebGL 1.0 ( ; __ ; ) I went with WebGL 1.0 for maximum compatibility across devices. */</span> <span>export</span> <span>async</span> <span>function</span> <span>setupGaussianDownsampleBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianDownsampleBlur'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>skipMode</span><span>:</span> <span>"normal"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span><span>,</span> <span>down</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>intermediate</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>nativeIntermediate</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span><span>,</span> <span>down</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>intermediate</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>nativeIntermediate</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>passthrough</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>sigma</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>kernelSize</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sizeRange'</span><span>)</span><span>,</span> <span>sigma</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#sigmaRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>downSample</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#downSampleRange'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>skipModes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[name="skipMode"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianDownsampleBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>skipMode</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianDownsampleBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#skipMode'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianDownsampleBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-GaussianDownsampleBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> gaussianBlurFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/gaussianBlurSeparable.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>updateSkipModeControls</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>==</span> <span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Skip skipMode radio buttons */</span> <span>if</span> <span>(</span>radio<span>.</span>name <span>===</span> <span>"skipMode"</span><span>)</span> <span>return</span><span>;</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Skip Mode */</span> ui<span>.</span>rendering<span>.</span>skipModes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to normal to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"normal"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>skipMode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Helper function to update skip mode controls */</span> <span>function</span> <span>updateSkipModeControls</span><span>(</span><span>)</span> <span>{</span> <span>const</span> hasIntermediarySteps <span>=</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>value <span>&gt;</span> <span>1</span><span>;</span> ui<span>.</span>rendering<span>.</span>skipModes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> radio<span>.</span>disabled <span>=</span> <span>!</span>hasIntermediarySteps<span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Reset to normal if disabled */</span> <span>if</span> <span>(</span><span>!</span>hasIntermediarySteps <span>&amp;&amp;</span> ctx<span>.</span>skipMode <span>!==</span> <span>"normal"</span><span>)</span> <span>{</span> ctx<span>.</span>skipMode <span>=</span> <span>"normal"</span><span>;</span> <span>}</span> <span>/* Always sync UI radio buttons with current ctx.skipMode */</span> ui<span>.</span>rendering<span>.</span>skipModes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> radio<span>.</span>checked <span>=</span> <span>(</span>radio<span>.</span>value <span>===</span> ctx<span>.</span>skipMode<span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Initialize skip mode controls */</span> <span>updateSkipModeControls</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/downsampleBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>blurShaderSrc</span><span>:</span> gaussianBlurFrag<span>,</span> <span>kernelSize</span><span>:</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>,</span> <span>sigma</span><span>:</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>downSample</span><span>:</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>value<span>,</span> <span>skipMode</span><span>:</span> ctx<span>.</span>skipMode <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> ui<span>.</span>benchmark<span>.</span>skipMode<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>skipMode<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Simple Passthrough */</span> ctx<span>.</span>shd<span>.</span>passthrough <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> simpleTexture<span>)</span><span>;</span> <span>/* Helper for recompilation */</span> <span>function</span> <span>reCompileBlurShader</span><span>(</span><span>blurSize</span><span>)</span> <span>{</span> ctx<span>.</span>shd<span>.</span>blur <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> gaussianBlurFrag<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"samplePosMult"</span><span>,</span> <span>"bloomStrength"</span><span>,</span> <span>"sigma"</span><span>,</span> <span>"direction"</span><span>]</span><span>,</span> <span>"#define KERNEL_SIZE "</span> <span>+</span> blurSize <span>+</span> <span>'\n'</span><span>)</span><span>;</span> <span>}</span> <span>/* Blur Shader */</span> <span>reCompileBlurShader</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value<span>)</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Add native resolution intermediate buffer for separable blur */</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>nativeIntermediate<span>)</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>nativeIntermediate<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>nativeIntermediate<span>,</span> ctx<span>.</span>tex<span>.</span>nativeIntermediate<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>const</span> maxDown <span>=</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>max<span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>max<span>;</span> <span>++</span>i<span>)</span> <span>{</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>intermediate<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>}</span> ctx<span>.</span>fb<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>tex<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>tex<span>.</span>intermediate <span>=</span> <span>[</span><span>]</span><span>;</span> <span>let</span> w <span>=</span> canvas<span>.</span>width<span>,</span> h <span>=</span> canvas<span>.</span>height<span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> maxDown<span>;</span> <span>++</span>i<span>)</span> <span>{</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> w <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> h <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> <span>const</span> <span>[</span>fb<span>,</span> tex<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> w<span>,</span> h<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>down<span>.</span><span>push</span><span>(</span>fb<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>down<span>.</span><span>push</span><span>(</span>tex<span>)</span><span>;</span> <span>const</span> <span>[</span>intermediateFb<span>,</span> intermediateTex<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> w<span>,</span> h<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate<span>.</span><span>push</span><span>(</span>intermediateFb<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>intermediate<span>.</span><span>push</span><span>(</span>intermediateTex<span>)</span><span>;</span> <span>}</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>/* Perform separable blur: horizontal pass followed by vertical pass */</span> <span>function</span> <span>performSeparableBlur</span><span>(</span><span>srcTexture<span>,</span> targetFB<span>,</span> width<span>,</span> height<span>,</span> intermediateFB<span>,</span> intermediateTex<span>,</span> bloomStrength</span><span>)</span> <span>{</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>handle<span>)</span><span>;</span> <span>/* Set common uniforms */</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> width<span>,</span> <span>1.0</span> <span>/</span> height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>sigma<span>,</span> Math<span>.</span><span>max</span><span>(</span>ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>/</span> ui<span>.</span>blur<span>.</span>sigma<span>.</span>value<span>,</span> <span>0.001</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> bloomStrength<span>)</span><span>;</span> <span>/* Horizontal pass */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> intermediateFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> width<span>,</span> height<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span> <span>// Horizontal</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTexture<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Vertical pass */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> targetFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> width<span>,</span> height<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>blur<span>.</span>uniforms<span>.</span>direction<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> <span>// Vertical</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> intermediateTex<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> KernelSizeSide <span>=</span> ui<span>.</span>blur<span>.</span>kernelSize<span>.</span>value <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span> <span>const</span> effectiveRes <span>=</span> <span>[</span>Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>+</span>ui<span>.</span>blur<span>.</span>downSample<span>.</span>value<span>)</span><span>,</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>+</span>ui<span>.</span>blur<span>.</span>downSample<span>.</span>value<span>)</span><span>]</span><span>;</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>effectiveRes<span>[</span><span>]</span> <span>*</span> effectiveRes<span>[</span><span>1</span><span>]</span> <span>*</span> KernelSizeSide <span>*</span> <span>2</span> <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* down-sample chain */</span> <span>const</span> levels <span>=</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>value<span>;</span> <span>let</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>frame<span>;</span> <span>let</span> w <span>=</span> canvas<span>.</span>width<span>,</span> h <span>=</span> canvas<span>.</span>height<span>;</span> <span>if</span> <span>(</span>levels <span>&gt;</span> <span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>skipMode <span>===</span> <span>"skipDown"</span><span>)</span> <span>{</span> <span>/* Skip downsample steps: jump directly to target level and blur */</span> <span>const</span> lastDownsampleFB <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>const</span> lastIntermediateFB <span>=</span> ctx<span>.</span>fb<span>.</span>intermediate<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>const</span> lastIntermediateTex <span>=</span> ctx<span>.</span>tex<span>.</span>intermediate<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>/* Calculate target resolution directly */</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> levels<span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> levels<span>)</span><span>;</span> <span>const</span> bloomStrength <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> <span>performSeparableBlur</span><span>(</span>srcTex<span>,</span> lastDownsampleFB<span>,</span> w<span>,</span> h<span>,</span> lastIntermediateFB<span>,</span> lastIntermediateTex<span>,</span> bloomStrength<span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Normal mode: Downsample up to the second to last level */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>)</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> levels <span>-</span> <span>1</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span> <span>const</span> fb <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>;</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> w <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> h <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> fb<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> w<span>,</span> h<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>gl<span>.</span><span>getUniformLocation</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>,</span> <span>"texture"</span><span>)</span><span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>;</span> <span>}</span> <span>/* Blur into the last downsample buffer */</span> <span>const</span> lastDownsampleFB <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>const</span> lastIntermediateFB <span>=</span> ctx<span>.</span>fb<span>.</span>intermediate<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>const</span> lastIntermediateTex <span>=</span> ctx<span>.</span>tex<span>.</span>intermediate<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> w <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> h <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> <span>const</span> bloomStrength <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> <span>performSeparableBlur</span><span>(</span>srcTex<span>,</span> lastDownsampleFB<span>,</span> w<span>,</span> h<span>,</span> lastIntermediateFB<span>,</span> lastIntermediateTex<span>,</span> bloomStrength<span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>levels <span>-</span> <span>1</span><span>]</span><span>;</span> <span>}</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Run Gaussian blur at native resolution when no downsample */</span> <span>const</span> bloomStrength <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> <span>performSeparableBlur</span><span>(</span>srcTex<span>,</span> ctx<span>.</span>fb<span>.</span>final<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>,</span> ctx<span>.</span>fb<span>.</span>nativeIntermediate<span>,</span> ctx<span>.</span>tex<span>.</span>nativeIntermediate<span>,</span> bloomStrength<span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>;</span> <span>}</span> <span>/* Upsample chain */</span> <span>if</span> <span>(</span>levels <span>&gt;</span> <span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>skipMode <span>===</span> <span>"skipUp"</span><span>)</span> <span>{</span> <span>/* Skip upsample steps: srcTex stays at the lowest resolution */</span> <span>/* Final pass will handle upscaling to full resolution */</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Normal mode: Upsample through the mip levels */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>)</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> levels <span>-</span> <span>2</span><span>;</span> i <span>&gt;=</span> <span>;</span> i<span>--</span><span>)</span> <span>{</span> <span>const</span> fb <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>;</span> <span>let</span> upsampleW <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> <span>let</span> upsampleH <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> fb<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> upsampleW<span>,</span> upsampleH<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>gl<span>.</span><span>getUniformLocation</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>,</span> <span>"texture"</span><span>)</span><span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>;</span> <span>}</span> <span>}</span> <span>}</span> <span>/* Final pass to present to screen (with upscaling if needed) */</span> <span>/* Skip final pass in bloom mode with no downsampling to avoid feedback loop */</span> <span>if</span> <span>(</span><span>!</span><span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>&amp;&amp;</span> levels <span>==</span> <span>)</span><span>)</span> <span>{</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>gl<span>.</span><span>getUniformLocation</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>,</span> <span>"texture"</span><span>)</span><span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>nativeIntermediate<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>nativeIntermediate <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>nativeIntermediate<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>nativeIntermediate <span>=</span> <span>null</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> ui<span>.</span>blur<span>.</span>downSample<span>.</span>max<span>;</span> <span>++</span>i<span>)</span> <span>{</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>intermediate<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>}</span> ctx<span>.</span>tex<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>fb<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>tex<span>.</span>intermediate <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>With each downsample step, our kernel covers more and more area, thus increasing the blur radius. Performance is again, a massive lift up, as we quadratically get less and less pixels to blur with each step. We get bigger blurs with the same <code>kernelSize</code> and with stronger blurs in <code>Scene</code> mode, the resolution drop is not visible.</p><p>With smaller blurs you will get &ldquo;shimmering&rdquo;, as aliasing artifacts begin, even with our bilinear filtering in place. Small blurs and lower resolution don&rsquo;t mix. This is <em><strong>especially</strong></em> painful in bloom mode with strong <code>lightBrightness</code>, as lights will start to &ldquo;turn on and off&rdquo; as they are not resolved correctly at lower resolutions.</p><blockquote><p>There must be some kind of sweet spot of low resolution and blur strong enough to hide the the low resolution.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"></blockquote><p>Skipping Downsample steps will bring obviously horrible aliasing. As for upsampling, there is a deep misunderstanding I held for years, until I read the SIGGRAPH 2014 presentation <a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Next Generation Post Processing in Call of Duty: Advanced Warfare</a> by graphics magician <a href="https://www.iryoku.com/">Jorge Jimenez</a>. One page stuck out to me:</p><figure><img src="https://blog.frost.kiwiimg/jimenez2014.png" alt="Page 159 from presentation Next Generation Post Processing in Call of Duty: Advanced Warfare by Jorge Jimenez"><figcaption>Page 159 from presentation <a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Next Generation Post Processing in Call of Duty: Advanced Warfare</a> by <a href="https://www.iryoku.com/">Jorge Jimenez</a></figcaption></figure><p>With upsampling, even when going from low res to high res in one jump, we aren&rsquo;t &ldquo;skipping&rdquo; any information, right? Nothing is missed. But if you look closely at the above demo with larger <code>downSample</code> chains with <code>Skip Upsample Steps</code> mode, then you will see a vague grid like artifact appearing, especially with strong blurs. <a href="https://blog.frost.kiwi#addendum">This point was expanded in the addendum</a>.</p><figure><figcaption>Visualization of the bilinear interpolation (<a href="https://en.wikipedia.org/wiki/Bicubic_interpolation">Source</a>)</figcaption></figure><p>How to keeps things smooth when upsampling is the field of &ldquo;Reconstruction filters&rdquo;. By skipping intermediate upsampling steps we are performing a 2 &times; 2 sample bilinear reconstruction of very small pixels. As a result we get the bilinear filtering characteristic pyramid shaped hot spots. <em><strong>How</strong></em> we upscale matters.</p><h3>Smooth Blur Animation <a href="https://blog.frost.kiwi#smooth-blur-animation">#</a></h3><p>One fundamental challenge with advanced blur algorithms is that it becomes challenging to get smooth blur sliders and smooth blur strength animations. Eg. with our separable gaussian blur, you could set <code>kernelSize</code> to the maximum required and adjust <code>samplePosMultiplier</code> smoothly between 0% and 100%.</p><p>With downsampling in the picture, this becomes more difficult and solutions to this are very context dependant, so we won&rsquo;t dive into it. One approach you see from time to time is to simply give up on animating blur strength and blend between a blurred and unblurred version of the scene, as shown below. Visually, not very pleasing.</p><h2>Kawase Blur <a href="https://blog.frost.kiwi#kawase-blur">#</a></h2><p>Now we get away from the classical blur approaches. It&rsquo;s the early 2000s and graphics programmer <a href="https://www.siliconstudio.co.jp/middleware/yebis/en/">Masaki Kawase</a>, today senior graphics programmer at Tokyo based company <a href="https://www.siliconstudio.co.jp/">Silicon Studio</a>, is programming the Xbox video game <a href="https://www.youtube.com/watch?v=JjR9VugWoHY">DOUBLE-S.T.E.A.L</a>, a game with vibrant post-processing effects.</p><p>During the creation of those visual effects, <a href="https://www.siliconstudio.co.jp/middleware/yebis/en/">Masaki Kawase</a> used a new blurring technique that he presented in the 2003 Game Developers Conference talk <a href="https://gdcvault.com/browse?keyword=Frame+Buffer+Postprocessing+Effects">Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)</a>. This technique became later referred to as the &ldquo;Kawase Blur&rdquo;. Let&rsquo;s take a look at it:</p><figure><figcaption>Sample placement in what later become known as the "Kawase Blur"<br>Excerpt from GDC presentation <a href="https://web.archive.org/web/20060909063116/http://www.daionet.gr.jp/~masa/archives/GDC2003_DSTEAL.ppt">Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L</a> (2003)</figcaption></figure><p>This technique does not have a <code>kernelSize</code> parameter anymore. It works in passes of 4 equally weighted samples, placed diagonally from the center output pixel, in the middle where the corners of 4 pixels touch. These samples get color contributions equally from their neighbors, due to bilinear filtering.</p><blockquote><p>This is new, there is no center pixel sample and, except for the required normalization, no explicit weights! The weighting happens as a result of bilinear filtering.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"></blockquote><p>After a pass is complete, that pass is used as the input to the next pass, where the outer 4 diagonal samples increase in distance by one pixel length. With each pass, this distance grows. Two framebuffers are required for this, which switch between being input and output between passes. This setup is often called &ldquo;ping-ponging&rdquo;.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>L The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p><svg><circle></circle><rect height="7" width="2"></rect><rect height="9" width="2"></rect></svg></div><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>iterations</code></td></tr><tr><td><code>iterations</code></td><td></td><td><output>3</output></td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>%</td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>%</td><td></td></tr></table></div><blockquote><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwishader/kawase.fs">kawase.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large iterations result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> samplePosMult<span>;</span> <span>/* Multiply to push blur strength past the pixel offset */</span> <span>uniform</span> <span>float</span> pixelOffset<span>;</span> <span>/* Pixel offset for this Kawase iteration */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Kawase blur samples 4 corners in a diamond pattern */</span> <span>vec2</span> o <span>=</span> <span>vec2</span><span>(</span>pixelOffset <span>+</span> <span>0.5</span><span>)</span> <span>*</span> samplePosMult <span>*</span> frameSizeRCP<span>;</span> <span>/* Sample the 4 diagonal corners with equal weight */</span> <span>vec4</span> color <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* top-right */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* top-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* bottom-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* bottom-right */</span> color <span>/=</span> <span>4.0</span><span>;</span> <span>/* Apply bloom strength and output */</span> gl_FragColor <span>=</span> color <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/kawase.js">kawase.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupKawaseBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-KawaseBlur'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameIntermediate1</span><span>:</span> <span>null</span><span>,</span> <span>frameIntermediate2</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>intermediate1</span><span>:</span> <span>null</span><span>,</span> <span>intermediate2</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>kawase</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>samplePosMult</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span><span>,</span> <span>pixelOffset</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterationsRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[name="modeKawase"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-KawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>kawaseIterations</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-KawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#kawaseIterations'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-KawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-KawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> kawaseFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/kawase.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>// Lock/unlock samplePos based on iterations</span> <span>const</span> iterations <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>iterations<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> iterations <span>===</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> iterations <span>===</span> <span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/kawaseBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>kawaseShaderSrc</span><span>:</span> kawaseFrag<span>,</span> <span>kawaseIterations</span><span>:</span> ui<span>.</span>blur<span>.</span>iterations<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> ui<span>.</span>benchmark<span>.</span>kawaseIterations<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>kawaseIterations<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Kawase Blur Shader */</span> ctx<span>.</span>shd<span>.</span>kawase <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> kawaseFrag<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"samplePosMult"</span><span>,</span> <span>"pixelOffset"</span><span>,</span> <span>"bloomStrength"</span><span>]</span><span>)</span><span>;</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate1<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate2<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>intermediate1<span>,</span> ctx<span>.</span>tex<span>.</span>frameIntermediate1<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>intermediate2<span>,</span> ctx<span>.</span>tex<span>.</span>frameIntermediate2<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>// Clear intermediate textures to prevent lazy initialization warnings</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>intermediate1<span>)</span><span>;</span> gl<span>.</span><span>clearColor</span><span>(</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>intermediate2<span>)</span><span>;</span> gl<span>.</span><span>clearColor</span><span>(</span><span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span> gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> iterations <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>iterations<span>.</span>value<span>)</span><span>;</span> <span>/* Kawase blur: 4 samples per iteration, 0 iterations = no blur (1 sample) */</span> <span>const</span> samplesPerPixel <span>=</span> iterations <span>===</span> <span>?</span> <span>1</span> <span>:</span> iterations <span>*</span> <span>4</span><span>;</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>canvas<span>.</span>width <span>*</span> canvas<span>.</span>height <span>*</span> samplesPerPixel <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Handle 0 iterations case - direct copy to output */</span> <span>if</span> <span>(</span>iterations <span>===</span> <span>)</span> <span>{</span> <span>/* Direct copy from scene to final destination using Kawase shader with no offset */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> <span>// null = screen</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Use Kawase shader with pixelOffset=0 and samplePosMult=0 for simple copy */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> <span>0.0</span><span>)</span><span>;</span> <span>// No offset</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>pixelOffset<span>,</span> <span>0.0</span><span>)</span><span>;</span> <span>// No offset</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Kawase Blur implementation - iterative ping-pong between framebuffers */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>samplePosMult<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> <span>/* Apply brightness only on final iteration to match Gaussian behavior */</span> <span>let</span> currentInputTex <span>=</span> ctx<span>.</span>tex<span>.</span>frame<span>;</span> <span>let</span> currentInputFB <span>=</span> ctx<span>.</span>fb<span>.</span>scene<span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> iterations<span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>/* Determine output framebuffer */</span> <span>let</span> outputFB<span>,</span> outputTex<span>;</span> <span>if</span> <span>(</span>i <span>===</span> iterations <span>-</span> <span>1</span><span>)</span> <span>{</span> <span>/* Last iteration - output to final destination */</span> outputFB <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> <span>// null = screen</span> <span>}</span> <span>else</span> <span>{</span> <span>/* Intermediate iterations - ping-pong between buffers */</span> <span>if</span> <span>(</span>i <span>%</span> <span>2</span> <span>===</span> <span>)</span> <span>{</span> outputFB <span>=</span> ctx<span>.</span>fb<span>.</span>intermediate1<span>;</span> outputTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameIntermediate1<span>;</span> <span>}</span> <span>else</span> <span>{</span> outputFB <span>=</span> ctx<span>.</span>fb<span>.</span>intermediate2<span>;</span> outputTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameIntermediate2<span>;</span> <span>}</span> <span>}</span> <span>/* Setup output framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> outputFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Bind input texture */</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> currentInputTex<span>)</span><span>;</span> <span>/* Set pixel offset for this iteration */</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>pixelOffset<span>,</span> i<span>)</span><span>;</span> <span>/* Apply distributed brightness, due to color precision limitations and multi pass nature of this blur algorithm */</span> <span>const</span> finalBrightness <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> <span>const</span> distributedBrightness <span>=</span> Math<span>.</span><span>pow</span><span>(</span>finalBrightness<span>,</span> <span>1.0</span> <span>/</span> iterations<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>kawase<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> distributedBrightness<span>)</span><span>;</span> <span>/* Draw */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>/* Setup for next iteration */</span> <span>if</span> <span>(</span>i <span>&lt;</span> iterations <span>-</span> <span>1</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>i <span>%</span> <span>2</span> <span>===</span> <span>)</span> <span>{</span> currentInputTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameIntermediate1<span>;</span> <span>}</span> <span>else</span> <span>{</span> currentInputTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameIntermediate2<span>;</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameIntermediate1<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameIntermediate1 <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameIntermediate2<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameIntermediate2 <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate1<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate1 <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>intermediate2<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>intermediate2 <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Initialize UI state */</span> <span>const</span> initialIterations <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>iterations<span>.</span>value<span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> initialIterations <span>===</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> initialIterations <span>===</span> <span>;</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>Akin to the <a href="https://en.wikipedia.org/wiki/Central_limit_theorem">Central Limit Theorem</a> making repeated passes of a box-blur approach a gaussian blur, our Kawase blur provides a smooth gaussian-like results, due to the iterative convolution at play. Technically, there are two convolutions happening at the same time - bilinear filtering and the diagonal samples with increasing distance.</p><blockquote><p>Two different origins: The Gaussian blur came from a mathematical concept entering graphics programming. The Kawase blur was born to get the most out of what hardware provides for free.</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"></blockquote><p>It is not a separable convolution, due to its diagonal sampling nature. As no downsampling is used, this means that we write all pixels out to memory, each pass. Even if we could separate, the cost of writing out twice as many passes to memory would outweigh the benefit of going from 4 samples per-pass to 2.</p><blockquote><p>With so few samples, you cannot increase <code>samplePosMultiplier</code> without instantly getting artifacts. We mess up the sample pattern.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"></blockquote><p>Take note of textures taps: They grow linearly, with increasing blur radius. In DOUBLE-S.T.E.A.L, Masaki Kawase used it to create the bloom effect, calculated at a lower resolution. But there is one more evolution coming up - We have blur, we have downsampling. Two separate concepts. What if we &ldquo;fused&rdquo; them?</p><h2>Dual Kawase Blur <a href="https://blog.frost.kiwi#dual-kawase-blur">#</a></h2><p><a href="https://theorg.com/org/arm/org-chart/marius-bjorge">Marius Bj&oslash;rge</a>, principal graphics architect at <a href="https://www.arm.com/">ARM</a> took this thought to its logical conclusion, when he was optimizing mobile graphics rendering with ARM graphics chips. In a SIGGRAPH 2015 <a href="https://dl.acm.org/doi/10.1145/2776880.2787664">talk</a> he presented an algorithm, that would later become knows as the &#10024; Dual Kawase Blur &#127775;, this article&rsquo;s final destination.</p><figure><img src="https://blog.frost.kiwiimg/dualKawasePattern.jpg" alt="Dual Kawase sampling patterns"><figcaption>Dual Kawase sampling patterns<br>Excerpt from <a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Bandwidth-Efficient Rendering</a>, talk by <a href="https://theorg.com/org/arm/org-chart/marius-bjorge">Marius Bj&oslash;rge</a></figcaption></figure><p>This blur works with the idea of Masaki Kawase&rsquo;s &ldquo;placing diagonal samples at increasing distance&rdquo;, but does so in conjunction with downsampling, which effectively performs this &ldquo;increase in distance&rdquo;. There is also a dedicated upsample filter. I&rsquo;ll let Marius Bj&oslash;rge explain this one, an excerpt <a href="https://dl.acm.org/doi/suppl/10.1145/2776880.2787664/suppl_file/a184.mp4">from his talk mentioned above</a></p><blockquote><strong>Marius Bj&oslash;rge</strong>: For lack for a better name, dual filter is something I come up with when playing with different downsampling and upsampling patterns. It's sort of a derivative of the Kawase filter, but instead of ping-ponging between two equally sized textures, this filter works by having the same filter for down sampling and having another filter for upsampling.<p>The downsample filter works by sampling four pixels covering the target pixel, and you also have four pixels on the corner of this pixel to smudge in some information from all the neighboring pixels. So the end upsample filter works by reconstructing information from the downsample pass. So this pattern was chosen to get a nice smooth circular shape.</p></blockquote><p>Let&rsquo;s try it. This time, there are two blur shaders, as there is an upsample and downsample stage. Again, there is no <code>kernelSize</code>. Instead there are <code>downsampleLevels</code>, which performs the blur in conjunction with the down sampling. Play around with all the slider and get a feel for it.</p><div><div><p><label> Scene</label> <label> Lights</label> <label> Bloom</label></p><p><label> Animate</label></p></div><div><canvas></canvas><p>L The browser killed this WebGL Context, please reload the page. If this happened as the result of a long benchmark, decrease the iteration count. On some platforms (iOS / iPad) you may have to restart the browser App completely, as the browser will temporarily refuse to allow this site to run WebGL again.</p></div><table><tr><td><p><span><strong>FPS:</strong><output>?</output>/<output>?</output>ms </span><span><strong>Resolution:</strong><output>?</output>x<output>?</output></span><span><strong>Texture Taps:</strong><output>?</output></span></p></td></tr><tr><td><code>downsampleLevels</code></td></tr><tr><td><code>downsampleLevels</code></td><td></td><td><output>2</output></td><td></td></tr><tr><td><code>samplePosMultiplier</code></td></tr><tr><td><code>samplePosMultiplier</code></td><td></td><td><output>100</output>%</td><td></td></tr><tr><td><code>lightBrightness</code></td></tr><tr><td><code>lightBrightness</code></td><td></td><td><output>100</output>%</td><td></td></tr></table></div><blockquote><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwishader/dual-kawase-down.fs">dual-kawase-down.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large iterations result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> offset<span>;</span> <span>/* Offset multiplier for blur strength */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Dual Kawase downsample: sample center + 4 diagonal corners */</span> <span>vec2</span> halfpixel <span>=</span> frameSizeRCP <span>*</span> <span>0.5</span><span>;</span> <span>vec2</span> o <span>=</span> halfpixel <span>*</span> offset<span>;</span> <span>/* Sample center with 4x weight */</span> <span>vec4</span> color <span>=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span> <span>*</span> <span>4.0</span><span>;</span> <span>/* Sample 4 diagonal corners with 1x weight each */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* bottom-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* bottom-right */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* top-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span><span>;</span> <span>/* top-right */</span> <span>/* Apply bloom strength and normalize by total weight (8) */</span> gl_FragColor <span>=</span> <span>(</span>color <span>/</span> <span>8.0</span><span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwishader/dual-kawase-up.fs">dual-kawase-up.fs</a></summary><pre><code><span>/* Float precision to highp, if supported. Large iterations result many color contributions and thus require the highest precision to avoid clipping. Required in WebGL 1 Shaders and depending on platform may have no effect */</span> <span>precision</span> <span>highp</span> <span>float</span><span>;</span> <span>/* UV coordinates, passed in from the Vertex Shader */</span> <span>varying</span> <span>vec2</span> uv<span>;</span> <span>uniform</span> <span>vec2</span> frameSizeRCP<span>;</span> <span>/* Resolution Reciprocal */</span> <span>uniform</span> <span>float</span> offset<span>;</span> <span>/* Offset multiplier for blur strength */</span> <span>uniform</span> <span>float</span> bloomStrength<span>;</span> <span>/* bloom strength */</span> <span>uniform</span> <span>sampler2D</span> texture<span>;</span> <span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span> <span>/* Dual Kawase upsample: sample 4 edge centers + 4 diagonal corners */</span> <span>vec2</span> halfpixel <span>=</span> frameSizeRCP <span>*</span> <span>0.5</span><span>;</span> <span>vec2</span> o <span>=</span> halfpixel <span>*</span> offset<span>;</span> <span>vec4</span> color <span>=</span> <span>vec4</span><span>(</span><span>0.0</span><span>)</span><span>;</span> <span>/* Sample 4 edge centers with 1x weight each */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x <span>*</span> <span>2.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>;</span> <span>/* left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x <span>*</span> <span>2.0</span><span>,</span> <span>0.0</span><span>)</span><span>)</span><span>;</span> <span>/* right */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>0.0</span><span>,</span> <span>-</span>o<span>.</span>y <span>*</span> <span>2.0</span><span>)</span><span>)</span><span>;</span> <span>/* bottom */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>0.0</span><span>,</span> o<span>.</span>y <span>*</span> <span>2.0</span><span>)</span><span>)</span><span>;</span> <span>/* top */</span> <span>/* Sample 4 diagonal corners with 2x weight each */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span> <span>*</span> <span>2.0</span><span>;</span> <span>/* top-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> o<span>.</span>y<span>)</span><span>)</span> <span>*</span> <span>2.0</span><span>;</span> <span>/* top-right */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span><span>-</span>o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span> <span>*</span> <span>2.0</span><span>;</span> <span>/* bottom-left */</span> color <span>+=</span> <span>texture2D</span><span>(</span>texture<span>,</span> uv <span>+</span> <span>vec2</span><span>(</span> o<span>.</span>x<span>,</span> <span>-</span>o<span>.</span>y<span>)</span><span>)</span> <span>*</span> <span>2.0</span><span>;</span> <span>/* bottom-right */</span> <span>/* Apply bloom strength and normalize by total weight (12) */</span> gl_FragColor <span>=</span> <span>(</span>color <span>/</span> <span>12.0</span><span>)</span> <span>*</span> bloomStrength<span>;</span> <span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwijs/blur/dual-kawase.js">dual-kawase.js</a></summary><pre><code><span>import</span> <span>*</span> <span>as</span> util <span>from</span> <span>'../utility.js'</span> <span>export</span> <span>async</span> <span>function</span> <span>setupDualKawaseBlur</span><span>(</span><span>)</span> <span>{</span> <span>/* Init */</span> <span>const</span> WebGLBox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-DualKawaseBlur'</span><span>)</span><span>;</span> <span>const</span> canvas <span>=</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'canvas'</span><span>)</span><span>;</span> <span>/* Circle Rotation size */</span> <span>const</span> radius <span>=</span> <span>0.12</span><span>;</span> <span>/* Main WebGL 1.0 Context */</span> <span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>'webgl'</span><span>,</span> <span>{</span> <span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span> <span>antialias</span><span>:</span> <span>false</span><span>,</span> <span>alpha</span><span>:</span> <span>false</span><span>,</span> <span>}</span><span>)</span><span>;</span> <span>/* State and Objects */</span> <span>const</span> ctx <span>=</span> <span>{</span> <span>/* State for of the Rendering */</span> <span>mode</span><span>:</span> <span>"scene"</span><span>,</span> <span>flags</span><span>:</span> <span>{</span> <span>isRendering</span><span>:</span> <span>false</span><span>,</span> <span>buffersInitialized</span><span>:</span> <span>false</span><span>,</span> <span>initComplete</span><span>:</span> <span>false</span><span>,</span> <span>benchMode</span><span>:</span> <span>false</span> <span>}</span><span>,</span> <span>/* Textures */</span> <span>tex</span><span>:</span> <span>{</span> <span>sdr</span><span>:</span> <span>null</span><span>,</span> <span>selfIllum</span><span>:</span> <span>null</span><span>,</span> <span>frame</span><span>:</span> <span>null</span><span>,</span> <span>frameFinal</span><span>:</span> <span>null</span><span>,</span> <span>down</span><span>:</span> <span>[</span><span>]</span> <span>}</span><span>,</span> <span>/* Framebuffers */</span> <span>fb</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>null</span><span>,</span> <span>final</span><span>:</span> <span>null</span><span>,</span> <span>down</span><span>:</span> <span>[</span><span>]</span> <span>}</span><span>,</span> <span>/* Shaders and their respective Resource Locations */</span> <span>shd</span><span>:</span> <span>{</span> <span>scene</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>passthrough</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span> <span>}</span><span>,</span> <span>downsample</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>upsample</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>frameSizeRCP</span><span>:</span> <span>null</span><span>,</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>bloomStrength</span><span>:</span> <span>null</span> <span>}</span> <span>}</span><span>,</span> <span>bloom</span><span>:</span> <span>{</span> <span>handle</span><span>:</span> <span>null</span><span>,</span> <span>uniforms</span><span>:</span> <span>{</span> <span>offset</span><span>:</span> <span>null</span><span>,</span> <span>radius</span><span>:</span> <span>null</span><span>,</span> <span>texture</span><span>:</span> <span>null</span><span>,</span> <span>textureAdd</span><span>:</span> <span>null</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>;</span> <span>/* UI Elements */</span> <span>const</span> ui <span>=</span> <span>{</span> <span>display</span><span>:</span> <span>{</span> <span>spinner</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'svg'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>contextLoss</span><span>:</span> canvas<span>.</span>parentElement<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>,</span> canvas<span>.</span>parentElement<span>)</span><span>,</span> <span>fps</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#fps'</span><span>)</span><span>,</span> <span>ms</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#ms'</span><span>)</span><span>,</span> <span>width</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#width'</span><span>)</span><span>,</span> <span>height</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#height'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#taps'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>blur</span><span>:</span> <span>{</span> <span>downsample</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#downsampleRange'</span><span>)</span><span>,</span> <span>samplePos</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRange'</span><span>)</span><span>,</span> <span>samplePosReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#samplePosRangeReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>rendering</span><span>:</span> <span>{</span> <span>animate</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#animateCheck'</span><span>)</span><span>,</span> <span>modes</span><span>:</span> WebGLBox<span>.</span><span>querySelectorAll</span><span>(</span><span>'input[type="radio"]'</span><span>)</span><span>,</span> <span>lightBrightness</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightness'</span><span>)</span><span>,</span> <span>lightBrightnessReset</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#lightBrightnessReset'</span><span>)</span><span>,</span> <span>}</span><span>,</span> <span>benchmark</span><span>:</span> <span>{</span> <span>button</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmark'</span><span>)</span><span>,</span> <span>label</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#benchmarkLabel'</span><span>)</span><span>,</span> <span>iterOut</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterOut'</span><span>)</span><span>,</span> <span>renderer</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-DualKawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#renderer'</span><span>)</span><span>,</span> <span>downsampleLevels</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-DualKawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#downsampleLevels'</span><span>)</span><span>,</span> <span>iterTime</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-DualKawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#iterTime'</span><span>)</span><span>,</span> <span>tapsCount</span><span>:</span> document<span>.</span><span>getElementById</span><span>(</span><span>'WebGLBox-DualKawaseBlurDetail'</span><span>)</span><span>.</span><span>querySelector</span><span>(</span><span>'#tapsCountBench'</span><span>)</span><span>,</span> <span>iterations</span><span>:</span> WebGLBox<span>.</span><span>querySelector</span><span>(</span><span>'#iterations'</span><span>)</span> <span>}</span> <span>}</span><span>;</span> <span>/* Shaders */</span> <span>const</span> circleAnimation <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/circleAnimation.vs"</span><span>)</span><span>;</span> <span>const</span> simpleTexture <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleTexture.fs"</span><span>)</span><span>;</span> <span>const</span> bloomVert <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.vs"</span><span>)</span><span>;</span> <span>const</span> bloomFrag <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/bloom.fs"</span><span>)</span><span>;</span> <span>const</span> simpleQuad <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/simpleQuad.vs"</span><span>)</span><span>;</span> <span>const</span> dualKawaseDown <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/dual-kawase-down.fs"</span><span>)</span><span>;</span> <span>const</span> dualKawaseUp <span>=</span> <span>await</span> util<span>.</span><span>fetchShader</span><span>(</span><span>"shader/dual-kawase-up.fs"</span><span>)</span><span>;</span> <span>/* Elements that cause a redraw in the non-animation mode */</span> ui<span>.</span>blur<span>.</span>downsample<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> <span>/* Events */</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>redraw</span><span>(</span><span>)</span> <span>}</span> <span>}</span><span>)</span><span>;</span> canvas<span>.</span><span>addEventListener</span><span>(</span><span>"webglcontextlost"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>display<span>.</span>contextLoss<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>blur<span>.</span>downsample<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>downsample<span>.</span>value <span>==</span> <span>;</span> ui<span>.</span>blur<span>.</span>samplePosReset<span>.</span>disabled <span>=</span> ui<span>.</span>blur<span>.</span>downsample<span>.</span>value <span>==</span> <span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Render Mode */</span> ui<span>.</span>rendering<span>.</span>modes<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span> <span>/* Force set to scene to fix a reload bug in Firefox Android */</span> <span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>"scene"</span><span>)</span> radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span> radio<span>.</span><span>addEventListener</span><span>(</span><span>'change'</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>mode <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> ui<span>.</span>rendering<span>.</span>lightBrightnessReset<span>.</span>disabled <span>=</span> ctx<span>.</span>mode <span>===</span> <span>"scene"</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>true</span><span>;</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>true</span><span>;</span> <span>/* spin up the Worker (ES-module) */</span> <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>"./js/benchmark/dualKawaseBenchmark.js"</span><span>,</span> <span>{</span> <span>type</span><span>:</span> <span>"module"</span> <span>}</span><span>)</span><span>;</span> <span>/* pass all data the worker needs */</span> worker<span>.</span><span>postMessage</span><span>(</span><span>{</span> <span>iterations</span><span>:</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value<span>,</span> <span>downShaderSrc</span><span>:</span> dualKawaseDown<span>,</span> <span>upShaderSrc</span><span>:</span> dualKawaseUp<span>,</span> <span>downsampleLevels</span><span>:</span> ui<span>.</span>blur<span>.</span>downsample<span>.</span>value<span>,</span> <span>samplePos</span><span>:</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value <span>}</span><span>)</span><span>;</span> <span>/* Benchmark */</span> worker<span>.</span><span>addEventListener</span><span>(</span><span>"message"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>event<span>.</span>data<span>.</span>type <span>!==</span> <span>"done"</span><span>)</span> <span>return</span><span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>benchText<span>;</span> ui<span>.</span>benchmark<span>.</span>tapsCount<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>tapsCount<span>;</span> ui<span>.</span>benchmark<span>.</span>iterTime<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>iterationText<span>;</span> ui<span>.</span>benchmark<span>.</span>renderer<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>renderer<span>;</span> ui<span>.</span>benchmark<span>.</span>downsampleLevels<span>.</span>textContent <span>=</span> event<span>.</span>data<span>.</span>downsampleLevels<span>;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>button<span>.</span>disabled <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>benchMode <span>=</span> <span>false</span><span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>else</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> ui<span>.</span>benchmark<span>.</span>iterations<span>.</span><span>addEventListener</span><span>(</span><span>"change"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span> ui<span>.</span>benchmark<span>.</span>iterOut<span>.</span>value <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span> ui<span>.</span>benchmark<span>.</span>label<span>.</span>textContent <span>=</span> <span>"Benchmark"</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>/* Draw Texture Shader */</span> ctx<span>.</span>shd<span>.</span>scene <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleAnimation<span>,</span> simpleTexture<span>,</span> <span>[</span><span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Draw bloom Shader */</span> ctx<span>.</span>shd<span>.</span>bloom <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> bloomVert<span>,</span> bloomFrag<span>,</span> <span>[</span><span>"texture"</span><span>,</span> <span>"textureAdd"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"radius"</span><span>]</span><span>)</span><span>;</span> <span>/* Simple Passthrough */</span> ctx<span>.</span>shd<span>.</span>passthrough <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> simpleTexture<span>)</span><span>;</span> <span>/* Dual Kawase Shaders */</span> ctx<span>.</span>shd<span>.</span>downsample <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> dualKawaseDown<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"bloomStrength"</span><span>]</span><span>)</span><span>;</span> ctx<span>.</span>shd<span>.</span>upsample <span>=</span> util<span>.</span><span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleQuad<span>,</span> dualKawaseUp<span>,</span> <span>[</span><span>"frameSizeRCP"</span><span>,</span> <span>"offset"</span><span>,</span> <span>"bloomStrength"</span><span>]</span><span>)</span><span>;</span> <span>/* Send Unit code verts to the GPU */</span> util<span>.</span><span>bindUnitQuad</span><span>(</span>gl<span>)</span><span>;</span> <span>async</span> <span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"block"</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>true</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>scene<span>,</span> ctx<span>.</span>tex<span>.</span>frame<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>[</span>ctx<span>.</span>fb<span>.</span>final<span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>const</span> maxDown <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>downsample<span>.</span>max<span>)</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> maxDown<span>;</span> <span>++</span>i<span>)</span> <span>{</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>}</span> ctx<span>.</span>fb<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>tex<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> <span>let</span> w <span>=</span> canvas<span>.</span>width<span>,</span> h <span>=</span> canvas<span>.</span>height<span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> maxDown<span>;</span> <span>++</span>i<span>)</span> <span>{</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> w <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> h <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> <span>const</span> <span>[</span>fb<span>,</span> tex<span>]</span> <span>=</span> util<span>.</span><span>setupFramebuffer</span><span>(</span>gl<span>,</span> w<span>,</span> h<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>down<span>.</span><span>push</span><span>(</span>fb<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>down<span>.</span><span>push</span><span>(</span>tex<span>)</span><span>;</span> <span>}</span> <span>let</span> <span>[</span>base<span>,</span> selfIllum<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/SDR_No_Sprite.png"</span><span>)</span><span>,</span> <span>fetch</span><span>(</span><span>"/dual-kawase/img/Selfillumination.png"</span><span>)</span> <span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBlob<span>,</span> selfIllumBlob<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span>base<span>.</span><span>blob</span><span>(</span><span>)</span><span>,</span> selfIllum<span>.</span><span>blob</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span> <span>let</span> <span>[</span>baseBitmap<span>,</span> selfIllumBitmap<span>]</span> <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span><span>[</span> <span>createImageBitmap</span><span>(</span>baseBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span><span>,</span> <span>createImageBitmap</span><span>(</span>selfIllumBlob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>'none'</span><span>,</span> <span>resizeWidth</span><span>:</span> canvas<span>.</span>width <span>*</span> <span>1.12</span><span>,</span> <span>resizeHeight</span><span>:</span> canvas<span>.</span>height <span>*</span> <span>1.12</span><span>,</span> <span>resizeQuality</span><span>:</span> <span>"high"</span> <span>}</span><span>)</span> <span>]</span><span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> baseBitmap<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> util<span>.</span><span>setupTexture</span><span>(</span>gl<span>,</span> <span>null</span><span>,</span> <span>null</span><span>,</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>,</span> gl<span>.</span><span>LINEAR</span><span>,</span> selfIllumBitmap<span>)</span><span>;</span> baseBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> selfIllumBitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>true</span><span>;</span> ui<span>.</span>display<span>.</span>spinner<span>.</span>style<span>.</span>display <span>=</span> <span>"none"</span><span>;</span> <span>}</span> <span>let</span> prevNow <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> lastStatsUpdate <span>=</span> prevNow<span>;</span> <span>let</span> fpsEMA <span>=</span> <span>60</span><span>;</span> <span>let</span> msEMA <span>=</span> <span>16</span><span>;</span> <span>async</span> <span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>buffersInitialized<span>)</span> <span>await</span> <span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>initComplete<span>)</span> <span>return</span><span>;</span> <span>/* UI Stats */</span> <span>const</span> levels <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>downsample<span>.</span>value<span>)</span><span>;</span> <span>/* Calculate texture taps based on computational resolution at each level */</span> <span>let</span> totalTaps <span>=</span> <span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> levels<span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>const</span> levelW <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> <span>const</span> levelH <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> totalTaps <span>+=</span> levelW <span>*</span> levelH <span>*</span> <span>5</span><span>;</span> <span>// 5 samples per downsample pass</span> <span>if</span> <span>(</span>i <span>&lt;</span> levels <span>-</span> <span>1</span><span>)</span> totalTaps <span>+=</span> levelW <span>*</span> levelH <span>*</span> <span>8</span><span>;</span> <span>// 8 samples per upsample pass (except final)</span> <span>}</span> <span>if</span> <span>(</span>levels <span>&gt;</span> <span>)</span> totalTaps <span>+=</span> canvas<span>.</span>width <span>*</span> canvas<span>.</span>height <span>*</span> <span>8</span><span>;</span> <span>// Final upsample to full res</span> <span>const</span> tapsNewText <span>=</span> <span>(</span>totalTaps <span>/</span> <span>1000000</span><span>)</span><span>.</span><span>toFixed</span><span>(</span><span>1</span><span>)</span> <span>+</span> <span>" Million"</span><span>;</span> ui<span>.</span>display<span>.</span>tapsCount<span>.</span>value <span>=</span> tapsNewText<span>;</span> <span>/* Display actual output resolution (always full canvas size) */</span> ui<span>.</span>display<span>.</span>width<span>.</span>value <span>=</span> canvas<span>.</span>width<span>;</span> ui<span>.</span>display<span>.</span>height<span>.</span>value <span>=</span> canvas<span>.</span>height<span>;</span> <span>/* Circle Motion */</span> <span>let</span> radiusSwitch <span>=</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>?</span> radius <span>:</span> <span>0.0</span><span>;</span> <span>let</span> speed <span>=</span> <span>(</span>performance<span>.</span><span>now</span><span>(</span><span>)</span> <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span> <span>const</span> offset <span>=</span> <span>[</span>radiusSwitch <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span><span>,</span> radiusSwitch <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>]</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>handle<span>)</span><span>;</span> <span>const</span> texture <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> ctx<span>.</span>tex<span>.</span>sdr <span>:</span> ctx<span>.</span>tex<span>.</span>selfIllum<span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> texture<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>scene<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> <span>/* Setup PostProcess Framebuffer */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>/* Draw Call */</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>const</span> downsampleLevels <span>=</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>downsample<span>.</span>value<span>)</span><span>;</span> <span>let</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>frame<span>;</span> <span>if</span> <span>(</span>downsampleLevels <span>&gt;</span> <span>)</span> <span>{</span> <span>/* Apply distributed brightness, due to color precision limitations and multi pass nature of this blur algorithm */</span> <span>const</span> finalBrightness <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> <span>const</span> totalPasses <span>=</span> <span>2</span> <span>*</span> downsampleLevels<span>;</span> <span>const</span> distributedBrightness <span>=</span> Math<span>.</span><span>pow</span><span>(</span>finalBrightness<span>,</span> <span>1.0</span> <span>/</span> totalPasses<span>)</span><span>;</span> <span>/* Downsample chain */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>downsample<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>downsample<span>.</span>uniforms<span>.</span>offset<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> <span>let</span> w <span>=</span> canvas<span>.</span>width<span>,</span> h <span>=</span> canvas<span>.</span>height<span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> downsampleLevels<span>;</span> <span>++</span>i<span>)</span> <span>{</span> <span>const</span> fb <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>;</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> w <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> h <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> fb<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> w<span>,</span> h<span>)</span><span>;</span> <span>const</span> frameSizeRCP <span>=</span> <span>[</span><span>1.0</span> <span>/</span> w<span>,</span> <span>1.0</span> <span>/</span> h<span>]</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>downsample<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> frameSizeRCP<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>downsample<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> distributedBrightness<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>;</span> <span>}</span> <span>/* Upsample chain */</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>uniforms<span>.</span>offset<span>,</span> ui<span>.</span>blur<span>.</span>samplePos<span>.</span>value<span>)</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> downsampleLevels <span>-</span> <span>2</span><span>;</span> i <span>&gt;=</span> <span>;</span> i<span>--</span><span>)</span> <span>{</span> <span>const</span> fb <span>=</span> ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>;</span> w <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> h <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> fb<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> w<span>,</span> h<span>)</span><span>;</span> <span>const</span> srcW <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>2</span><span>)</span><span>)</span><span>;</span> <span>const</span> srcH <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>(</span>i <span>+</span> <span>2</span><span>)</span><span>)</span><span>;</span> <span>const</span> frameSizeRCP <span>=</span> <span>[</span><span>1.0</span> <span>/</span> srcW<span>,</span> <span>1.0</span> <span>/</span> srcH<span>]</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> frameSizeRCP<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> distributedBrightness<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>;</span> <span>}</span> <span>/* Final upsample to full resolution */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> <span>const</span> srcW <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>width <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> <span>const</span> srcH <span>=</span> Math<span>.</span><span>max</span><span>(</span><span>1</span><span>,</span> canvas<span>.</span>height <span>&gt;&gt;</span> <span>1</span><span>)</span><span>;</span> <span>const</span> frameSizeRCP <span>=</span> <span>[</span><span>1.0</span> <span>/</span> srcW<span>,</span> <span>1.0</span> <span>/</span> srcH<span>]</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>uniforms<span>.</span>frameSizeRCP<span>,</span> frameSizeRCP<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>upsample<span>.</span>uniforms<span>.</span>bloomStrength<span>,</span> distributedBrightness<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>!=</span> <span>"bloom"</span><span>)</span> <span>{</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>;</span> <span>}</span> <span>}</span> <span>else</span> <span>{</span> <span>/* No blur - direct passthrough */</span> <span>const</span> finalFB <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"bloom"</span> <span>?</span> ctx<span>.</span>fb<span>.</span>final <span>:</span> <span>null</span><span>;</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> finalFB<span>)</span><span>;</span> gl<span>.</span><span>viewport</span><span>(</span><span>,</span> <span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> srcTex<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>gl<span>.</span><span>getUniformLocation</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>,</span> <span>"texture"</span><span>)</span><span>,</span> <span>)</span><span>;</span> <span>const</span> bloomStrength <span>=</span> ctx<span>.</span>mode <span>==</span> <span>"scene"</span> <span>?</span> <span>1.0</span> <span>:</span> ui<span>.</span>rendering<span>.</span>lightBrightness<span>.</span>value<span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>gl<span>.</span><span>getUniformLocation</span><span>(</span>ctx<span>.</span>shd<span>.</span>passthrough<span>.</span>handle<span>,</span> <span>"bloomStrength"</span><span>)</span><span>,</span> bloomStrength<span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>!=</span> <span>"bloom"</span><span>)</span> <span>{</span> srcTex <span>=</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>;</span> <span>}</span> <span>}</span> <span>if</span> <span>(</span>ctx<span>.</span>mode <span>==</span> <span>"bloom"</span><span>)</span> <span>{</span> <span>/* Now do the bloom composition to the screen */</span> gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span> gl<span>.</span><span>useProgram</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>handle<span>)</span><span>;</span> gl<span>.</span><span>uniform2fv</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>offset<span>,</span> offset<span>)</span><span>;</span> gl<span>.</span><span>uniform1f</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>radius<span>,</span> radiusSwitch<span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE0</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>texture<span>,</span> <span>)</span><span>;</span> gl<span>.</span><span>activeTexture</span><span>(</span>gl<span>.</span><span>TEXTURE1</span><span>)</span><span>;</span> gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> gl<span>.</span><span>uniform1i</span><span>(</span>ctx<span>.</span>shd<span>.</span>bloom<span>.</span>uniforms<span>.</span>textureAdd<span>,</span> <span>1</span><span>)</span><span>;</span> gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>,</span> <span>4</span><span>)</span><span>;</span> <span>}</span> <span>/* Ask for CPU-GPU Sync to prevent overloading the GPU during compositing. In reality this is more likely to be flush, but still, it seems to help on multiple devices with during low FPS */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>const</span> now <span>=</span> performance<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span> <span>let</span> dt <span>=</span> now <span>-</span> prevNow<span>;</span> <span>if</span> <span>(</span>dt <span>&gt;</span> <span>)</span> <span>{</span> <span>const</span> instFPS <span>=</span> <span>1000</span> <span>/</span> dt<span>;</span> <span>const</span> <span>ALPHA</span> <span>=</span> <span>0.05</span><span>;</span> fpsEMA <span>=</span> <span>ALPHA</span> <span>*</span> instFPS <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> fpsEMA<span>;</span> msEMA <span>=</span> <span>ALPHA</span> <span>*</span> dt <span>+</span> <span>(</span><span>1</span> <span>-</span> <span>ALPHA</span><span>)</span> <span>*</span> msEMA<span>;</span> <span>}</span> prevNow <span>=</span> now<span>;</span> <span>if</span> <span>(</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked <span>&amp;&amp;</span> now <span>-</span> lastStatsUpdate <span>&gt;=</span> <span>1000</span><span>)</span> <span>{</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> fpsEMA<span>.</span><span>toFixed</span><span>(</span><span>)</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> msEMA<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>;</span> lastStatsUpdate <span>=</span> now<span>;</span> <span>}</span> <span>}</span> <span>let</span> animationFrameId<span>;</span> <span>/* Render at Native Resolution */</span> <span>function</span> <span>nativeResize</span><span>(</span><span>)</span> <span>{</span> <span>const</span> <span>[</span>width<span>,</span> height<span>]</span> <span>=</span> util<span>.</span><span>getNativeSize</span><span>(</span>canvas<span>)</span><span>;</span> <span>if</span> <span>(</span>width <span>&amp;&amp;</span> canvas<span>.</span>width <span>!==</span> width <span>||</span> height <span>&amp;&amp;</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span> canvas<span>.</span>width <span>=</span> width<span>;</span> canvas<span>.</span>height <span>=</span> height<span>;</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>if</span> <span>(</span><span>!</span>ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span> <span>/* Resize Event */</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>let</span> resizePending <span>=</span> <span>false</span><span>;</span> window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>resizePending<span>)</span> <span>{</span> resizePending <span>=</span> <span>true</span><span>;</span> <span>requestAnimationFrame</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> resizePending <span>=</span> <span>false</span><span>;</span> <span>nativeResize</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>function</span> <span>renderLoop</span><span>(</span><span>)</span> <span>{</span> <span>if</span> <span>(</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> ui<span>.</span>rendering<span>.</span>animate<span>.</span>checked<span>)</span> <span>{</span> <span>redraw</span><span>(</span><span>)</span><span>;</span> animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span> <span>}</span> <span>}</span> <span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Start rendering, when canvas visible */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>true</span><span>;</span> <span>renderLoop</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span> <span>/* Stop another redraw being called */</span> ctx<span>.</span>flags<span>.</span>isRendering <span>=</span> <span>false</span><span>;</span> <span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span> <span>/* Force the rendering pipeline to sync with CPU before we mess with it */</span> gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span> <span>/* Delete the buffers to free up memory */</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>sdr<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>sdr <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>selfIllum<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>selfIllum <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frame<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frame <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>frameFinal<span>)</span><span>;</span> ctx<span>.</span>tex<span>.</span>frameFinal <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>scene<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>scene <span>=</span> <span>null</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>final<span>)</span><span>;</span> ctx<span>.</span>fb<span>.</span>final <span>=</span> <span>null</span><span>;</span> <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>;</span> i <span>&lt;</span> <span>parseInt</span><span>(</span>ui<span>.</span>blur<span>.</span>downsample<span>.</span>max<span>)</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span> gl<span>.</span><span>deleteTexture</span><span>(</span>ctx<span>.</span>tex<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> gl<span>.</span><span>deleteFramebuffer</span><span>(</span>ctx<span>.</span>fb<span>.</span>down<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>}</span> ctx<span>.</span>tex<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>fb<span>.</span>down <span>=</span> <span>[</span><span>]</span><span>;</span> ctx<span>.</span>flags<span>.</span>buffersInitialized <span>=</span> <span>false</span><span>;</span> ctx<span>.</span>flags<span>.</span>initComplete <span>=</span> <span>false</span><span>;</span> ui<span>.</span>display<span>.</span>fps<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> ui<span>.</span>display<span>.</span>ms<span>.</span>value <span>=</span> <span>"-"</span><span>;</span> <span>}</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span> entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span> <span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span> <span>if</span> <span>(</span><span>!</span>ctx<span>.</span>flags<span>.</span>isRendering <span>&amp;&amp;</span> <span>!</span>ctx<span>.</span>flags<span>.</span>benchMode<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>else</span> <span>{</span> <span>stopRendering</span><span>(</span><span>)</span><span>;</span> <span>}</span> <span>}</span><span>)</span><span>;</span> <span>}</span> <span>/* Only render when the canvas is actually on screen */</span> <span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span> observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span> <span>}</span></code></pre></details></blockquote><p>It&rsquo;s also a gaussian-like blur. Remember our first gaussian Blur? Its performance tanked exponentially, as we increased kernel radius. But now, with each downsample step, the required texture taps grow slower and slower. The stronger our blur, the less <em>additional</em> samples we require!</p><p>This was of special interest to Marius Bj&oslash;rge, as his goal was to reduce memory access, which is especially slow on mobile devices, and still produce a motion-stable non shimmering blur. Speaking of which, go into bloom mode, crank <code>lightBrightness</code> and compare it to our <a href="https://blog.frost.kiwi#downsampling">downsample</a> example.</p><p>Even though the resolution is reduced to the same <code>downSample</code> level, no shimmering! That&rsquo;s the Dual Kawase Blur for you - A gaussian-like post-processing blur, with good performance, no heavy repeated memory writes and motion stable output. This makes it ideal as a basic building block for visual effects like bloom.</p><h2>What are the big boys doing? <a href="https://blog.frost.kiwi#what-are-the-big-boys-doing%3F">#</a></h2><p>The Dual Kawase Blur has found its way into game engines and user interfaces alike. For instance the Linux Desktop Environment <a href="https://kde.org/">KDE</a> uses it as the frosted backdrop effect <a href="https://web.archive.org/web/20220427124712/https://phabricator.kde.org/D9848">since in 2018</a>, where it remains the <a href="https://invent.kde.org/plasma/kwin/-/tree/master/src/plugins/blur">algorithm of choice to this day</a>. I used KDE&rsquo;s implementation as a guide when creating my demo above.</p><figure><img src="https://blog.frost.kiwiimg/kdeBlur.png" alt="KDE Plasma's Blur with noise at max strength"><figcaption>KDE Plasma's Blur with noise at max strength (<a href="https://web.archive.org/web/20220427124712/https://phabricator.kde.org/D9848">Source</a>)</figcaption></figure><p>Of course, graphics programming didn&rsquo;t stop in 2015 and there have been new developments. The previously mentioned talk <a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Next Generation Post Processing in Call of Duty: Advanced Warfare</a> by <a href="https://www.iryoku.com/">Jorge Jimenez</a> showcased an evolution on the &ldquo;downsample while blurring&rdquo; idea to handle far-away and very bright lights at high blur strengths better.</p><figure><video><source src="https://blog.frost.kiwiimg/jimenezBlur.mp4"></source></video><figcaption>Uneven interpolation of bright, small light sources (Left), Page 156 from presentation<br><a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Next Generation Post Processing in Call of Duty: Advanced Warfare</a> by <a href="https://www.iryoku.com/">Jorge Jimenez</a></figcaption></figure><p>In turn, this technique got picked up two years later by graphics programmer <a href="https://x.com/pixelmager">Mikkel Gjoel</a>, when working on the video game <a href="https://en.wikipedia.org/wiki/Inside_(video_game)">INSIDE</a> by Studio <a href="https://playdead.com/">Playdead</a>. In the GDC 2016 talk <a href="https://gdcvault.com/play/1023304/Low-Complexity-High-Fidelity-INSIDE">Low Complexity, High Fidelity - INSIDE Rendering</a> he showcased a further optimization, reducing the number of texture reads required.</p><figure><video><source src="https://blog.frost.kiwiimg/gdcInside.mp4"></source></video><figcaption>Blur algorithm used for Bloom in video game Inside<br>Excerpt from talk <a href="https://gdcvault.com/play/1023304/Low-Complexity-High-Fidelity-INSIDE">Low Complexity, High Fidelity - INSIDE Rendering</a> by Mikkel Gjoel &amp; Mikkel Svendsen</figcaption></figure><p>I showcased the bloom use-case a lot. The technique used in my demos is rather primitive, akin to the time of video game <a href="https://gangles.ca/2008/07/18/bloom-disasters/">bloom disasters</a>, where some many games had radioactive levels of bloom, showing off a then novel technique. In this older style an extra lights pass or the scene after <a href="https://en.wikipedia.org/wiki/Thresholding_(image_processing)">thresholding</a>, was blurred and added on top.</p><figure><img src="https://blog.frost.kiwiimg/bloom-oblivion.jpg" alt="Bloom in Video game "><figcaption>Bloom in Video game <a href="https://en.wikipedia.org/wiki/The_Elder_Scrolls_IV:_Oblivion">The Elder Scrolls IV: Oblivion</a>, from article by <a href="https://gangles.ca/2008/07/18/bloom-disasters/">Bloom Disasters</a></figcaption></figure><p>These days 3D engines follow a <a href="https://learnopengl.com/PBR/Theory">Physically based shading</a> model, with HDR framebuffers capturing pixels in an <a href="https://learnopengl.com/Getting-started/Textures#:~:text=Energy%20conservation">energy conserving</a> manner. Specular light reflections preserve the super bright pixels from the lamp they originated from.</p><p>With such a wide range of energy values, light that should bloom doesn&rsquo;t need special selection anymore. Instead of defining what to blur, everything is blurred and the bright parts naturally start glowing, without predefined &ldquo;parts to blur&rdquo;.</p><figure><img src="https://blog.frost.kiwiimg/bloom.png" alt="Physically Based Blur"><figcaption>Multiple blurs stacked to create a natural light fall-off<br>Page 144 in <a href="https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/">Next Generation Post Processing in Call of Duty: Advanced Warfare</a> by <a href="https://www.iryoku.com/">Jorge Jimenez</a></figcaption></figure><p>The result isn&rsquo;t just blurred once, but rather multiple blur strengths are stacked on top of each other, for a more natural light fall-off, as shown in the previously mentioned talk by Jorge Jimenez. This isn&rsquo;t an article about bloom, but the underlying building block. The Blur.</p><p>This was a journey through blurs and I hope you enjoyed the ride! If you are a new visitor from the <a href="https://some.3b1b.co/">Summer of Math Exposition</a> and enjoyed this article, you&rsquo;ll enjoy my other graphics programming deep-dives on this blog. Also during SoME 3, my submission was a WebApp + Video Adventure into Mirrorballs:</p><figure><iframe src="https://www.youtube-nocookie.com/embed/rJPKTCdk-WI" title="YouTube video player" width="100%"></iframe><figcaption>Mathematical Magic Mirrorball #SoME3<br><a href="https://www.youtube.com/watch?v=rJPKTCdk-WI">YouTube Video</a> by <a href="https://www.youtube.com/@FrostKiwi">FrostKiwi</a></figcaption></figure><h2>Addendum <a href="https://blog.frost.kiwi#addendum">#</a></h2><p>Additional things that came to light as a result of discussions around this article.</p><h3>Upsample skip steps technique <a href="https://blog.frost.kiwi#upsample-skip-steps-technique">#</a></h3><p>In the <a href="https://blog.frost.kiwi#downsampling">downsampling</a> chapter I mentioned, that skipping upsample steps will result in &ldquo;<em>a vague grid like artifact appearing</em>&rdquo;. In an E-Mail, Masaki Kawase expanded on this with a reference to his <a href="https://www.siliconstudio.co.jp/rd/presentations/#CEDEC2009">2009 CEDEC</a> talk <a href="https://www.siliconstudio.co.jp/rd/presentations/files/CEDEC2009/CEDEC2009_Anti-DownsizedBufferArtifacts.ppt">Anti-Downsized Buffer Artifacts</a>, that there is an in-between path, when the Downscale - Upsample chain is a bit longer.</p><figure><figcaption>Skipping Upsample steps and the resulting artifacts (Left) vs performing one intermediary upsample step with 4-Tap Blur, before going on to skipping the remaining intermediary up-sample steps with reduced artifacts (Right)<br>Page 99 - 100 from the 2009 CEDEC talk<br><a href="https://www.siliconstudio.co.jp/rd/presentations/files/CEDEC2009/CEDEC2009_Anti-DownsizedBufferArtifacts.ppt">Anti-Downsized Buffer Artifacts</a> by <a href="https://www.siliconstudio.co.jp/middleware/yebis/en/">Masaki Kawase</a></figcaption></figure><p>This involves performing a slight 4 Texture-Tap blur on the very first upsample from the smallest to 2nd smallest framebuffer size and then skipping all the remaining upscample steps, a technique explained in the above linked talk from page 72 onwards. A balance of a longer upsample chain vs the appearance of artifacts.</p><h3>Multiple blurs stacked <a href="https://blog.frost.kiwi#multiple-blurs-stacked">#</a></h3><p>I was surprised to learn that the &ldquo;Multiple blurs stacked to create a natural light fall-off&rdquo; thing was <em>also</em> presented by Masaki Kawase in the 2004 GDC talk <a href="https://gdcvault.com/play/1015174/Practical-Implementation-of-High-Dynamic">Practical Implementation of High Dynamic Range Rendering</a>. Those couple of years in particular were quite eventful for graphics programming!</p><figure><video><source src="https://blog.frost.kiwivid/2004-Gdc-Kawase-Practical-Hdr.mp4"></source></video><figcaption>Use of Multiple Gaussian Filters, Excerpt from the 2004 GDC Talk<br><a href="https://gdcvault.com/play/1015174/Practical-Implementation-of-High-Dynamic">Practical Implementation of High Dynamic Range Rendering</a> (<a href="https://media.gdcvault.com/gdc04/video/2004-GDC-kawase-practical-hdr.flv">Video Direct Link</a>) by <a href="https://www.siliconstudio.co.jp/middleware/yebis/en/">Masaki Kawase</a></figcaption></figure><blockquote><p>Didn't even know about this connection, truly a graphics programmer idol of mine</p><img src="https://blog.frost.kiwi/assets/kiwis/love.svg"></blockquote><p>Here are the 3 slides mentioned in the excerpt from the talk:</p><figure><figcaption>Page 31 - 33 from the 2004 GDC Talk<br><a href="https://gdcvault.com/play/1015174/Practical-Implementation-of-High-Dynamic">Practical Implementation of High Dynamic Range Rendering</a> by <a href="https://www.siliconstudio.co.jp/middleware/yebis/en/">Masaki Kawase</a></figcaption></figure></div></section>]]></description><pubDate>Wed, 03 Sep 2025 16:57:14 +0530</pubDate></item><item><link>https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html</link><title>Python has had async for 10 years – why isn't it more popular? (tonybaloney.github.io)</title><guid isPermaLink="true">https://www.reddit.com/r/programming/comments/1n6vqrz/python_has_had_async_for_10_years_why_isnt_it/</guid><comments>https://www.reddit.com/r/programming/comments/1n6vqrz/python_has_had_async_for_10_years_why_isnt_it/</comments><description><![CDATA[<section class='reading-time-and-permalink'><p>Reading time: 20 min | <a href='https://www.reddit.com/r/programming/comments/1n6vqrz/python_has_had_async_for_10_years_why_isnt_it/'>Post permalink</a></p></section><section class='preview-image'><img src='https://tonybaloney.github.io/img/posts/fishing-2015.jpg' /></section><section class='parsed-content'><div><p>The <a href="https://www.youtube.com/watch?v=GfH4QL4VqJ0&amp;pp=ygUScHl0aG9uIGRvY3VtZW50YXJ5">Python Documentary</a> dropped this morning. In the middle of the documentary, there&rsquo;s a dramatic segment about how the transition from Python 2 to 3 divided the community (spoiler alert: <a href="https://blog.jetbrains.com/pycharm/2025/08/the-state-of-python-2025/#most-still-use-older-python-versions-despite-benefits-of-newer-releases">it didn&rsquo;t in the end</a>).</p><p>The early versions of Python 3 (3.0-3.4) were mostly focused on stability and offering pathways for users moving from 2.7. Along came 3.5 in 2015 with a new feature: <a href="https://peps.python.org/pep-0492/"><code>async</code> and <code>await</code> keywords for executing coroutines</a>.</p><p>Ten years and nine releases later, Python 3.14 is <a href="https://peps.python.org/pep-0745/">weeks away</a>.</p><p>Whilst everyone will be distracted by the shiny, colorful REPL features in 3.14, there are some big announcements nestled in the release notes &mdash; both related to concurrency and parallelism</p><ol> <li><a href="https://docs.python.org/3.14/whatsnew/3.14.html#pep-779-free-threaded-python-is-officially-supported">PEP779 Free-Threading is Officially Supported</a>. </li> <li><a href="https://docs.python.org/3.14/whatsnew/3.14.html#pep-734-multiple-interpreters-in-the-stdlib">PEP 734: Multiple interpreters in the stdlib</a></li> </ol><p>Both of these features are huge advancements in how Python can be used to execute concurrent code. But if <code>async</code> has been here for 10 years, why do we need them?</p><p>The killer use-case for async is web development. Coroutines lend well to out-of-process network calls, like HTTP requests and database queries. Why block the entire Python interpreter waiting for a SQL query to run on another server?</p><p>Yet, among the three most popular Python web frameworks, async support is still not universal. FastAPI is async from the ground-up, Django has some support, but is <a href="https://docs.djangoproject.com/en/5.2/topics/async/"><strong>&ldquo;still working on async support&rdquo;</strong></a> in key areas like the ORM (database). Then Flask is and probably always will be synchronous (Quart is an async alternative with similar APIs). The most popular ORM for Python, SQLAlchemy, only added asyncio support in 2023 (<a href="https://docs.sqlalchemy.org/en/20/changelog/migration_14.html#change-3414">changelog</a>).</p><p>I posed the question <em>&ldquo;Why isn&rsquo;t async more popular&rdquo;</em> to a couple of other developers to get their thoughts.</p><p><a href="https://realpython.com/team/ctrudeau/">Christopher Trudeau</a>, co-host of the <a href="https://realpython.com/podcasts/rpp/">Real Python Podcast</a>, shared his perspective:</p><blockquote><p>Certain kinds of errors get caught by the compiler, others just disappear. Why didn&rsquo;t that function run? Oops, forgot to await it. Error in the coroutine? Did you remember to launch with the right params, if not, it doesn&rsquo;t percolate up. I still find threads easier to wrap my head around.</p></blockquote><p><a href="https://talkpython.fm/">Michael Kennedy</a> offered some additional insight:</p><blockquote><p>The [GIL] is so omnipresent that most Python people never developed multithreaded/async thinking. Because async/await only works for I/O bound work, not CPU as well, it&rsquo;s of much less use. E.g. You can use in on the web, but most servers fork out to 4-8 web workers anyway</p></blockquote><p>So <strong>what&rsquo;s going on here</strong> and <strong>can we apply the lessons to Free-Threading and Multiple Interpreters in 3.14</strong> so that in another ten years we&rsquo;re looking back and wondering why <strong>they</strong> aren&rsquo;t more popular?</p><h2>Problem 1: What is an asynchronous-shaped problem?<a href="https://tonybaloney.github.io#problem-1-what-is-an-asynchronous-shaped-problem" title="Permanent link">&para;</a></h2><p><em>Coroutines</em> are most valuable with IO-related tasks. In Python, you can start hundreds of coroutines to make network requests, then wait for them all to finish without running them one at a time. The concepts behind coroutines are quite straightforward. You have a loop (the event loop) and you pass it coroutines to evaluate.</p><p>Let&rsquo;s go back to the classic use-case, HTTP requests:</p><pre><code>def get_thing_sync(): return http_client.get('/thing/which_takes?ages=1') </code></pre><p>The equivalent async function is clean and readable:</p><pre><code>async def get_thing_async(): return await http_client.get('/thing/which_takes?ages=1') </code></pre><p>If you call function <code>get_thing_sync()</code> versus <code>await get_thing_async()</code>, they take <strong>the same amount of time</strong>. Calling it <em>&ldquo;&#10024; asynchronously &#10024;&rdquo;</em> does not somehow make it faster. The gains are when you have more than one coroutine running at once. </p><p>When fetching multiple HTTP resources you can start all the requests at once via the OS network stack, then handle each response as it arrives. The important point is that the actual work &mdash; sending packets and waiting for remote servers &mdash; happens outside your Python process while your code waits. Async is most effective here: you start operations, receive awaitable handles (tasks/futures), and the event loop efficiently notifies the coroutine when each operation completes without wasting CPU on busy&#8209;polling.</p><p>This scenario works well because:</p><ol> <li>The remote end is handling the work in another process</li> <li>The local end (asyncio HTTP library) can yield control while waiting for the response</li> <li>Operating-Systems have stacks and APIs for managing sockets and network</li> </ol><p>That&rsquo;s all fine, but I started with the statement <strong><em>Coroutines</em> are most valuable with IO-related tasks.</strong> I then picked the one task that asyncio can handle really well, HTTP requests.</p><p>What about disk IO? I have <strong>far</strong> more applications in Python which read and write from files on disks or memory than I do making HTTP requests. I also have Python programs which run other programs using <code>subprocess</code>.</p><p>Can I make all of those <code>async</code>? </p><p>No, not really. From the <a href="https://github.com/python/asyncio/wiki/ThirdParty#filesystem">asyncio Wiki</a>:</p><blockquote><p>asyncio does not support asynchronous operations on the filesystem. Even if files are opened with O_NONBLOCK, read and write will block.</p></blockquote><p>The solution is to use a third-party package, <code>aiofiles</code>, which gives you async file I/O capabilities:</p><pre><code>async with aiofiles.open('filename', mode='r') as f: contents = await f.read() </code></pre><p>So, mission accomplished? No because <code>aiofiles</code> uses a <strong>thread pool</strong> to offload the blocking file I/O operations. </p><h3>Side-Quest: Why isn&rsquo;t file IO async?<a href="https://tonybaloney.github.io#side-quest-why-isnt-file-io-async" title="Permanent link">&para;</a></h3><p>Windows has an async file IO API called <a href="https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/">IoRing</a>. Linux has this availability in newer Kernels via <a href="https://kernel.dk/io_uring.pdf"><code>io_uring</code></a>. All I could find for a Python implementation of <code>io_uring</code> is this <a href="https://github.com/YoSTEALTH/Liburing">synchronous API written in Cython</a>.</p><p>There were io_uring APIs for other platforms, Rust has implementations with <a href="https://github.com/tokio-rs/tokio-uring">tokio</a>, C++ has <a href="https://think-async.com/Asio/asio-1.24.0/doc/asio/history.html#asio.history.asio_1_21_0">Asio</a> and Node.JS has <a href="https://www.phoronix.com/news/libuv-io-uring">libuv</a>.</p><p>So, the asyncio Wiki is a little out of date, but</p><ol> <li><strong>Most</strong> production Python applications run on Linux, where the implementation is <code>io_uring</code></li> <li><code>io_uring</code> has been plagued by security issues so bad that RedHat, Google and others have restricted or removed its availability. After paying out $1 million in bug bounties related to <code>io_uring</code>, <a href="https://security.googleblog.com/2023/06/learnings-from-kctf-vrps-42-linux.html">Google disabled it on some products</a>. The issue was severe; many of the related bug&#8209;bounty reports involved io_uring exploits.</li> </ol><p>So we should hold our horses a little while longer. Operating Systems have long held a file IO API that handles threads for concurrent IO. It does the job just fine for now.</p><p>So in summary, <em>Coroutines are most valuable with IO-related tasks</em> is only really true for <strong>network I/O</strong> and network sockets in Python were never blocking operations in the first place. Socket open in Python is one of the few operations which releases the GIL and works <a href="https://github.com/python/cpython/blob/v3.14.0rc2/Modules/socketmodule.c#L939-L1085">concurrently in a thread pool</a> as a non-blocking operation.</p><h3>Recap: What are the async operations in asyncio?<a href="https://tonybaloney.github.io#recap-what-are-the-async-operations-in-asyncio" title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>Operation</th> <th>Asyncio API</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>Sleep</td> <td><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep"><code>asyncio.sleep()</code></a></td> <td>Asynchronously sleep for a given duration.</td> </tr> <tr> <td>TCP/UDP Streams</td> <td><a href="https://docs.python.org/3/library/asyncio-stream.html#asyncio-streams"><code>asyncio.open_connection()</code></a></td> <td>Open a TCP/UDP connection.</td> </tr> <tr> <td>HTTP</td> <td><a href="https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.ClientSession"><code>aiohttp.ClientSession()</code></a></td> <td>Asynchronous HTTP client.</td> </tr> <tr> <td>Run Subprocesses</td> <td><a href="https://docs.python.org/3/library/asyncio-subprocess.html#asyncio-subprocess"><code>asyncio.subprocess</code></a></td> <td>Asynchronously run subprocesses.</td> </tr> <tr> <td>Queues</td> <td><a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio-queues"><code>asyncio.Queue</code></a></td> <td>Asynchronous queue implementation.</td> </tr> </tbody> </table> <h2>Problem 2: No matter how fast you run, you can&rsquo;t escape the GIL<a href="https://tonybaloney.github.io#problem-2-no-matter-how-fast-you-run-you-cant-escape-the-gil" title="Permanent link">&para;</a></h2><p><a href="https://willmcgugan.github.io/">Will McGugan</a>, the creator of Rich, Textualize, and several other extremely popular Python libraries offered his perspective on async:</p><blockquote><p>I really enjoy async programming, but it isn&rsquo;t intuitive for most devs that don&rsquo;t have a background writing network code. A reoccurring problem I see with Textual is folk testing concurrency by dropping in a <code>time.sleep(10)</code> call to simulate the work they are planning. <strong>Of course, that blocks the entire loop.</strong> But that&rsquo;s a class of issue which is difficult to explain to devs who haven&rsquo;t used async much. i.e. what does it mean for code to &ldquo;block&rdquo;, and when is it necessary to defer to threads. <strong>Without that grounding in the fundamentals, your async code is going to misbehave,</strong> but its not going to break per se. So devs don&rsquo;t get the rapid iteration and feedback that we expect from Python.</p></blockquote><p>Now that we&rsquo;ve covered the limited use cases for async, another challenge keeps coming up. The Python GIL.</p><p>I&rsquo;ve been working on this C#/Python bridge project called <a href="https://tonybaloney.github.io/CSnakes">CSnakes</a>, one of the features that caused the most head-scratching was <a href="https://tonybaloney.github.io/CSnakes/v1/user-guide/async/">async</a>.</p><p>C#, the language from which the <a href="https://peps.python.org/pep-0492/#why-async-and-await-keywords"><code>async</code>/<code>await</code> syntax was borrowed</a>, has far broader async support in its core I/O libraries because it implements a Task&#8209;based Asynchronous Pattern (TAP), where tasks are dispatched onto a managed thread pool. Disk, network, and memory I/O operations commonly provide both async and sync methods.</p><p>In fact, the C# implementation goes all the way up from the disk to the higher-level APIs, such as serialization libraries. <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer.deserializeasync?view=net-9.0#system-text-json-jsonserializer-deserializeasync(system-io-stream-system-type-system-text-json-serialization-jsonserializercontext-system-threading-cancellationtoken)">JSON deserialization is async</a>, so is XML. </p><p>The <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming">C# Async model</a> and the Python Async models have some important differences:</p><ul> <li>C# creates a task pool and tasks are scheduled on this pool. The number of threads is managed automatically by the runtime.</li> <li>Python event loops belong to the thread that created them. C# tasks can be scheduled on any thread.</li> <li>Python async functions are coroutines that are scheduled on the event loop. C# async functions are tasks that are scheduled on the task pool.</li> </ul><p>The benefit of C#&rsquo;s model is that a <code>Task</code> is a higher-level abstraction over a thread or coroutine. This means that you don&rsquo;t have to worry about the underlying thread management, you can schedule several tasks to be awaited concurrently or you can run them in parallel with Task Parallel Library (TPL).</p><p>In Python &ldquo;An event loop runs in a thread (typically the main thread) and executes all callbacks and Tasks in its thread. While a Task is running in the event loop, no other Tasks can run in the same thread. When a Task executes an await expression, the running Task gets suspended, and the event loop executes the next Task.&rdquo; <a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading">1</a></p><p>Going back to Will&rsquo;s comment <strong>&ldquo;Of course, that blocks the entire loop&rdquo;</strong>, he&rsquo;s talking about operations inside async functions which are blocking and therefore block the entire event loop. Since we covered in Problem 1, that&rsquo;s practically everything except network calls and sleeping. </p><p>With Python&rsquo;s GIL, it doesn&rsquo;t matter if you&rsquo;re running 1 thread or 10, the GIL will lock everything so that only 1 is operating at a time.</p><p>There are some operations don&rsquo;t block the GIL (e.g. File IO) and in those cases you can run them in threads. For example, if you used <code>httpx</code>&lsquo;s streaming feature to stream a large network download onto disk:</p><pre><code>import httpx import tempfile def download_file(url: str): with tempfile.NamedTemporaryFile(delete=False) as tmp_file: with httpx.stream("GET", url) as response: for chunk in response.iter_bytes(): tmp_file.write(chunk) return tmp_file.name </code></pre><p>Neither the <code>httpx</code> stream iterator nor <code>tmp_file.write</code> is GIL-blocking, so they benefit from running in separate threads.</p><p>We can merge this behavior with an asyncio API, by using the <a href="https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools">Event Loop <code>run_in_executor()</code> function</a> and passing it a thread pool:</p><pre><code>import asyncio import concurrent.futures async def main(): loop = asyncio.get_running_loop() URLS = [ "https://example.place/big-file-1", "https://example.place/big-file-2", "https://example.place/big-file-3", # etc. ] tasks = set() with concurrent.futures.ThreadPoolExecutor(max_workers=10) as pool: for url in URLS: tasks.add(loop.run_in_executor(pool, download_file, url)) files = await asyncio.gather(*tasks) print(files) </code></pre><p>It&rsquo;s not immediately clear to me what the benefit of this is over running a <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">thread-pool and calling <code>pool.submit</code></a>. We retain an async API, so if that is important this is an interesting workaround. </p><p>I find that memorizing, documenting, and explaining what is and isn&rsquo;t &ldquo;blocking&rdquo; in Python to be confusing and continually changing.</p><h3>Does the free-threaded mode make asyncio more useful or redundant?<a href="https://tonybaloney.github.io#does-the-free-threaded-mode-make-asyncio-more-useful-or-redundant" title="Permanent link">&para;</a></h3><p>Python 3.13 introduced a very-unstable &ldquo;free-threaded&rdquo; build of Python where the GIL is removed and replaced with smaller, more granular locks. See my <a href="https://www.youtube.com/watch?v=Mp5wKOL4L2Q">PyCon US 2024 Talk</a> for a summary of parallelism. The 3.13 build wasn&rsquo;t stable enough for any production use. 3.14 is looking far improved and I think we can start to introduce free-threading in 2026 in some narrow, well-tested scenarios.</p><p>One major benefit to coroutines versus threads is that they have a far smaller memory footprint, a lower context-switching overhead, and faster startup times. async APIs are also easier to reason about and compose.</p><p>Because parallelism in Python using threads has always been so limited, the APIs in the standard library are quite rudimentary. I think there is an opportunity to have a task-parallelism API in the standard library once free-threading is stabilized. </p><p>Last week I was implementing a registry function that did two discrete tasks. One calls a very slow sync-only API and the other calls several async APIs. </p><p>I want the behavior that:</p><ul> <li>Both are started at the same time</li> <li>If one fails, it cancels the other and raises an exception with the exception details of the failed function</li> <li>The result is only combined when both are complete</li> </ul><pre> flowchart LR Start([Start]) --&gt; Invoke["tpl.invoke()"] Invoke --&gt; f1["f1()"] Invoke --&gt; f2["f2()"] f1 --&gt;|f1 -&gt; T1| Join["Tuple[T1, T2]"] f2 --&gt;|f2 -&gt; T2| Join Join --&gt; End([End]) </pre><p>Since there are only two tasks, I don&rsquo;t want to have to define a thread-pool or a set number of workers. I also don&rsquo;t want to have to map or gather the callees. I want to retain my typing information so that the resulting variables are strongly typed from the return types of <code>function_a</code> and <code>function_a</code>. Essentially an API like this:</p><pre><code>import tpl def function_a() -&gt; T1: ... def function_b() -&gt; T2: ... result_a: T1, result_b: T2 = tpl.invoke(function_a, function_b) </code></pre><p>This is all <em>possible</em> today but there are many constraints with the GIL. Free-threading will make parallel programming more popular in Python and we&rsquo;ll have to revisit some of the APIs.</p><h2>Problem 3: Maintaining two APIs is hard<a href="https://tonybaloney.github.io#problem-3-maintaining-two-apis-is-hard" title="Permanent link">&para;</a></h2><p>As a package maintainer, supporting both synchronous and asynchronous APIs is a big challenge. You also have to be selective with where you support async. Much of the stdlib doesn&rsquo;t support async natively (e.g. logging backends).</p><p>Python&rsquo;s <strong>Magic</strong> (<code>__dunder__</code>) methods cannot be async. <code>__init__</code> cannot be async for example, so none of your code can use network requests in the initializer.</p><h3>Async properties<a href="https://tonybaloney.github.io#async-properties" title="Permanent link">&para;</a></h3><p>This is an odd-pattern but I&rsquo;ll keep it simple to illustrate my point. You have a class <code>User</code> with a property <code>records</code>. This property gives a list of records for that user. A synchronous API is straightforward:</p><pre><code>class User: @property def records(self) -&gt; list[RecordT]: # fetch records from database lazily ... </code></pre><p>We can even use a lazily-initialized instance variable to cache this data.</p><p>Porting this API to async is a challenge because whilst <code>@property</code> methods can be async, standard attributes are not. Having to <code>await</code> some instance attributes and not others leaves a very odd API:</p><pre><code>class AsyncDatabase: @staticmethod async def fetch_many(id: str, of: Type[RecordT]) -&gt; list[RecordT]: ... class User: @property async def records(self) -&gt; list[RecordT]: # fetch records from database lazily return await AsyncDatabase.fetch_many(self.id, RecordT) </code></pre><p>Anytime you access that property, it needs to be awaited:</p><pre><code>user = User(...) # single access await user.records # if if await user.records: ... # comprehension? [record async for record in user.records] </code></pre><p><a href="https://tryexceptpass.org/article/controlling-python-async-creep/">The further we go into this implementation</a>, the more we wait for the user to accidentally forget to await the property and it fails silently.</p><h3>Duplicated implementations<a href="https://tonybaloney.github.io#duplicated-implementations" title="Permanent link">&para;</a></h3><p>The Azure Python SDK, a ginormous Python project supports both sync and async. Maintaining both is achieved via a lot of code-generation infrastructure. This is ok for a project with tens of full-time engineers, but for anything small or voluntary you need to copy + paste a lot of your code base to create an async version. Then you need to patch and backport fixes and changes between the two. The differences (mostly <code>await</code> calls) are big enough to confuse Git. I was reviewing some langchain implementations last year which had both sync and async implementation. Every method was copied+pasted, with little behavioral differences and their own bugs. People would submit bug fix PR&rsquo;s to one implementation and not the other so instead of merging directly, maintainers had to port the fix, skip it, or ask the contributors to do both.</p><h3>Backend fragmentation<a href="https://tonybaloney.github.io#backend-fragmentation" title="Permanent link">&para;</a></h3><p>Since we&rsquo;re largely talking about HTTP/Network IO, you also need to pick a backend for sync and async. For synchronous HTTP calls, <code>requests</code>, <code>httpx</code> are suitable backends. For <code>async</code>, its <code>aiohttp</code> and <code>httpx</code>. Since neither are part of the Python standard library, the adoption and support for CPython&rsquo;s main platforms is out of sync. E.g. as of today, <code>aiohttp</code> has <a href="https://pypi.org/project/aiohttp/#files">no Python 3.14 wheels, nor free-threaded support</a>. UV Loop, the alternative implementation of the event loop has <a href="https://pypi.org/project/uvloop/#files">no Python 3.14 support, nor any Windows support.</a> (Python 3.14 isn&rsquo;t out yet, so it&rsquo;s reasonable to not have support in either open-source project).</p><h3>Testing overhead<a href="https://tonybaloney.github.io#testing-overhead" title="Permanent link">&para;</a></h3><p>Further down the copy+paste maintainer overhead is the testing of these APIs. Testing your async code requires different mocks, different calls and in the case of Pytest a whole set of extensions and patterns for fixtures. This situation is so <a href="https://tonybaloney.github.io/posts/async-test-patterns-for-pytest-and-unittest.html">confusing I wrote a post about it and it&rsquo;s one of the most popular on my blog</a>.</p><h2>Summary<a href="https://tonybaloney.github.io#summary" title="Permanent link">&para;</a></h2><p>In summary, I think the use cases for asyncio are limited (mostly for reasons beyond the control of <code>asyncio</code>) and this has constrained it&rsquo;s popularity. Maintaining duplicate code-bases is a burden.</p><p>FastAPI, the web framework that&rsquo;s <a href="https://www.starlette.io/">async from-the-ground-up</a> grew in <a href="https://blog.jetbrains.com/pycharm/2025/08/the-state-of-python-2025/#python-web-devs-resurgence">popularity again</a> from 29% to 38% share of the web frameworks for Python, taking the #1 spot. It has over 100-million downloads a month. Considering the big use-case for async is HTTP and network IO, having the #1 web framework be an async one is a sign of asyncio&rsquo;s success. </p><p>I think in 3.14 the sub-interpreter executor and free-threading features make more parallel and concurrency use cases practical and useful. For those, we don&rsquo;t need <code>async</code> APIs and it alleviates much of the issues I highlighted in this post.</p><h2>Related Posts</h2> </div></section>]]></description><pubDate>Wed, 03 Sep 2025 02:41:00 +0530</pubDate></item></channel></rss>
